<?xml version="1.0" encoding="UTF-8"?>
<model version="4.4.0" links="0">
 <framework name="qpn"/>
 <package name="AOs" stereotype="0x02">
  <class name="DKbIn" superclass="qpn::QActive">
   <operation name="shiftIn32" type="uint32_t" visibility="0x00" properties="0x00">
    <code>uint32_t myDataIn = 0;

for (int i=31; i&gt;=0; i--)
{
  digitalWrite(CLOCKPIN_IN, 0);
  delayMicroseconds(2);
  int temp = digitalRead(DATAPIN_IN);
  if (temp) {
    bitSet(myDataIn, i);
    // Debug: Serial.print(i);
  }
  digitalWrite(CLOCKPIN_IN, 1);
}
return myDataIn;
</code>
   </operation>
   <statechart>
    <initial target="../1">
     <action>QActive_armX((QActive *)me, 0U,
  DKBREADINVERVAL,
  DKBREADINVERVAL);

pinMode(LATCHPIN_IN, OUTPUT);
pinMode(CLOCKPIN_IN, OUTPUT);
pinMode(DATAPIN_IN,  INPUT);

Serial.println(F(&quot;DKbIn Initialized&quot;));</action>
     <initial_glyph conn="9,5,5,0,14,5">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="Read">
     <tran trig="Q_TIMEOUT">
      <action brief="shift in">digitalWrite(LATCHPIN_IN, 1);
delayMicroseconds(20);
digitalWrite(LATCHPIN_IN, 0);
uint32_t dkbin = DKbIn_shiftIn32(me);
// Debug: Serial.println(dkbin, HEX);

if (dkbin != 0) {
  processDKb((QMActive*)&amp;AO_Application, dkbin);
}</action>
      <tran_glyph conn="14,17,3,-1,16">
       <action box="0,-2,19,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="14,10,26,13"/>
    </state>
    <state_diagram size="52,30"/>
   </statechart>
  </class>
  <class name="DKbOut" superclass="qpn::QActive">
   <statechart>
    <initial target="../1">
     <action>pinMode(CLOCKPIN_OUT, OUTPUT);
pinMode(LATCHPIN_OUT, OUTPUT);
pinMode(DATAPIN_OUT,  OUTPUT);

Serial.println(F(&quot;DKbOut Initialized&quot;));</action>
     <initial_glyph conn="9,3,5,0,11,3">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="LED">
     <initial target="../6">
      <initial_glyph conn="15,10,5,0,17,4">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <tran trig="REMOTE_MODE" target="../7">
      <tran_glyph conn="6,45,3,3,20">
       <action box="0,-2,14,2"/>
      </tran_glyph>
     </tran>
     <tran trig="CALIBRATION_MODE" target="../8">
      <tran_glyph conn="6,57,3,3,20">
       <action box="0,-2,16,2"/>
      </tran_glyph>
     </tran>
     <tran trig="PRESET_MODE" target="../5">
      <tran_glyph conn="6,31,3,3,20">
       <action box="0,-2,13,2"/>
      </tran_glyph>
     </tran>
     <tran trig="MANUAL_MOTION_MODE" target="../6">
      <tran_glyph conn="6,20,3,3,20">
       <action box="0,-2,21,2"/>
      </tran_glyph>
     </tran>
     <state name="PreSetLED">
      <entry>// Debug: Serial.println(F(&quot;DKbOut: Enter PreSetLED&quot;));

byte whichPin = 0; // DKb r0: 4;
byte bitsToSend = 0;

digitalWrite(LATCHPIN_OUT, LOW);
bitWrite(bitsToSend, whichPin, HIGH);
shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
digitalWrite(LATCHPIN_OUT, HIGH);</entry>
      <state_glyph node="26,27,22,10">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="ManualMotionLED">
      <entry>// Debug: Serial.println(F(&quot;DKbOut: Enter ManualMotionLED&quot;));

byte whichPin = 1; // DKb r0: 5;
byte bitsToSend = 0;

digitalWrite(LATCHPIN_OUT, LOW);
bitWrite(bitsToSend, whichPin, HIGH);
shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
digitalWrite(LATCHPIN_OUT, HIGH);</entry>
      <state_glyph node="26,14,22,10">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="RemoteLED">
      <entry>// Debug: Serial.println(F(&quot;DKbOut: Enter RemoteLED&quot;));

byte whichPin = 3; // DKb r0: 2;
byte bitsToSend = 0;

digitalWrite(LATCHPIN_OUT, LOW);
bitWrite(bitsToSend, whichPin, HIGH);
shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
digitalWrite(LATCHPIN_OUT, HIGH);</entry>
      <state_glyph node="26,40,22,10">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="CalibrationLED">
      <entry>// Debug: Serial.println(F(&quot;DKbOut: Enter CalibrationLED&quot;));

byte whichPin = 2; // DKb r0: 3;
byte bitsToSend = 0;

digitalWrite(LATCHPIN_OUT, LOW);
bitWrite(bitsToSend, whichPin, HIGH);
shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
digitalWrite(LATCHPIN_OUT, HIGH);</entry>
      <state_glyph node="26,53,22,10">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="6,6,50,61"/>
    </state>
    <state_diagram size="97,81"/>
   </statechart>
  </class>
  <class name="MotorsOut" superclass="qpn::QActive">
   <attribute name="servoPosition[NUMSERVOS]" type="uint8_t" visibility="0x00" properties="0x00"/>
   <attribute name="target[NUMSERVOS]" type="uint8_t" visibility="0x00" properties="0x00"/>
   <attribute name="stepSize[NUMSERVOS]" type="uint8_t" visibility="0x00" properties="0x00"/>
   <attribute name="_sendPositionCounter" type="uint16_t" visibility="0x00" properties="0x00"/>
   <attribute name="initializeCounter" type="uint8_t" visibility="0x00" properties="0x00"/>
   <operation name="isInitialized" type="bool" visibility="0x00" properties="0x00">
    <code>return me-&gt;initializeCounter == NUMSERVOS;</code>
   </operation>
   <statechart>
    <initial target="../2">
     <action>// Give the capacitor time to load
QActive_armX((QActive *)me, 0U,
  MOTORSTARTUPDELAY*5,
  MOTORSTARTUPDELAY*5);

servoLib.begin();
me-&gt;initializeCounter = 0;

Serial.println(F(&quot;MotorOut Initialized&quot;));</action>
     <initial_glyph conn="6,7,5,3,18">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>// Timings:
// servoLib.write for 16 motors takes 9 ms
// Serial print takes 0.2 ms
// Meassured with the oscilloscope and digitalWrite(HIGH/LOW)</documentation>
     <entry>//
Serial.println(F(&quot;MotorsOut: Enter Active&quot;));</entry>
     <initial target="../3">
      <initial_glyph conn="51,38,4,0,3">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <tran trig="MOTOR_STEP_FORWARD">
      <action>uint32_t par = Q_PAR(me);
MotorEvArgs data(par);
// Debug: Serial.println(par, HEX);

me-&gt;stepSize[data.ServoNum] = data.StepSize;
int pos = me-&gt;servoPosition[data.ServoNum] + data.Pos;
if (pos &lt; 0) { pos = 0; }
else if (pos &gt; 255) { pos = 255; }

me-&gt;target[data.ServoNum] = pos;</action>
      <tran_glyph conn="24,29,3,-1,21">
       <action box="0,-2,23,2"/>
      </tran_glyph>
     </tran>
     <tran trig="MOTOR_STEP_BACKWARD">
      <action>uint32_t par = Q_PAR(me);
MotorEvArgs data(par);
// Debug: Serial.println(par, HEX);

me-&gt;stepSize[data.ServoNum] = data.StepSize;
// Debug: Serial.println(data.StepSize);
int pos = me-&gt;servoPosition[data.ServoNum] - data.Pos;
if (pos &lt; 0) { pos = 0; }
else if (pos &gt; 255) { pos = 255; }

me-&gt;target[data.ServoNum] = pos;</action>
      <tran_glyph conn="24,34,3,-1,21">
       <action box="0,-2,22,2"/>
      </tran_glyph>
     </tran>
     <state name="Simulation">
      <entry>Serial.println(F(&quot;MotorsOut: Enter Simulation&quot;));</entry>
      <tran trig="Q_TIMEOUT">
       <action>
#ifdef SERIALIN
bool isMoving = false;
#endif

for (int n=0; n &lt; NUMSERVOS; n++) {

  int newPos = me-&gt;servoPosition[n];
  if (me-&gt;servoPosition[n] &lt; me-&gt;target[n]) {
    newPos = min(me-&gt;servoPosition[n]+me-&gt;stepSize[n], me-&gt;target[n]);
  }
  if (me-&gt;target[n] &lt; me-&gt;servoPosition[n]) {
    newPos = max(me-&gt;servoPosition[n]-me-&gt;stepSize[n], me-&gt;target[n]);
  }
  if (newPos != me-&gt;servoPosition[n]) {
    me-&gt;servoPosition[n] = newPos;
    #ifdef SERIALIN
    isMoving = true;
    #endif
    servoLib.write(n, me-&gt;servoPosition[n]);
  }
}

#ifdef SERIALIN
if (!isMoving) {
  if (me-&gt;_sendPositionCounter % NUMSERVOS == 0) {
    int servo = (me-&gt;_sendPositionCounter / NUMSERVOS) - 1;
    Serial.print(&quot;|&quot;);
    Serial.print(servo);
    Serial.print(me-&gt;servoPosition[servo]);
    Serial.print(&quot;|&quot;);
    if (me-&gt;_sendPositionCounter == (NUMSERVOS * NUMSERVOS)) me-&gt;_sendPositionCounter = 0;
  }
  me-&gt;_sendPositionCounter++;
}
#endif</action>
       <tran_glyph conn="29,58,3,-1,12">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="CALIBRATION_MODE" target="../../4">
       <action>Serial.println(F(&quot;MotorsOut: Enter Calibration&quot;));

for (int n = 0; n &lt; NUMSERVOS; n++) {
  servoLib.write(n, 100);
  me-&gt;servoPosition[n] = 100;
  me-&gt;target[n] = 100;
  me-&gt;stepSize[n] = 1;
}</action>
       <tran_glyph conn="54,54,1,3,11">
        <action box="0,-2,17,2"/>
       </tran_glyph>
      </tran>
      <tran trig="MOTOR_MOVE_ASOLUTE">
       <action>uint32_t par = Q_PAR(me);
MotorEvArgs data(par);
// Debug: Serial.println(par, HEX);

me-&gt;stepSize[data.ServoNum] = data.StepSize;
if (data.Pos &gt;= 0 &amp;&amp; data.Pos &lt;= 255) {
  me-&gt;target[data.ServoNum] = data.Pos;
} else {
  me-&gt;target[data.ServoNum] = me-&gt;servoPosition[data.ServoNum];
}</action>
       <tran_glyph conn="29,51,3,-1,20">
        <action box="0,-2,23,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="29,41,25,21">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Calibration">
      <entry>// Debug: crashes the application Serial.println(F(&quot;MotorsOut: Enter Calibration&quot;));</entry>
      <tran trig="Q_TIMEOUT">
       <action>
#ifdef SERIALIN
bool isMoving = false;
#endif

for (int n=0; n &lt; NUMSERVOS; n++) {

  int newPos = me-&gt;servoPosition[n];
  if (me-&gt;servoPosition[n] &lt; me-&gt;target[n]) {
    newPos = min(me-&gt;servoPosition[n]+me-&gt;stepSize[n], me-&gt;target[n]);
  }
  if (me-&gt;target[n] &lt; me-&gt;servoPosition[n]) {
    newPos = max(me-&gt;servoPosition[n]-me-&gt;stepSize[n], me-&gt;target[n]);
  }
  if (newPos != me-&gt;servoPosition[n]) {
    me-&gt;servoPosition[n] = newPos;
    #ifdef SERIALIN
    isMoving = true;
    #endif
    servoLib.write(n, me-&gt;servoPosition[n]);
  }
}

#ifdef SERIALIN
if (!isMoving) {
  if (me-&gt;_sendPositionCounter % NUMSERVOS  == 0) {
    int servo = (me-&gt;_sendPositionCounter / NUMSERVOS) - 1;
    Serial.print(&quot;|&quot;);
    Serial.print(servo);
    Serial.print(me-&gt;servoPosition[servo] * 2 + 100);
    Serial.print(&quot;|&quot;);
    if (me-&gt;_sendPositionCounter == (NUMSERVOS * 10)) me-&gt;_sendPositionCounter = 0;
  }
  me-&gt;_sendPositionCounter++;
}
#endif</action>
       <tran_glyph conn="65,58,3,-1,12">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="65,44,18,18">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="24,21,60,44">
      <entry box="1,2,6,2"/>
     </state_glyph>
    </state>
    <state name="Wait">
     <tran trig="Q_TIMEOUT">
      <action>QActive_armX((QActive *)me, 0U,
  MOTORSTARTUPDELAY,
  MOTORSTARTUPDELAY);</action>
      <choice target="../../../1">
       <guard brief="is initialized">MotorsOut_isInitialized(me)</guard>
       <action>QActive_armX((QActive *)me, 0U,
  MOTORSENDINTERVAL,
  MOTORSENDINTERVAL);

Serial.println(F(&quot;MotorsOut: Enter Active&quot;));</action>
       <choice_glyph conn="41,12,4,0,9">
        <action box="-11,2,11,2"/>
       </choice_glyph>
      </choice>
      <choice>
       <guard brief="else">!MotorsOut_isInitialized(me)</guard>
       <action>// Debug: Serial.print(&quot;Initialize: &quot;); Serial.println(me-&gt;initializeCounter);

servoLib.write(me-&gt;initializeCounter, 127);
me-&gt;servoPosition[me-&gt;initializeCounter] = 127;
me-&gt;target[me-&gt;initializeCounter] = 127;
me-&gt;stepSize[me-&gt;initializeCounter] = 1;

me-&gt;initializeCounter++;</action>
       <choice_glyph conn="41,12,5,-1,6">
        <action box="1,-3,10,2"/>
       </choice_glyph>
      </choice>
      <tran_glyph conn="24,12,3,-1,17">
       <action box="0,-3,12,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="24,4,28,10"/>
    </state>
    <state_diagram size="89,81"/>
   </statechart>
  </class>
  <class name="SerialIn" superclass="qpn::QActive">
   <attribute name="remainingBytes" type="uint8_t" visibility="0x00" properties="0x00"/>
   <operation name="processRemainingBytes" type="void" visibility="0x00" properties="0x00">
    <code>while (me-&gt;remainingBytes &gt; 1 &amp;&amp; Serial.available() &gt; 1) {
  uint8_t tmpLow = Serial.read();
  uint8_t tmpHigh = Serial.read();
  // Debug: Serial.println(tmpLow, HEX); Serial.println(tmpHigh, HEX);
  uint16_t rawData = (tmpHigh &lt;&lt; 8) | tmpLow;
  #ifdef MOTOROUT
  MotorEvArgs motorOut(rawData);
  // Debug:
  // Serial.println(F(&quot;Serial motor in&quot;));
  // Serial.print(F(&quot;Servo Num: &quot;));
  // Serial.println(motorOut.ServoNum);
  // Serial.print(F(&quot;Step Size: &quot;));
  // Serial.println(motorOut.StepSize);
  // Serial.print(F(&quot;Servo Position: &quot;));
  // Serial.println(motorOut.Pos);
  QACTIVE_POST((QMActive *)&amp;AO_Application, MOTOR_MOVE_ASOLUTE_SIG, motorOut.raw);
  #endif
  me-&gt;remainingBytes -= 2;
}</code>
   </operation>
   <statechart>
    <initial target="../1">
     <action>QActive_armX((QActive *)me, 0U,
  SERIALRECVINVERVAL,
  SERIALRECVINVERVAL);

me-&gt;remainingBytes = 0;

Serial.println(F(&quot;SerialIn Initialized&quot;));</action>
     <initial_glyph conn="26,12,5,0,13,6">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="Receive">
     <tran trig="Q_TIMEOUT">
      <action>// process unfinished command
if (me-&gt;remainingBytes != 0) {
  // Debug: Serial.print(&quot;Process unfinished cmd: &quot;); Serial.println(me-&gt;remainingBytes);
  SerialIn_processRemainingBytes(me);
}
else if (Serial.available() &gt; 0) {
  int serin = Serial.read();
  //Debug: Serial.println(serin, HEX);

  if (serin &gt; -1) {
    SerialInEvArgs input(serin);
    // Debug: Serial.print(F(&quot;Serial Byte: Cmd: 0x&quot;));
    // Debug: Serial.println(input.getCmd(), HEX);
    // Debug: Serial.print(F(&quot;Data &quot;));
    // Debug: Serial.println(input.Data, BIN);

    if (input.getCmd() == SOFTDKB) {
      // Debug: Serial.println(F(&quot; SOFTDKB&quot;));
      // Command 1: SoftDKb. The same bit is set as from the shift registers of the hardware DKb.
      processSoftDKb((QMActive*)&amp;AO_Application, input);
    }
    else if (input.getCmd() == ABSMOVE) {
      // Command 2: Absolute motion for the motors. Each motor requires 16bit/2 bytes.
      me-&gt;remainingBytes = (serin &gt;&gt; 3);
      // Debug: Serial.print(F(&quot;Num bytes: &quot;)); Serial.println(me-&gt;remainingBytes);
      // It is possible that not all bytes are in the serial-in buffer.
      SerialIn_processRemainingBytes(me);
    }
    else if (input.getCmd() == FREEMEM) {
      // Send free memory
      Serial.print(F(&quot;|E&quot;));
      // Debug: int* p = new int[10];
      // if (p == 0) { Serial.print(999); )
      Serial.print(freeMemory());
      Serial.print(F(&quot;|&quot;));
    }
    else if (input.getCmd() == SYNC) {
      // Send sync
      Serial.print(F(&quot;Synced&quot;));
    }
  }
}</action>
      <tran_glyph conn="30,27,3,-1,12">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="30,18,16,12"/>
    </state>
    <state_diagram size="80,50"/>
   </statechart>
  </class>
  <class name="Application" superclass="qpn::QActive">
   <attribute name="speed" type="uint8_t" visibility="0x00" properties="0x00"/>
   <attribute name="currentPreSet" type="uint8_t" visibility="0x00" properties="0x00"/>
   <attribute name="preSetTimer" type="uint16_t" visibility="0x00" properties="0x00"/>
   <operation name="isCurrentPreSet" type="bool" visibility="0x00" properties="0x00">
    <code>Serial.println(&quot;PreSet isCurrentPreSet&quot;);

ProgramChangeEvArgs args(Q_PAR(me));
return me-&gt;currentPreSet == args.ProgNo;</code>
   </operation>
   <statechart>
    <initial target="../2">
     <action>QActive_armX((QActive *)me, 0U,
  PRESETTIMERINTERVAL,
  PRESETTIMERINTERVAL);</action>
     <initial_glyph conn="23,6,5,3,9">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="Calibration">
     <entry>Serial.println(F(&quot;Calibration&quot;));

me-&gt;speed = 1;

#ifdef DKBOUT
QACTIVE_POST((QMActive*)&amp;AO_DKbOut, CALIBRATION_MODE_SIG, 0L);
#endif

#ifdef MOTOROUT

servoLib.end();
impl.Calibration = true;
servoLib.begin();
delay(20);

QACTIVE_POST((QMActive*)&amp;AO_MotorsOut, CALIBRATION_MODE_SIG, 0L);

#endif</entry>
     <tran trig="MOTOR_MOVE_RELATIVE">
      <action>// Debug: Serial.println(&quot;Calibration Motor Button Pressed&quot;);

MotorMoveRelativeEvArgs args(Q_PAR(me));
uint8_t step = (me-&gt;speed / 3) + 1;
uint8_t dir = args.getDirection() == FORWARDS ? MOTOR_STEP_FORWARD_SIG : MOTOR_STEP_BACKWARD_SIG;
// Debug: Serial.print(&quot;Servo Num: &quot;); Serial.println(args.ServoNum);

#ifdef MOTOROUT
  MotorEvArgs m(args.ServoNum, me-&gt;speed, step);
  QACTIVE_POST((QMActive *)&amp;AO_MotorsOut, dir, m.raw);
#endif</action>
      <tran_glyph conn="3,73,3,-1,12">
       <action box="0,-3,22,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="3,65,26,13">
      <entry box="1,2,6,2"/>
     </state_glyph>
    </state>
    <state name="Simulation">
     <entry>Serial.println(&quot;Simulation entry&quot;);</entry>
     <initial target="../4">
      <action>me-&gt;speed = 4;</action>
      <initial_glyph conn="34,7,5,3,4">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <state name="ManualMotion">
      <entry>Serial.println(F(&quot;ManualMotion entry&quot;));

#ifdef DKBOUT
QACTIVE_POST((QMActive *)&amp;AO_DKbOut, MANUAL_MOTION_MODE_SIG, 0L);
#endif</entry>
      <tran trig="MOTOR_MOVE_RELATIVE">
       <action>// Debug: Serial.print(F(&quot;ManualMotion Motor Button Pressed&quot;));

MotorMoveRelativeEvArgs args(Q_PAR(me));
uint8_t step = (me-&gt;speed / 3) + 1;
uint8_t dir = args.getDirection() == FORWARDS ? MOTOR_STEP_FORWARD_SIG : MOTOR_STEP_BACKWARD_SIG;
//Debug: Serial.print(&quot;Servo Num: &quot;); Serial.println(args.ServoNum);

#ifdef MOTOROUT
  MotorEvArgs m(args.ServoNum, me-&gt;speed, step);
  QACTIVE_POST((QMActive *)&amp;AO_MotorsOut, dir, m.raw);
#endif</action>
       <tran_glyph conn="36,23,3,-1,18">
        <action box="0,-2,21,2"/>
       </tran_glyph>
      </tran>
      <tran trig="PROGRAM_CHANGE">
       <action>Serial.println(&quot;ManualMotion Program Button Pressed&quot;);

ProgramChangeEvArgs args(Q_PAR(me));
me-&gt;speed = args.ProgNo;</action>
       <tran_glyph conn="36,26,3,-1,18">
        <action box="0,-2,18,2"/>
       </tran_glyph>
      </tran>
      <tran trig="PRESET_MODE" target="../../2">
       <action>Serial.println(F(&quot;StateChange PreSet |B|&quot;));</action>
       <tran_glyph conn="64,22,1,3,17">
        <action box="0,-2,16,2"/>
       </tran_glyph>
      </tran>
      <tran trig="REMOTE_MODE" target="../../3">
       <action>Serial.println(F(&quot;StateChange Remote |C|&quot;));</action>
       <tran_glyph conn="48,29,2,0,20">
        <action box="0,0,17,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="36,16,28,13">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="PreSet">
      <entry>Serial.println(F(&quot;PreSet entry&quot;));

#ifdef DKBOUT
QACTIVE_POST((QMActive *)&amp;AO_DKbOut, PRESET_MODE_SIG, 0L);
#endif</entry>
      <initial target="../3">
       <initial_glyph conn="94,18,4,0,4">
        <action box="0,-2,10,2"/>
       </initial_glyph>
      </initial>
      <tran trig="REMOTE_MODE" target="../../3">
       <action>Serial.println(F(&quot;StateChange Remote |C|&quot;));</action>
       <tran_glyph conn="88,58,2,1,3,-21">
        <action box="1,1,15,2"/>
       </tran_glyph>
      </tran>
      <tran trig="MANUAL_MOTION_MODE" target="../../1">
       <action>Serial.println(F(&quot;StateChange ManualMotion |A|&quot;));</action>
       <tran_glyph conn="81,28,3,1,-15,-3,-2">
        <action box="-14,0,19,2"/>
       </tran_glyph>
      </tran>
      <state name="Wait">
       <entry>Serial.println(F(&quot;PreSet Wait&quot;));

me-&gt;preSetTimer = 0;</entry>
       <tran trig="PROGRAM_CHANGE" target="../../4">
        <action>Serial.println(&quot;PreSet Program Button Pressed&quot;);

ProgramChangeEvArgs args(Q_PAR(me));
me-&gt;currentPreSet = args.ProgNo;
me-&gt;preSetTimer = 0;</action>
        <tran_glyph conn="88,28,2,0,6">
         <action box="0,0,17,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="83,22,24,6">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state name="Run">
       <entry>Serial.println(F(&quot;PreSet Run&quot;));</entry>
       <tran trig="PROGRAM_CHANGE">
        <choice target="../../../3">
         <guard brief="else"/>
         <choice_glyph conn="95,43,5,2,10,-15">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="current PreSet">Application_isCurrentPreSet(me)</guard>
         <choice_glyph conn="95,43,4,-1,5">
          <action box="-11,1,13,3"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="83,43,3,-1,12">
         <action box="0,-3,17,3"/>
        </tran_glyph>
       </tran>
       <tran trig="Q_TIMEOUT">
        <action>#ifdef MOTOROUT

if (me-&gt;currentPreSet == 1) {
  Serial.println(me-&gt;preSetTimer);
  prog1((QMActive*)&amp;AO_MotorsOut, me-&gt;preSetTimer);
}
else if (me-&gt;currentPreSet == 2) {
  prog2((QMActive*)&amp;AO_MotorsOut, me-&gt;preSetTimer);
}
else if (me-&gt;currentPreSet == 3) {
 prog3((QMActive*)&amp;AO_MotorsOut, me-&gt;preSetTimer);
}
else if (me-&gt;currentPreSet == 4) {
  prog4((QMActive*)&amp;AO_MotorsOut, me-&gt;preSetTimer);
}
else if (me-&gt;currentPreSet == 5) {
  prog5((QMActive*)&amp;AO_MotorsOut, me-&gt;preSetTimer);
}
else if (me-&gt;currentPreSet == 6) {
  prog6((QMActive*)&amp;AO_MotorsOut, me-&gt;preSetTimer);
}
else if (me-&gt;currentPreSet == 7) {
  prog7((QMActive*)&amp;AO_MotorsOut, me-&gt;preSetTimer);
}
else if (me-&gt;currentPreSet == 8) {
  prog8((QMActive*)&amp;AO_MotorsOut, me-&gt;preSetTimer);
}

#endif</action>
        <tran_glyph conn="83,51,3,-1,15">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="83,34,24,19">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="81,14,29,44">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Remote">
      <entry>Serial.println(F(&quot;Remote&quot;));

#ifdef DKBOUT
QACTIVE_POST((QMActive *)&amp;AO_DKbOut, REMOTE_MODE_SIG, 0L);
#endif</entry>
      <tran trig="CALIBRATION_MODE" target="../../../1">
       <action>Serial.println(F(&quot;StateChange Calibration |D|&quot;));</action>
       <tran_glyph conn="44,56,3,0,-22,9">
        <action box="-16,-2,18,2"/>
       </tran_glyph>
      </tran>
      <tran trig="MOTOR_MOVE_ASOLUTE">
       <action>// Debug: Serial.println(&quot;Remote Motor Move Absolute&quot;);

//MotorEvArgs args(rawData);
#ifdef MOTOROUT
  QACTIVE_POST((QMActive *)&amp;AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, Q_PAR(me));
#endif</action>
       <tran_glyph conn="44,60,3,-1,9">
        <action box="0,-2,22,2"/>
       </tran_glyph>
      </tran>
      <tran trig="PRESET_MODE" target="../../2">
       <action>Serial.println(F(&quot;StateChange PreSet |B|&quot;));</action>
       <tran_glyph conn="62,49,0,3,-8,19">
        <action box="0,-2,14,2"/>
       </tran_glyph>
      </tran>
      <tran trig="MANUAL_MOTION_MODE" target="../../1">
       <action>Serial.println(F(&quot;StateChange ManualMotion |A|&quot;));</action>
       <tran_glyph conn="46,49,0,2,-20">
        <action box="-20,-2,23,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="44,49,23,14">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Init">
      <tran trig="Q_TIMEOUT">
       <choice target="../../../1">
        <guard brief="DKb connected">isDKbEnabled()</guard>
        <action>Serial.println(F(&quot;StateChange ManualMotion |A|&quot;));</action>
        <choice_glyph conn="48,9,5,0,13,7">
         <action box="1,0,12,2"/>
        </choice_glyph>
       </choice>
       <choice target="../../../3">
        <guard brief="else"/>
        <action>Serial.println(F(&quot;StateChange Remote |C|&quot;));</action>
        <choice_glyph conn="48,9,4,3,5,-15,39,11">
         <action box="-4,1,10,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="38,9,3,-1,10">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="38,4,34,8"/>
     </state>
     <state_glyph node="32,2,80,77">
      <entry box="1,2,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="113,86"/>
   </statechart>
  </class>
 </package>
 <directory name=".">
  <file name="gris5A.ino">
   <text>/* gris5A.qm - Arduino software for the GRIS5A (C) motion phantom
 * Copyright (C) 2018-2019 by Stefan Grimm
 */

#include &quot;qpn.h&quot;
#include &quot;Arduino.h&quot;

#define GRIS5A 1
//#define NO2 1

#define DKBIN
#define DKBOUT
#define SERIALIN
#define MOTOROUT

#ifdef GRIS5A
#define NUMSERVOS 10
#elif NO2
#define NUMSERVOS 6
#endif

#define Q_PARAM_SIZE 4

#include &quot;FreeMemory.h&quot;
#include &quot;dkb.h&quot;
#include &quot;preset.h&quot;
#include &quot;events.h&quot;
#include &quot;constants.h&quot;

#ifdef MOTOROUT
#include &quot;_Adafruit_PWMServoDriver.h&quot;
#include &quot;prfServo2.h&quot;

class ServoShieldPCA9685Linear : public prfServo2ImplBase&lt;uint16_t, float&gt; {
  public:
  ServoShieldPCA9685Linear(Adafruit_PWMServoDriver&amp; pwm) : _pwm(pwm) {
    Calibration = false;
  }

  bool Calibration;

  void begin() {
    _pwm.begin();
    _pwm.setPWMFreq(60);
    // Set pwm signal to off.
    // The servo shield does not like signal when it is powered. 1.5 Amperes are flowing.
    // setPWMOn() has interestingly the same effect.
    _pwm.setPWMOff();
  }

  void get(float** params, float** offsets) const {
    #ifdef GRIS5A
    if (!Calibration) {
    // LURTN
    params[0][0] = 1.2942268654268088e+002;
    params[0][1] = 1.6668375402407262e+000;
    offsets[0][0] = 0;
    // LULNG
    params[1][0] = 5.5452380952380930e+002;
    params[1][1] = -2.6484593837534930e+000;
    params[1][2] = 1.1929477673422232e-002;
    params[1][3] = -2.7138883234954693e-005;
    offsets[1][0] = 0;
    // LLRTN
    params[2][0] = 1.5442914556378040e+002;
    params[2][1] = 1.5882527835305206e+000;
    offsets[2][0] = 0;
    // LLLNG
    params[3][0] = 1.3666666666666668e+002;
    params[3][1] = 2.8253968253968250e+000;
    params[3][2] = -1.3016971494480146e-002;
    params[3][3] = 3.0757400999615536e-005;
    offsets[3][0] = 0;
    // RLLNG
    params[4][0] = 5.7880952380952260e+002;
    params[4][1] = -2.3641456582632174e+000;
    params[4][2] = 9.3590377327392710e-003;
    params[4][3] = -2.1711106587961670e-005;
    offsets[4][0] = 0;
    // RLRTN
    params[5][0] = 1.3774938998134064e+002;
    params[5][1] = 1.5490885603559636e+000;
    offsets[5][0] = 0;
    // RULNG
    params[6][0] = 1.8559523809523685e+002;
    params[6][1] = 2.1031746031746907e+000;
    params[6][2] = -7.4147305981224840e-003;
    params[6][3] = 1.8092588823305492e-005;
    offsets[6][0] = 0;
    // RURTN
    params[7][0] = 1.6024944124341286e+002;
    params[7][1] = 1.6079886813344540e+000;
    offsets[7][0] = 0;
    // GALNG
    params[8][0] = 5.3464285714285590e+002;
    params[8][1] = -2.8109243697478114e+000;
    params[8][2] = 1.3346515076618000e-002;
    params[8][3] = -3.2566659881943620e-005;
    offsets[8][0] = 0;
    // GARTN
    params[9][0] = 1.4526246180975622e+002;
    params[9][1] = 1.5686194098710244e+000;
    offsets[9][0] = 0;
    }
    else {
    // LURTN
    params[0][0] = 100;
    params[0][1] = 2;
    offsets[0][0] = 0;
    // LULNG
    params[1][0] = 100;
    params[1][1] = 2;
    params[1][2] = 0;
    params[1][3] = 0;
    offsets[1][0] = 0;
    // LLRTN
    params[2][0] = 100;
    params[2][1] = 2;
    offsets[2][0] = 0;
    // LLLNG
    params[3][0] = 100;
    params[3][1] = 2;
    params[3][2] = 0;
    params[3][3] = 0;
    offsets[3][0] = 0;
    // RLLNG
    params[4][0] = 100;
    params[4][1] = 2;
    params[4][2] = 0;
    params[4][3] = 0;
    offsets[4][0] = 0;
    // RLRTN
    params[5][0] = 100;
    params[5][1] = 2;
    offsets[5][0] = 0;
    // RULNG
    params[6][0] = 100;
    params[6][1] = 2;
    params[6][2] = 0;
    params[6][3] = 0;
    offsets[6][0] = 0;
    // RURTN
    params[7][0] = 100;
    params[7][1] = 2;
    offsets[7][0] = 0;
    // GALNG
    params[8][0] = 100;
    params[8][1] = 2;
    params[8][2] = 0;
    params[8][3] = 0;
    offsets[8][0] = 0;
    // GARTN
    params[9][0] = 100;
    params[9][1] = 2;
    offsets[9][0] = 0;
    }
    #elif NO2
    if (!Calibration) {
    // LLLNG
    params[0][0] = 5.3400000000000000e+002;
    params[0][1] = -1.5833333333333320e+000;
    params[0][2] = 3.6621093749999844e-003;
    params[0][3] = -6.3578287760416260e-006;
    offsets[0][0] = -1.3322676295501878e-015;
    offsets[0][1] = 7.8125000000000080e-002;
    offsets[0][2] = -2.4414062500000030e-004;
    // RLLNG
    params[1][0] = 2.3420000000000002e+002;
    params[1][1] = 1.5338541666666618e+000;
    params[1][2] = -3.6621093749999460e-003;
    params[1][3] = 6.9936116536456924e-006;
    offsets[1][0] = -4.0000000000000000e+000;
    offsets[1][1] = 1.5625000000000000e-002;
    // GALNG
    params[2][0] = 1.8751428571428568e+002;
    params[2][1] = 2.1677827380952457e+000;
    params[2][2] = -6.6266741071429420e-003;
    params[2][3] = 1.0808308919271054e-005;
    offsets[2][0] = 0;
    // LLRTN
    params[3][0] = 1.9000000000000000e+002;
    params[3][1] = 1.3671874999999997e+000;
    params[3][2] = 5.4931640625000050e-004;
    offsets[3][0] = 0;
    // RLRTN
    params[4][0] = 1.2999999999999994e+002;
    params[4][1] = 1.3750000000000033e+000;
    params[4][2] = 6.1035156249998670e-004;
    offsets[4][0] = -4;
    // GARTN
    params[5][0] = 1.5000000000000000e+002;
    params[5][1] = 1.4843749999999997e+000;
    params[5][2] = 7.3242187500000060e-004;
    offsets[5][0] = 0;
    }
    else {
    // LLLNG
    params[0][0] = 100;
    params[0][1] = 2;
    params[0][2] = 0;
    params[0][3] = 0;
    offsets[0][0] = 0;
    offsets[0][1] = 0;
    offsets[0][2] = 0;
    // RLLNG
    params[1][0] = 100;
    params[1][1] = 2;
    params[1][2] = 0;
    params[1][3] = 0;
    offsets[1][0] = 0;
    offsets[1][1] = 0;
    // GALNG
    params[2][0] = 100;
    params[2][1] = 2;
    params[2][2] = 0;
    params[2][3] = 0;
    offsets[2][0] = 0;
    // LLRTN
    params[3][0] = 100;
    params[3][1] = 2;
    params[3][2] = 0;
    offsets[3][0] = 0;
    // RLRTN
    params[4][0] = 100;
    params[4][1] = 2;
    params[4][2] = 0;
    offsets[4][0] = 0;
    // GARTN
    params[5][0] = 100;
    params[5][1] = 2;
    params[5][2] = 0;
    offsets[5][0] = 0;
    }
    #endif
  }

  void write(uint8_t num, uint16_t servoVal) {
    _pwm.setPWM(num, 0, servoVal);
  }

  private:
  Adafruit_PWMServoDriver&amp; _pwm;
};

Adafruit_PWMServoDriver pwm;
ServoShieldPCA9685Linear impl(pwm);
#ifdef GRIS5A
prfServo2&lt;uint32_t, uint8_t, uint16_t, float&gt; servoLib(&amp;impl, 0x0777DD, 0x0);
#elif NO2
prfServo2&lt;uint16_t, uint8_t, uint16_t, float&gt; servoLib(&amp;impl, 0b101010111111, 0b000000000110);
#endif

#endif

//============================================================================
// declare all AO classes...
$declare(AOs::Application)
#ifdef DKBIN
$declare(AOs::DKbIn)
#endif
#ifdef SERIALIN
$declare(AOs::SerialIn)
#endif
#ifdef DKBOUT
$declare(AOs::DKbOut)
#endif
#ifdef MOTOROUT
$declare(AOs::MotorsOut)
#endif


// AO instances and event queue buffers for them...
Application AO_Application;
static QEvt l_ApplicationQSto[10];
#ifdef DKBIN
DKbIn AO_DKbIn;
static QEvt l_DKbInQSto[1];
#endif
#ifdef SERIALIN
SerialIn AO_SerialIn;
static QEvt l_SerialInQSto[1];
#endif
#ifdef DKBOUT
DKbOut AO_DKbOut;
static QEvt l_DKbOutQSto[1];
#endif
#ifdef MOTOROUT
MotorsOut AO_MotorsOut;
static QEvt l_MotorsOutQSto[NUMSERVOS*2];
#endif

//============================================================================
// events used in this application...
// events.h
// constants.h
//============================================================================

//============================================================================
// QF_active[] array defines all active object control blocks ----------------
QActiveCB const Q_ROM QF_active[] = {
  { (QActive*)0, (QEvt *)0, 0U}, // SGR: required...
  { (QActive*)&amp;AO_Application, l_ApplicationQSto, Q_DIM(l_ApplicationQSto) },
  #ifdef DKBIN
  { (QActive*)&amp;AO_DKbIn, l_DKbInQSto, Q_DIM(l_DKbInQSto) },
  #endif
  #ifdef SERIALIN
  { (QActive*)&amp;AO_SerialIn, l_SerialInQSto, Q_DIM(l_SerialInQSto) },
  #endif
  #ifdef DKBOUT
  { (QActive*)&amp;AO_DKbOut, l_DKbOutQSto, Q_DIM(l_DKbOutQSto) },
  #endif
  #ifdef MOTOROUT
  { (QActive*)&amp;AO_MotorsOut, l_MotorsOutQSto, Q_DIM(l_MotorsOutQSto) }
  #endif
};


//............................................................................
void setup() {
  // initialize the QF-nano framework
  QF_init(Q_DIM(QF_active));

  // initialize all AOs...
  QActive_ctor(&amp;AO_Application.super, Q_STATE_CAST(&amp;Application_initial));
  #ifdef DKBIN
  QActive_ctor(&amp;AO_DKbIn.super, Q_STATE_CAST(&amp;DKbIn_initial));
  #endif
  #ifdef SERIALIN
  QActive_ctor(&amp;AO_SerialIn.super, Q_STATE_CAST(&amp;SerialIn_initial));
  #endif
  #ifdef DKBOUT
  QActive_ctor(&amp;AO_DKbOut.super, Q_STATE_CAST(&amp;DKbOut_initial));
  #endif
  #ifdef MOTOROUT
  QActive_ctor(&amp;AO_MotorsOut.super, Q_STATE_CAST(&amp;MotorsOut_initial));
  #endif

  // initialize the hardware used in this sketch...
  Serial.begin(9600);   // Stanard baud rates: 9600, 38400, 115200 bps
  Serial.print(F(&quot;Synced&quot;));
  Serial.print(F(&quot;Start, QP-nano: &quot;));
  Serial.println(F(QP_VERSION_STR));

  // Send free memory
  Serial.print(F(&quot;|E&quot;));
  Serial.print(freeMemory());
  Serial.print(F(&quot;|&quot;));
}

//............................................................................
void loop() {
  QF_run(); // run the QF-nano framework
}

//============================================================================
// interrupts...
ISR(TIMER2_COMPA_vect) {
  QF_tickXISR(0); // process time events for tick rate 0
}

//============================================================================
// QF callbacks...
void QF_onStartup(void) {
  // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking...
  TCCR2A = (1U &lt;&lt; WGM21) | (0U &lt;&lt; WGM20);
  TCCR2B = (1U &lt;&lt; CS22 ) | (1U &lt;&lt; CS21) | (1U &lt;&lt; CS20); // 1/2^10
  ASSR  &amp;= ~(1U &lt;&lt; AS2);
  TIMSK2 = (1U &lt;&lt; OCIE2A); // enable TIMER2 compare Interrupt
  TCNT2  = 0U;

  // set the output-compare register based on the desired tick frequency
  OCR2A  = (F_CPU / BSP_TICKS_PER_SEC / 1024U) - 1U;
}
//............................................................................
void QV_onIdle(void) {   // called with interrupts DISABLED
  // Put the CPU and peripherals to the low-power mode. You might
  // need to customize the clock management for your application,
  // see the datasheet for your particular AVR MCU.
  SMCR = (0 &lt;&lt; SM0) | (1 &lt;&lt; SE); // idle mode, adjust to your project
  QV_CPU_SLEEP();  // atomically go to sleep and enable interrupts
}
//............................................................................
void Q_onAssert(char const Q_ROM* const file, int line) {
  // implement the error-handling policy for your application!!!
  QF_INT_DISABLE(); // disable all interrupts
  QF_RESET();  // reset the CPU
}

//============================================================================
// define all AO classes (state machine)...
$define(AOs::Application)
#ifdef DKBIN
$define(AOs::DKbIn)
#endif
#ifdef SERIALIN
$define(AOs::SerialIn)
#endif
#ifdef DKBOUT
$define(AOs::DKbOut)
#endif
#ifdef MOTOROUT
$define(AOs::MotorsOut)
#endif
</text>
  </file>
  <file name="FreeMemory.h">
   <text>// Copied from:
// https://learn.adafruit.com/memories-of-an-arduino/measuring-free-memory

#ifndef __FREEMEMORY_H
#define __FREEMEMORY_H

#ifdef __arm__
// should use uinstd.h to define sbrk but Due causes a conflict
extern &quot;C&quot; char* sbrk(int incr);
#else  // __ARM__
extern char *__brkval;
#endif  // __arm__

int freeMemory() {
  char top;
#ifdef __arm__
  return &amp;top - reinterpret_cast&lt;char*&gt;(sbrk(0));
#elif defined(CORE_TEENSY) || (ARDUINO &gt; 103 &amp;&amp; ARDUINO != 151)
  return 1 + (&amp;top - __brkval);
#else  // __arm__
  return 1 + (__brkval ? &amp;top - __brkval : &amp;top - __malloc_heap_start);
#endif  // __arm__
}

#endif</text>
  </file>
  <file name="dkb.h">
   <text>/* dkb.h - Arduino software for the GRIS5A (C) motion phantom
 * Copyright (C) 2019 by Stefan Grimm
 */

#ifndef __DKB_H
#define __DKB_H

#include &quot;qpn.h&quot;
#include &quot;events.h&quot;

struct DKbInEvArgs {
  DKbInEvArgs () : raw(0) {}
  DKbInEvArgs (const DKbInEvArgs&amp; t) : raw(t.raw) {}
  DKbInEvArgs (uint32_t rawValue) : raw(rawValue) {}
  union {
    struct {
      uint32_t GAL : 1;
      uint32_t GAT : 1;
      uint32_t GAB : 1;
      uint32_t GAR : 1;
      uint32_t FP7 : 1;
      uint32_t FP6 : 1;
      uint32_t FP5 : 1;
      uint32_t FP8 : 1;
      uint32_t RLB : 1;
      uint32_t RLR : 1;
      uint32_t RLL : 1;
      uint32_t RLT : 1;
      uint32_t RUR : 1;
      uint32_t RUL : 1;
      uint32_t RUT : 1;
      uint32_t RUB : 1;
      uint32_t FP4 : 1;
      uint32_t FP3 : 1;
      uint32_t FP2 : 1;
      uint32_t FP1 : 1;
      uint32_t FRM : 1;
      uint32_t FPS : 1;
      uint32_t FMM : 1;
      uint32_t FCA : 1;
      uint32_t LLB : 1;
      uint32_t LLR : 1;
      uint32_t LLL : 1;
      uint32_t LLT : 1;
      uint32_t LUR : 1;
      uint32_t LUL : 1;
      uint32_t LUT : 1;
      uint32_t LUB : 1;
    };
    uint32_t raw;
  };
};

bool isDKbEnabled() {
  #ifdef DKBIN
  return true;
  #else
  return false;
  #endif
}

void printDKbInData(const DKbInEvArgs&amp; s);

#ifdef GRIS5A
void processDKb(QMActive* recv, const DKbInEvArgs&amp; dkb)
{
  // Debug: Serial.println(dkb.raw, BIN);
  if (dkb.GAL) {
    MotorMoveRelativeEvArgs args(GARTN, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.GAT) {
    MotorMoveRelativeEvArgs args(GALNG, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.GAB) {
    MotorMoveRelativeEvArgs args(GALNG, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.GAR) {
    MotorMoveRelativeEvArgs args(GARTN, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.FP7) {
    ProgramChangeEvArgs args(7);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FP6) {
    ProgramChangeEvArgs args(6);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FP5) {
    ProgramChangeEvArgs args(5);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FP8) {
    ProgramChangeEvArgs args(8);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.RLB) {
    MotorMoveRelativeEvArgs args(RLLNG, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.RLR) {
    MotorMoveRelativeEvArgs args(RLRTN, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.RLL) {
    MotorMoveRelativeEvArgs args(RLRTN, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.RLT) {
    MotorMoveRelativeEvArgs args(RLLNG, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.RUR) {
    MotorMoveRelativeEvArgs args(RURTN, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.RUL) {
    MotorMoveRelativeEvArgs args(RURTN, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.RUT) {
    MotorMoveRelativeEvArgs args(RULNG, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.RUB) {
    MotorMoveRelativeEvArgs args(RULNG, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.FP4) {
    ProgramChangeEvArgs args(4);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FP3) {
    ProgramChangeEvArgs args(3);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FP2) {
    ProgramChangeEvArgs args(2);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FP1) {
    ProgramChangeEvArgs args(1);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FRM) {
    QACTIVE_POST(recv, REMOTE_MODE_SIG, 0L);
  }
  if (dkb.FPS) {
    QACTIVE_POST(recv, PRESET_MODE_SIG, 0L);
  }
  if (dkb.FMM) {
    QACTIVE_POST(recv, MANUAL_MOTION_MODE_SIG, 0L);
  }
  if (dkb.FCA) {
    QACTIVE_POST(recv, CALIBRATION_MODE_SIG, 0L);
  }
  if (dkb.LLB) {
    MotorMoveRelativeEvArgs args(LLLNG, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.LLR) {
    MotorMoveRelativeEvArgs args(LLRTN, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.LLL) {
    MotorMoveRelativeEvArgs args(LLRTN, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.LLT) {
    MotorMoveRelativeEvArgs args(LLLNG, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.LUR) {
    MotorMoveRelativeEvArgs args(LURTN, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.LUL) {
    MotorMoveRelativeEvArgs args(LURTN, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.LUT) {
    MotorMoveRelativeEvArgs args(LULNG, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.LUB) {
    MotorMoveRelativeEvArgs args(LULNG, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  //printDKbInData(dkb);
}
#elif NO2
void processDKb(QMActive* recv, const DKbInEvArgs&amp; dkb)
{
  if (dkb.GAL) {
    MotorMoveRelativeEvArgs args(GARTN, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.GAT) {
    MotorMoveRelativeEvArgs args(GALNG, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.GAB) {
    MotorMoveRelativeEvArgs args(GALNG, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.GAR) {
    MotorMoveRelativeEvArgs args(GARTN, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.FP7) {
    ProgramChangeEvArgs args(7);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FP6) {
    ProgramChangeEvArgs args(6);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FP5) {
    ProgramChangeEvArgs args(5);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FP8) {
    ProgramChangeEvArgs args(8);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.RLB) {
    MotorMoveRelativeEvArgs args(RLLNG, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.RLR) {
    MotorMoveRelativeEvArgs args(RLRTN, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.RLL) {
    MotorMoveRelativeEvArgs args(RLRTN, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.RLT) {
    MotorMoveRelativeEvArgs args(RLLNG, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.FP4) {
    ProgramChangeEvArgs args(4);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FP3) {
    ProgramChangeEvArgs args(3);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FP2) {
    ProgramChangeEvArgs args(2);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FP1) {
    ProgramChangeEvArgs args(1);
    QACTIVE_POST(recv, PROGRAM_CHANGE_SIG, args.raw);
  }
  if (dkb.FRM) {
    QACTIVE_POST(recv, REMOTE_MODE_SIG, 0L);
  }
  if (dkb.FPS) {
    QACTIVE_POST(recv, PRESET_MODE_SIG, 0L);
  }
  if (dkb.FMM) {
    QACTIVE_POST(recv, MANUAL_MOTION_MODE_SIG, 0L);
  }
  if (dkb.FCA) {
    QACTIVE_POST(recv, CALIBRATION_MODE_SIG, 0L);
  }
  if (dkb.LLB) {
    MotorMoveRelativeEvArgs args(LLLNG, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.LLR) {
    MotorMoveRelativeEvArgs args(LLRTN, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.LLL) {
    MotorMoveRelativeEvArgs args(LLRTN, BACKWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  if (dkb.LLT) {
    MotorMoveRelativeEvArgs args(LLLNG, FORWARDS);
    QACTIVE_POST(recv, MOTOR_MOVE_RELATIVE_SIG, args.raw);
  }
  printDKbInData(dkb);
}
#endif



void processSoftDKb(QMActive* recv, const SerialInEvArgs&amp; softdkb)
{
  int bitToSet = softdkb.Data;
  uint32_t dkbRaw = 0;
  bitSet(dkbRaw, bitToSet);
  DKbInEvArgs dkb(dkbRaw);
  processDKb(recv, dkb);
}

void printDKbInData(const DKbInEvArgs&amp; s) {
  if (s.FMM) { Serial.println(F(&quot;Pressed Function Manual Motion&quot;)); }
  if (s.FPS) { Serial.println(F(&quot;Pressed Function Pre-Set&quot;)); }
  if (s.FRM) { Serial.println(F(&quot;Pressed Function Remote&quot;)); }
  if (s.FP2) { Serial.println(F(&quot;Pressed Function Program 2&quot;)); }
  if (s.FP1) { Serial.println(F(&quot;Pressed Function Program 1&quot;)); }
  if (s.FCA) { Serial.println(F(&quot;Pressed Function Calibration&quot;)); }
  if (s.FP3) { Serial.println(F(&quot;Pressed Function Program 3&quot;)); }
  if (s.FP4) { Serial.println(F(&quot;Pressed Function Program 4&quot;)); }
  if (s.LUT) { Serial.println(F(&quot;Pressed Left Upper Top&quot;)); }
  if (s.LUR) { Serial.println(F(&quot;Pressed Left Upper Right&quot;)); }
  if (s.LUL) { Serial.println(F(&quot;Pressed Left Upper Left&quot;)); }
  if (s.LLL) { Serial.println(F(&quot;Pressed Left Lower Left&quot;)); }
  if (s.LUB) { Serial.println(F(&quot;Pressed Left Upper Bottom&quot;)); }
  if (s.LLT) { Serial.println(F(&quot;Pressed Left Lower Top&quot;)); }
  if (s.LLR) { Serial.println(F(&quot;Pressed Left Lower Right&quot;)); }
  if (s.LLB) { Serial.println(F(&quot;Pressed Left Lower Bottom&quot;)); }
  if (s.RUT) { Serial.println(F(&quot;Pressed Right Upper Top&quot;)); }
  if (s.RUR) { Serial.println(F(&quot;Pressed Right Upper Right&quot;)); }
  if (s.RUL) { Serial.println(F(&quot;Pressed Right Upper Left&quot;)); }
  if (s.RUB) { Serial.println(F(&quot;Pressed Right Upper Bottom&quot;)); }
  if (s.RLT) { Serial.println(F(&quot;Pressed Right Lower Top&quot;)); }
  if (s.RLL) { Serial.println(F(&quot;Pressed Right Lower Left&quot;)); }
  if (s.RLB) { Serial.println(F(&quot;Pressed Right Lower Bottom&quot;)); }
  if (s.RLR) { Serial.println(F(&quot;Pressed Right Lower Right&quot;)); }
  if (s.FP8) { Serial.println(F(&quot;Pressed Function Program 8&quot;)); }
  if (s.GAT) { Serial.println(F(&quot;Pressed Gating Top&quot;)); }
  if (s.GAR) { Serial.println(F(&quot;Pressed Gating Right&quot;)); }
  if (s.GAL) { Serial.println(F(&quot;Pressed Gating Left&quot;)); }
  if (s.FP5) { Serial.println(F(&quot;Pressed Function Program 5&quot;)); }
  if (s.FP6) { Serial.println(F(&quot;Pressed Function Program 6&quot;)); }
  if (s.FP7) { Serial.println(F(&quot;Pressed Function Program 7&quot;)); }
  if (s.GAB) { Serial.println(F(&quot;Pressed Gating Bottom&quot;)); }
}

#endif</text>
  </file>
  <file name="events.h">
   <text>/* events.h - Arduino software for the GRIS5A (C) motion phantom
 * Copyright (C) 2019 by Stefan Grimm
 */

#ifndef __EVENTS_H
#define __EVENTS_H

enum Signals {
  MANUAL_MOTION_MODE_SIG = Q_USER_SIG,
  PRESET_MODE_SIG,
  REMOTE_MODE_SIG,
  CALIBRATION_MODE_SIG,
  PROGRAM_CHANGE_SIG,
  MOTOR_STEP_FORWARD_SIG,
  MOTOR_STEP_BACKWARD_SIG,
  MOTOR_MOVE_RELATIVE_SIG,
  MOTOR_MOVE_ASOLUTE_SIG,
  DKBIN_DISPATCH_SIG
};

#ifdef GRIS5A
enum ServoNumber {
  LURTN=0,
  LULNG,
  LLRTN,
  LLLNG,
  RLLNG,
  RLRTN,
  RULNG,
  RURTN,
  GALNG,
  GARTN
};
#elif NO2
enum ServoNumber {
  LLLNG=0,
  RLLNG,
  GALNG,
  LLRTN,
  RLRTN,
  GARTN
};
#endif

enum SerialInCommand {
  SOFTDKB = 1,
  ABSMOVE = 2,
  FREEMEM = 3,
  SYNC = 4
};

struct SerialInEvArgs {
  SerialInEvArgs () : raw(0) {}
  SerialInEvArgs (const SerialInEvArgs&amp; t) : raw(t.raw) {}
  SerialInEvArgs (uint8_t rawValue) : raw(rawValue) {}

  SerialInCommand getCmd() { return (SerialInCommand)Cmd; }

  union {
    struct {
      uint8_t Cmd  : 3;
      uint8_t Data : 5;
    };
    uint8_t raw;
  };
};

enum Direction {
  BACKWARDS = 0,
  FORWARDS
};

struct MotorMoveRelativeEvArgs {
  MotorMoveRelativeEvArgs () : raw(0) {}
  MotorMoveRelativeEvArgs (const MotorMoveRelativeEvArgs&amp; t) : raw(t.raw) {}
  MotorMoveRelativeEvArgs (uint8_t rawValue) : raw(rawValue) {}
  MotorMoveRelativeEvArgs (uint8_t servoNum, Direction direction) : raw((direction &lt;&lt; 4) | servoNum) {}

  Direction getDirection() { return (Direction)Dir; }

  union {
    struct {
      uint8_t ServoNum : 4;
      uint8_t Dir      : 1;
      uint8_t Any      : 3;
    };
    uint8_t raw;
  };
};

struct ProgramChangeEvArgs {
  ProgramChangeEvArgs () : raw(0) {}
  ProgramChangeEvArgs (const ProgramChangeEvArgs&amp; t) : raw(t.raw) {}
  ProgramChangeEvArgs (uint8_t rawValue) : raw(rawValue) {}

  union {
    struct {
      uint8_t ProgNo : 4;
      uint8_t Any    : 4;
    };
    uint8_t raw;
  };
};

#ifdef MOTOROUT
struct MotorEvArgs {
  MotorEvArgs () : raw(0) {}
  MotorEvArgs (const MotorEvArgs&amp; t) : raw(t.raw) {}
  MotorEvArgs (uint16_t rawValue) : raw(rawValue) {}
  MotorEvArgs (uint8_t m, uint8_t pos, uint8_t step)
    : raw((pos &lt;&lt; 8) | (step &lt;&lt; 4) | m) {}
  union {
    struct {
      uint16_t ServoNum : 4;
      uint16_t StepSize : 4;
      uint16_t Pos   : 8;
    };
    uint16_t raw;
  };
};
#endif

#endif</text>
  </file>
  <file name="constants.h">
   <text>/* constants.h - Arduino software for the GRIS5A (C) motion phantom
 * Copyright (C) 2019 by Stefan Grimm
 */

#ifndef __CONSTANTS_H
#define __CONSTANTS_H

enum Pins {
  CLOCKPIN_IN = 4,  // yellow 1
  LATCHPIN_IN = 3,  // green 1
  DATAPIN_IN = 2,   // blue 1
  CLOCKPIN_OUT = 7, // yellow 2
  LATCHPIN_OUT = 6, // green 2
  DATAPIN_OUT = 5   // blue 2
};

// Timeout definitions
// Given BSP_TICKS_PER_SEC = 100:
// Possible are 1 for 10 ms or 100 Hz, 2 for 20 ms or 50 Hz, 3 for 30 ms or 33.3 Hz
enum Constants {
  BSP_TICKS_PER_SEC = 100,          // Number of system clock ticks in one second, e.g. an interrupt every 10 ms
  DKBREADINVERVAL = 10,             // Read control panel every 100 ms
  SERIALRECVINVERVAL = 4,           // Read serial in buffer every 40 ms
  MOTORSENDINTERVAL = 2,            // A move of a motor takes 20 ms. the term step is used in the source code
  PRESETTIMERINTERVAL = 4,          // Discrete step size between the positions is 40 ms
  USERPROGRAMCOUNTERINTERVAL = 100, // Discrete step size between positions is 1000 ms
  MOTORSTARTUPDELAY = 20,           // Wait 200 ms between the initialization of the motors (all at once draws too much current)
  PRESETTIMERINCR = 40              // Increment the preset timer by 40 ms on every PRESETTIMERINTERVAL
};

#endif</text>
  </file>
  <file name="preset.h">
   <text>/* preset.h - Arduino software for the GRIS5A (C) motion phantom
 * Copyright (C) 2019 by Stefan Grimm
 */

#ifndef __PRESET_H
#define __PRESET_H

#include &quot;qpn.h&quot;
#include &quot;events.h&quot;
#include &quot;constants.h&quot;

#ifdef GRIS5A

void prog1(QMActive* recv, uint16_t&amp; preSetTimer) {
    // Marker Position 1

    static const uint8_t PROGMEM STEPSZ = 2;
    if (preSetTimer == 0) {
      MotorEvArgs lulng(LULNG, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, 0, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (preSetTimer == 3000) {
      MotorEvArgs lulng(LULNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
    }

    if (preSetTimer &lt;= 3000) {
      preSetTimer += PRESETTIMERINCR;
    }
}

void prog2(QMActive* recv, uint16_t&amp; preSetTimer) {
    // Marker Position 2

    static const uint8_t PROGMEM STEPSZ = 2;
    if (preSetTimer == 0) {
      MotorEvArgs lulng(LULNG, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 100, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 70, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 70, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, 0, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (preSetTimer == 3000) {
      MotorEvArgs lulng(LULNG, 167, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 167, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 117, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 117, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 87, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 137, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 137, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 87, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
    }

    if (preSetTimer &lt;= 3000) {
      preSetTimer += PRESETTIMERINCR;
    }
}

void prog3(QMActive* recv, uint16_t&amp; preSetTimer) {
    // Marker Position 1 &lt;-&gt; 2

    if (preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 147, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 147, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 122, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 122, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 107, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 132, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 132, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 107, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, 0, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (preSetTimer &gt;= 3000) {
      static const uint8_t PROGMEM STEPSZ = 8;
      float targetDeltaSmall = 10 * sin((preSetTimer - 3000) / 3000.0 * PI);
      float targetDeltaLarge = 40 * sin((preSetTimer - 3000) / 3000.0 * PI);

      MotorEvArgs lulng(LULNG, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
    }

    if (preSetTimer == 8960) {
      preSetTimer = 3000;
    }
    else {
      preSetTimer += PRESETTIMERINCR;
    }
}

void prog4(QMActive* recv, uint16_t&amp; preSetTimer) {
    // Free-breath Gating

    if (preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
      MotorEvArgs galng(GALNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (preSetTimer &gt;= 3000) {
      static const uint8_t PROGMEM STEPSZ = 8;
      float target = 127 + 80 * sin((preSetTimer - 3000) / 2500.0 * PI);

      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (preSetTimer == 7960) {
      preSetTimer = 3000;
    }
    else {
      preSetTimer += PRESETTIMERINCR;
    }
}

void prog5(QMActive* recv, uint16_t&amp; preSetTimer) {
    // Breath-hold Gating

    if (preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 60, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 60, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 60, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 60, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
      MotorEvArgs galng(GALNG, 60, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (preSetTimer &gt;= 3000 &amp;&amp; preSetTimer &lt; 28000) {
      static const uint8_t PROGMEM STEPSZ = 8;
      float target = 60 + 50 * sin((preSetTimer - 3000) / 2500.0 * PI);

      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }
    else if (preSetTimer == 28000) {
      static const uint8_t PROGMEM STEPSZ = 4;
      MotorEvArgs lulng(LULNG, 250, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, 250, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, 250, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, 250, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, 250, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }
    else if (preSetTimer &gt; 28000 &amp;&amp; preSetTimer &lt; 38000) {
      static const uint8_t PROGMEM STEPSZ = 10;
      float target = 200 + 50 * cos((preSetTimer - 28000) / 40000.0 * PI);
      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }
    else if (preSetTimer == 38000) {
      static const uint8_t PROGMEM STEPSZ = 4;
      MotorEvArgs lulng(LULNG, 10, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, 10, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, 10, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, 10, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, 10, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (preSetTimer == 40000) {
      preSetTimer = 6720;
    }
    else {
      preSetTimer += PRESETTIMERINCR;
    }
}

void prog6(QMActive* recv, uint16_t&amp; preSetTimer) {
    // Free-breath Gating, Marker Position 1 &lt;-&gt; 2

    if (preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 147, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 147, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 122, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 122, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 107, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 132, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 132, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 107, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (preSetTimer &gt;= 3000) {

      static const uint8_t PROGMEM STEPSZ = 8;
      float targetDeltaSmall = 10 * sin((preSetTimer - 3000) / 3000.0 * PI);
      float targetDeltaLarge = 40 * sin((preSetTimer - 3000) / 3000.0 * PI);
      float targetGating = 127 + 80 * sin((preSetTimer - 3000) / 3000.0 * PI);

      MotorEvArgs lulng(LULNG, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, targetGating, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (preSetTimer == 8960) {
      preSetTimer = 3000;
    }
    else {
      preSetTimer += PRESETTIMERINCR;
    }
}

void prog7(QMActive* recv, uint16_t&amp; preSetTimer) {
    // Free-breath Gating loosing signal

    if (preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
      MotorEvArgs galng(GALNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (preSetTimer &gt;= 3000) {
      static const uint8_t PROGMEM STEPSZ = 8;
      float target = 127 + 80 * sin((preSetTimer - 3000) / 2500.0 * PI);

      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (preSetTimer == 25000) {
      static const uint8_t PROGMEM STEPSZ = 3;

      MotorEvArgs gartn(GARTN, 255, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (preSetTimer == 35000) {
      static const uint8_t PROGMEM STEPSZ = 3;

      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }

    if (preSetTimer == 37960) {
      preSetTimer = 3000;
    }
    else {
      preSetTimer += PRESETTIMERINCR;
    }
}

void prog8(QMActive* recv, uint16_t&amp; preSetTimer) {
    // Free-breath Gating base line shift

    if (preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 130, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 130, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 130, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 130, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
      MotorEvArgs galng(GALNG, 130, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (preSetTimer &gt;= 3000) {
      static const uint8_t PROGMEM STEPSZ = 8;
      float baseline = 130 + 30 * sin((preSetTimer - 3000) / 30000.0 * PI);
      float target = baseline + 50 * sin((preSetTimer - 3000) / 3000.0 * PI);

      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (preSetTimer == 62960) {
      preSetTimer = 3000;
    }
    else {
      preSetTimer += PRESETTIMERINCR;
    }
}

#elif NO2

void prog1(QMActive* recv, uint16_t&amp; preSetTimer) {
}

void prog2(QMActive* recv, uint16_t&amp; preSetTimer) {
}

void prog3(QMActive* recv, uint16_t&amp; preSetTimer) {
}

void prog4(QMActive* recv, uint16_t&amp; preSetTimer) {
// Free-breath Gating

    if (preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lllng(LLLNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
      MotorEvArgs galng(GALNG, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (preSetTimer &gt;= 3000) {
      static const uint8_t PROGMEM STEPSZ = 8;
      float target = 127 + 80 * sin((preSetTimer - 3000) / 2500.0 * PI);

      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST(recv, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (preSetTimer == 7960) {
      preSetTimer = 3000;
    }
    else {
      preSetTimer += PRESETTIMERINCR;
    }

}

void prog5(QMActive* recv, uint16_t&amp; preSetTimer) {
}

void prog6(QMActive* recv, uint16_t&amp; preSetTimer) {
}

void prog7(QMActive* recv, uint16_t&amp; preSetTimer) {
}

void prog8(QMActive* recv, uint16_t&amp; preSetTimer) {
}

#endif


#endif</text>
  </file>
 </directory>
</model>
