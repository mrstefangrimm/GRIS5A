/*****************************************************************************
* Model: gris5A.qm
* File:  ./gris5A.ino
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::gris5A.ino} .........................................................*/
/* gris5A.qm - Arduino software for the GRIS5A (C) motion phantom
 * Copyright (C) 2018 by Stefan Grimm
 */

#include "qpn.h"     // QP-nano framework
#include "Arduino.h" // Arduino API

#define DKBIN
#define SERIALIN
#define MANUALMOTION
#define PRESET
#define USERPROGRAM
#define DKBOUT
#define MOTOROUT

#ifdef MOTOROUT
#include "_Adafruit_PWMServoDriver.h"
#include "prfServo.h"

class ServoShieldPCA9685Linear : public prfServoImplBase<uint16_t, float> {
  public:
  void begin() {
    pwm.begin();
    pwm.setPWMFreq(60);
    // Set pwm signal to off.
    // The servo shield does not like signal when it is powered. 1.5 Amperes are flowing.
    // setPWMOn() has interestingly the same effect.
    pwm.setPWMOff();
  }

  void get(float** params) const {
    // LURTN
    params[0][0] = 140;
    params[0][1] = 1.647;
    // LULNG
    params[1][0] = 4.4153846153846140e+002;
    params[1][1] = -1.6206560324207273e+000;
    params[1][2] = 6.3136914347985870e-003;
    params[1][3] = -1.3647931869430087e-005;
    // LLRTN
    params[2][0] = 140;
    params[2][1] = 1.647;
    // LLLNG
    params[3][0] = 220; //2.0891608391608386e+002;
    params[3][1] = 1.5197982845041706e+000;
    params[3][2] = -3.7998653915609324e-003;
    params[3][3] = 6.9118281570506850e-006;
    // RLLNG
    params[4][0] = 5.3912587412587410e+002;
    params[4][1] = -1.5669515669515590e+000;
    params[4][2] = 4.3151773255578690e-003;
    params[4][3] = -9.4305451973315200e-006;
    // RLRTN
    params[5][0] = 140;
    params[5][1] = 1.647;
    // RULNG
    params[6][0] = 2.3982517482517500e+002;
    params[6][1] = 1.5140088669500340e+000;
    params[6][2] = -5.3054724335000170e-003;
    params[6][3] = 1.1597813348271060e-005;
    // RURTN
    params[7][0] = 140;
    params[7][1] = 1.647;
    // GALNG
    params[8][0] = 4.6569930069930063e+002;
    params[8][1] = -1.5909471791824652e+000;
    params[8][2] = 4.7856795261638710e-003;
    params[8][3] = -9.9577185313438400e-006;
    // GARTN
    params[9][0] = 140;
    params[9][1] = 1.647;
  }

  void write(uint8_t num, uint16_t servoVal) {
    pwm.setPWM(num, 0, servoVal);
  }

  private:
  Adafruit_PWMServoDriver pwm;
};

ServoShieldPCA9685Linear impl;
prfServo<uint32_t, uint8_t, uint16_t, float> servoLib(&impl, 0x777DD);

#define NUMSERVOS 10

#endif

#define Q_PARAM_SIZE   4

//============================================================================
// declare all AO classes...

#if ((QP_VERSION < 591) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpn version 5.9.1 or higher required
#endif

/*${AOs::DKbIn} ............................................................*/
typedef struct DKbIn {
/* protected: */
    QActive super;

/* public: */
    uint32_t dataBuffer;
} DKbIn;

/* public: */
static uint32_t DKbIn_shiftIn32(DKbIn * const me);
static bool DKbIn_isMotorButtonPressed(DKbIn * const me);
static bool DKbIn_isProgramButtonPressed(DKbIn * const me);
static void DKbIn_printDKbInData(DKbIn * const me);

/* protected: */
static QState DKbIn_initial(DKbIn * const me);
static QState DKbIn_Read(DKbIn * const me);
static QState DKbIn_Dispatch(DKbIn * const me);

#ifdef MANUALMOTION
/*${AOs::ManualMotion} .....................................................*/
typedef struct ManualMotion {
/* protected: */
    QActive super;

/* public: */
    uint8_t speed;
} ManualMotion;

/* protected: */
static QState ManualMotion_initial(ManualMotion * const me);
static QState ManualMotion_ManualMotion(ManualMotion * const me);
static QState ManualMotion_Idle(ManualMotion * const me);

#endif
#ifdef PRESET
/*${AOs::PreSet} ...........................................................*/
typedef struct PreSet {
/* protected: */
    QActive super;

/* public: */
    uint8_t currentPreSet;
    uint16_t preSetTimer;
} PreSet;

/* public: */
static bool PreSet_isCurrentPreSet(PreSet * const me);
static void PreSet_prog3(PreSet * const me);
static void PreSet_prog1(PreSet * const me);
static void PreSet_prog2(PreSet * const me);
static void PreSet_prog4(PreSet * const me);
static void PreSet_prog5(PreSet * const me);
static void PreSet_prog6(PreSet * const me);
static void PreSet_prog7(PreSet * const me);
static void PreSet_prog8(PreSet * const me);

/* protected: */
static QState PreSet_initial(PreSet * const me);
static QState PreSet_Idle(PreSet * const me);
static QState PreSet_WaitForProgram(PreSet * const me);
static QState PreSet_RunProgram(PreSet * const me);

#endif
#ifdef USERPROGRAM
/*${AOs::UserProgram} ......................................................*/
typedef struct UserProgram {
/* protected: */
    QActive super;

/* public: */
    uint8_t userProgramCounter;
    uint8_t userProgram[NUMSERVOS][8];
} UserProgram;

/* protected: */
static QState UserProgram_initial(UserProgram * const me);
static QState UserProgram_Idle(UserProgram * const me);
static QState UserProgram_Record(UserProgram * const me);
static QState UserProgram_Play(UserProgram * const me);

#endif
#ifdef DKBOUT
/*${AOs::DKbOut} ...........................................................*/
typedef struct DKbOut {
/* protected: */
    QActive super;
} DKbOut;

/* protected: */
static QState DKbOut_initial(DKbOut * const me);
static QState DKbOut_ManualMotionLED(DKbOut * const me);
static QState DKbOut_PreSetLED(DKbOut * const me);
static QState DKbOut_UserProgramRecordLED(DKbOut * const me);
static QState DKbOut_UserProgramPlayLED(DKbOut * const me);

#endif
#ifdef MOTOROUT
/*${AOs::MotorsOut} ........................................................*/
typedef struct MotorsOut {
/* protected: */
    QActive super;

/* public: */
    uint8_t servoPosition[NUMSERVOS];
    uint8_t target[NUMSERVOS];
    uint8_t stepSize[NUMSERVOS];
    uint16_t _sendPositionCounter;
    uint8_t initializeCounter;
} MotorsOut;

/* public: */
static bool MotorsOut_isInitialized(MotorsOut * const me);

/* protected: */
static QState MotorsOut_initial(MotorsOut * const me);

// Timings:
// servoLib.write for 16 motors takes 9 ms
// Serial print takes 0.2 ms
// Meassured with the oscilloscope and digitalWrite(HIGH/LOW)
static QState MotorsOut_Active(MotorsOut * const me);
static QState MotorsOut_Wait(MotorsOut * const me);

#endif

// AO instances and event queue buffers for them...
DKbIn AO_DKbIn;
static QEvt l_DKbInQSto[5];
#ifdef MANUALMOTION
ManualMotion AO_ManualMotion;
static QEvt l_ManualMotionQSto[5];
#endif
#ifdef PRESET
PreSet AO_PreSet;
static QEvt l_PreSetQSto[5];
#endif
#ifdef USERPROGRAM
UserProgram AO_UserProgram;
static QEvt l_UserProgramQSto[5];
#endif
#ifdef DKBOUT
DKbOut AO_DKbOut;
static QEvt l_DKbOutQSto[2];
#endif
#ifdef MOTOROUT
MotorsOut AO_MotorsOut;
static QEvt l_MotorsOutQSto[NUMSERVOS*2];
#endif


//============================================================================
// events used in this application...
enum Signals {
  evRead_SIG = Q_USER_SIG, // PEDestrians-waiting button press event
  evManualMotionPressed_SIG,
  evPreSetPressed_SIG,
  evUserProgramPressed_SIG,
  evUserProgramPlayPressed_SIG,
  evMotorButtonPressed_SIG,
  evProgramButtonPressed_SIG,
  evMotorForward_SIG,
  evMotorBackward_SIG,
  evMotorAbsMove_SIG
};

enum Pins {
  CLOCKPIN_IN = 4,  // yellow 1
  LATCHPIN_IN = 3,  // green 1
  DATAPIN_IN = 2,   // blue 1
  CLOCKPIN_OUT = 7, // yellow 2
  LATCHPIN_OUT = 6, // green 2
  DATAPIN_OUT = 5   // blue 2
};


// Timeout definitions
// Given BSP_TICKS_PER_SEC = 100:
// Possible are 1 for 10 ms or 100 Hz, 2 for 20 ms or 50 Hz, 3 for 30 ms or 33.3 Hz
enum Constants {
  BSP_TICKS_PER_SEC = 100,          // Number of system clock ticks in one second, e.g. an interrupt every 10 ms
  READOUTINVERVAL = 10,             // Read control panel every 100 ms
  MOTORSENDINTERVAL = 2,            // A move of a motor takes 20 ms. the term step is used in the source code
  PRESETTIMERINTERVAL = 4,          // Discrete step size between the positions is 40 ms
  USERPROGRAMCOUNTERINTERVAL = 100, // Discrete step size between positions is 1000 ms
  MOTORSTARTUPDELAY = 20,           // Wait 200 ms between the initialization of the motors (all at once draws too much current)
  PRESETTIMERINCR = 40              // Increment the preset timer by 40 ms on every PRESETTIMERINTERVAL
};

typedef struct DKbInData_r1_t {
  DKbInData_r1_t () : raw(0) {}
  DKbInData_r1_t (const struct DKbInData_r1_t& t) : raw(t.raw) {}
  DKbInData_r1_t (uint32_t rawValue) : raw(rawValue) {}
  union {
    struct {
      uint32_t GAL : 1;
      uint32_t GAT : 1;
      uint32_t GAB : 1;
      uint32_t GAR : 1;
      uint32_t FP7 : 1;
      uint32_t FP6 : 1;
      uint32_t FP5 : 1;
      uint32_t FP8 : 1;
      uint32_t RLB : 1;
      uint32_t RLR : 1;
      uint32_t RLL : 1;
      uint32_t RLT : 1;
      uint32_t RUR : 1;
      uint32_t RUL : 1;
      uint32_t RUT : 1;
      uint32_t RUB : 1;
      uint32_t FP4 : 1;
      uint32_t FP3 : 1;
      uint32_t FP2 : 1;
      uint32_t FP1 : 1;
      uint32_t FPG : 1;
      uint32_t FPS : 1;
      uint32_t FMM : 1;
      uint32_t FPP : 1;
      uint32_t LLB : 1;
      uint32_t LLR : 1;
      uint32_t LLL : 1;
      uint32_t LLT : 1;
      uint32_t LUR : 1;
      uint32_t LUL : 1;
      uint32_t LUT : 1;
      uint32_t LUB : 1;
    };
    uint32_t raw;
  };
} DKbInData;

#ifdef DKBOUT
typedef struct DKbOutData_t {
  DKbOutData_t() : raw(0) {}
  DKbOutData_t(const struct DKbOutData_t& t) : raw(t.raw) {}
  DKbOutData_t(uint8_t rawValue) : raw(rawValue) {}
  union {
    struct {
      uint8_t FPR : 1;
      uint8_t FPP : 1;
      uint8_t FPS : 1;
      uint8_t FMM : 1;
    };
    int raw;
  };
} DKbOutData;
#endif

#ifdef MOTOROUT
enum ServoNumber {
  LURTN=0,
  LULNG,
  LLRTN,
  LLLNG,
  RLLNG,
  RLRTN,
  RULNG,
  RURTN,
  GALNG,
  GARTN
};

typedef struct MotorData_t {
  MotorData_t () : raw(0) {}
  MotorData_t (const struct MotorData_t& t) : raw(t.raw) {}
  MotorData_t (uint16_t rawValue) : raw(rawValue) {}
  MotorData_t (ServoNumber m, uint8_t pos, uint8_t step)
    : raw((pos << 8) | (step << 4) | m) {}
  uint8_t abspos() {
    switch(ServoNum) {
      default: return Pos;
      // Not required with prfServo
      // case RLLNG:
      // case RULNG:
      //   return 255 - Pos;
    }
  }
  int16_t relpos() {
    switch(ServoNum) {
      default: return Pos;
      // Not required with prfServo
      // case RLLNG:
      // case RULNG:
      //   return -Pos;
    }
  }
  union {
    struct {
      uint16_t ServoNum : 4;
      uint16_t StepSize : 4;
      uint16_t Pos   : 8;
    };
    uint16_t raw;
  };
} MotorData;
#endif

//============================================================================

//============================================================================
// QF_active[] array defines all active object control blocks ----------------
QActiveCB const Q_ROM QF_active[] = {
  { (QActive *)0, (QEvt *)0, 0U}, // SGR: required...
  { (QActive *)&AO_DKbIn, l_DKbInQSto, Q_DIM(l_DKbInQSto) },
  #ifdef MANUALMOTION
  { (QActive *)&AO_ManualMotion, l_ManualMotionQSto, Q_DIM(l_ManualMotionQSto) },
  #endif
  #ifdef PRESET
  { (QActive *)&AO_PreSet, l_PreSetQSto, Q_DIM(l_PreSetQSto) },
  #endif
  #ifdef USERPROGRAM
  { (QActive *)&AO_UserProgram, l_UserProgramQSto, Q_DIM(l_UserProgramQSto) },
  #endif
  #ifdef DKBOUT
  { (QActive *)&AO_DKbOut, l_DKbOutQSto, Q_DIM(l_DKbOutQSto) },
  #endif
  #ifdef MOTOROUT
  { (QActive *)&AO_MotorsOut, l_MotorsOutQSto, Q_DIM(l_MotorsOutQSto) },
  #endif
};


//............................................................................
void setup() {
  // initialize the QF-nano framework
  QF_init(Q_DIM(QF_active));

  // initialize all AOs...
  QActive_ctor(&AO_DKbIn.super, Q_STATE_CAST(&DKbIn_initial));
  #ifdef MANUALMOTION
  QActive_ctor(&AO_ManualMotion.super, Q_STATE_CAST(&ManualMotion_initial));
  #endif
  #ifdef PRESET
  QActive_ctor(&AO_PreSet.super, Q_STATE_CAST(&PreSet_initial));
  #endif
  #ifdef USERPROGRAM
  QActive_ctor(&AO_UserProgram.super, Q_STATE_CAST(&UserProgram_initial));
  #endif
  #ifdef DKBOUT
  QActive_ctor(&AO_DKbOut.super, Q_STATE_CAST(&DKbOut_initial));
  #endif
  #ifdef MOTOROUT
  QActive_ctor(&AO_MotorsOut.super, Q_STATE_CAST(&MotorsOut_initial));
  #endif

  // initialize the hardware used in this sketch...
  Serial.begin(9600);   // set the highest stanard baud rate of 115200 bps
  Serial.print(F("Start, QP-nano: "));
  Serial.println(F(QP_VERSION_STR));

}

//............................................................................
void loop() {
  QF_run(); // run the QF-nano framework
}

//============================================================================
// interrupts...
ISR(TIMER2_COMPA_vect) {
  QF_tickXISR(0); // process time events for tick rate 0
}

//============================================================================
// QF callbacks...
void QF_onStartup(void) {
  // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking...
  TCCR2A = (1U << WGM21) | (0U << WGM20);
  TCCR2B = (1U << CS22 ) | (1U << CS21) | (1U << CS20); // 1/2^10
  ASSR  &= ~(1U << AS2);
  TIMSK2 = (1U << OCIE2A); // enable TIMER2 compare Interrupt
  TCNT2  = 0U;

  // set the output-compare register based on the desired tick frequency
  OCR2A  = (F_CPU / BSP_TICKS_PER_SEC / 1024U) - 1U;
}
//............................................................................
void QV_onIdle(void) {   // called with interrupts DISABLED
  // Put the CPU and peripherals to the low-power mode. You might
  // need to customize the clock management for your application,
  // see the datasheet for your particular AVR MCU.
  SMCR = (0 << SM0) | (1 << SE); // idle mode, adjust to your project
  QV_CPU_SLEEP();  // atomically go to sleep and enable interrupts
}
//............................................................................
void Q_onAssert(char const Q_ROM * const file, int line) {
  // implement the error-handling policy for your application!!!
  QF_INT_DISABLE(); // disable all interrupts
  QF_RESET();  // reset the CPU
}

//============================================================================
// define all AO classes (state machine)...
/*${AOs::DKbIn} ............................................................*/
/*${AOs::DKbIn::shiftIn32} .................................................*/
static uint32_t DKbIn_shiftIn32(DKbIn * const me) {
    uint32_t myDataIn = 0;

    for (int i=31; i>=0; i--)
    {
      digitalWrite(CLOCKPIN_IN, 0);
      delayMicroseconds(2);
      int temp = digitalRead(DATAPIN_IN);
      if (temp) {
        bitSet(myDataIn, i);
        // Debug: Serial.print(i);
      }
      digitalWrite(CLOCKPIN_IN, 1);
    }
    return myDataIn;

}
/*${AOs::DKbIn::isMotorButtonPressed} ......................................*/
static bool DKbIn_isMotorButtonPressed(DKbIn * const me) {
    DKbInData data(me->dataBuffer);

    return data.LUT  != 0 ||
           data.LUR  != 0 ||
           data.LUL  != 0 ||
           data.LLL  != 0 ||
           data.LUB  != 0 ||
           data.LLT  != 0 ||
           data.LLR  != 0 ||
           data.LLB  != 0 ||
           data.RUT  != 0 ||
           data.RUR  != 0 ||
           data.RUL  != 0 ||
           data.RUB  != 0 ||
           data.RLT  != 0 ||
           data.RLL  != 0 ||
           data.RLB  != 0 ||
           data.RLR  != 0 ||
           data.GAT  != 0 ||
           data.GAR  != 0 ||
           data.GAL  != 0 ||
           data.GAB  != 0;
}
/*${AOs::DKbIn::isProgramButtonPressed} ....................................*/
static bool DKbIn_isProgramButtonPressed(DKbIn * const me) {
    DKbInData data(me->dataBuffer);

    return data.FP1  != 0 ||
           data.FP2  != 0 ||
           data.FP3  != 0 ||
           data.FP4  != 0 ||
           data.FP5  != 0 ||
           data.FP6  != 0 ||
           data.FP7  != 0 ||
           data.FP8  != 0;
}
/*${AOs::DKbIn::printDKbInData} ............................................*/
static void DKbIn_printDKbInData(DKbIn * const me) {
    DKbInData s(me->dataBuffer);

    if (s.FMM) { Serial.println(F("DKbIn: Pressed Function Manual Motion")); }
    if (s.FPS) { Serial.println(F("DKbIn: Pressed Function Pre-Set")); }
    if (s.FPG) { Serial.println(F("DKbIn: Pressed Function User Program")); }
    if (s.FP2) { Serial.println(F("DKbIn: Pressed Function Program 2")); }
    if (s.FP1) { Serial.println(F("DKbIn: Pressed Function Program 1")); }
    if (s.FPP) { Serial.println(F("DKbIn: Pressed Function User Program Play")); }
    if (s.FP3) { Serial.println(F("DKbIn: Pressed Function Program 3")); }
    if (s.FP4) { Serial.println(F("DKbIn: Pressed Function Program 4")); }
    if (s.LUT) { Serial.println(F("DKbIn: Pressed Left Upper Top")); }
    if (s.LUR) { Serial.println(F("DKbIn: Pressed Left Upper Right")); }
    if (s.LUL) { Serial.println(F("DKbIn: Pressed Left Upper Left")); }
    if (s.LLL) { Serial.println(F("DKbIn: Pressed Left Lower Left")); }
    if (s.LUB) { Serial.println(F("DKbIn: Pressed Left Upper Bottom")); }
    if (s.LLT) { Serial.println(F("DKbIn: Pressed Left Lower Top")); }
    if (s.LLR) { Serial.println(F("DKbIn: Pressed Left Lower Right")); }
    if (s.LLB) { Serial.println(F("DKbIn: Pressed Left Lower Bottom")); }
    if (s.RUT) { Serial.println(F("DKbIn: Pressed Right Upper Top")); }
    if (s.RUR) { Serial.println(F("DKbIn: Pressed Right Upper Right")); }
    if (s.RUL) { Serial.println(F("DKbIn: Pressed Right Upper Left")); }
    if (s.RUB) { Serial.println(F("DKbIn: Pressed Right Upper Bottom")); }
    if (s.RLT) { Serial.println(F("DKbIn: Pressed Right Lower Top")); }
    if (s.RLL) { Serial.println(F("DKbIn: Pressed Right Lower Left")); }
    if (s.RLB) { Serial.println(F("DKbIn: Pressed Right Lower Bottom")); }
    if (s.RLR) { Serial.println(F("DKbIn: Pressed Right Lower Right")); }
    if (s.FP8) { Serial.println(F("DKbIn: Pressed Function Program 8")); }
    if (s.GAT) { Serial.println(F("DKbIn: Pressed Gating Top")); }
    if (s.GAR) { Serial.println(F("DKbIn: Pressed Gating Right")); }
    if (s.GAL) { Serial.println(F("DKbIn: Pressed Gating Left")); }
    if (s.FP5) { Serial.println(F("DKbIn: Pressed Function Program 5")); }
    if (s.FP6) { Serial.println(F("DKbIn: Pressed Function Program 6")); }
    if (s.FP7) { Serial.println(F("DKbIn: Pressed Function Program 7")); }
    if (s.GAB) { Serial.println(F("DKbIn: Pressed Gating Bottom")); }
}
/*${AOs::DKbIn::SM} ........................................................*/
static QState DKbIn_initial(DKbIn * const me) {
    /* ${AOs::DKbIn::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      READOUTINVERVAL,
      READOUTINVERVAL);

    pinMode(LATCHPIN_IN, OUTPUT);
    pinMode(CLOCKPIN_IN, OUTPUT);
    pinMode(DATAPIN_IN,  INPUT);

    Serial.println(F("DKbIn Initialized"));
    return Q_TRAN(&DKbIn_Read);
}
/*${AOs::DKbIn::SM::Read} ..................................................*/
static QState DKbIn_Read(DKbIn * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::DKbIn::SM::Read} */
        case Q_ENTRY_SIG: {
            me->dataBuffer = 0;

            // Timing 0.5 ms

            #ifdef DKBIN
            digitalWrite(LATCHPIN_IN, 1);
            delayMicroseconds(20);
            digitalWrite(LATCHPIN_IN,0);
            me->dataBuffer = DKbIn_shiftIn32(me);
            // Debug: Serial.println(me->dataBuffer, HEX);
            #endif

            #ifdef SERIALIN
            if (Serial.available() > 0) {
              int serin = Serial.read();
              if (serin > -1) {
                if ((serin & 0x3) == 1) {
                  // Command 1: SoftDKb. The same bit is set as from the shift registers of the hardware DKb.
                  int bitToSet = (serin & ~0x3) >> 2;
                  bitSet(me->dataBuffer, bitToSet);
                }
                else if ((serin & 0x3) == 2) {
                  // Command 2:
                }
              }
            }
            #endif

            // Debug: DKbIn_printDKbInData(me);

            QACTIVE_POST((QMActive *)&AO_DKbIn, evRead_SIG, me->dataBuffer);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::DKbIn::SM::Read::evRead} */
        case evRead_SIG: {
            status_ = Q_TRAN(&DKbIn_Dispatch);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbIn::SM::Dispatch} ..............................................*/
static QState DKbIn_Dispatch(DKbIn * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::DKbIn::SM::Dispatch} */
        case Q_ENTRY_SIG: {
            //Debug: DKbIn_printDKbInData(me);

            // Timing less than 0.05 ms

            DKbInData data(me->dataBuffer);

            // Do some valitity checks here

            // Raise input event to all active object, even though they do not handle the event
            if (data.FMM) {
              #ifdef MANUALMOTION
              QACTIVE_POST((QMActive *)&AO_ManualMotion, evManualMotionPressed_SIG, 0L);
              #endif
              #ifdef PRESET
              QACTIVE_POST((QMActive *)&AO_PreSet, evManualMotionPressed_SIG, 0L);
              #endif
              #ifdef USERPROGRAM
              QACTIVE_POST((QMActive *)&AO_UserProgram, evManualMotionPressed_SIG, 0L);
              #endif
              #ifdef DKBOUT
              QACTIVE_POST((QMActive *)&AO_DKbOut, evManualMotionPressed_SIG, 0L);
              #endif
            } else if (data.FPS) {
              #ifdef MANUALMOTION
              QACTIVE_POST((QMActive *)&AO_ManualMotion, evPreSetPressed_SIG, 0L);
              #endif
              #ifdef PRESET
              QACTIVE_POST((QMActive *)&AO_PreSet, evPreSetPressed_SIG, 0L);
              #endif
              #ifdef USERPROGRAM
              QACTIVE_POST((QMActive *)&AO_UserProgram, evPreSetPressed_SIG, 0L);
              #endif
              #ifdef DKBOUT
              QACTIVE_POST((QMActive *)&AO_DKbOut, evPreSetPressed_SIG, 0L);
              #endif
            } else if (data.FPG) {
              #ifdef MANUALMOTION
              QACTIVE_POST((QMActive *)&AO_ManualMotion, evUserProgramPressed_SIG, 0L);
              #endif
              #ifdef PRESET
              QACTIVE_POST((QMActive *)&AO_PreSet, evUserProgramPressed_SIG, 0L);
              #endif
              #ifdef USERPROGRAM
              QACTIVE_POST((QMActive *)&AO_UserProgram, evUserProgramPressed_SIG, 0L);
              #endif
              #ifdef DKBOUT
              QACTIVE_POST((QMActive *)&AO_DKbOut, evUserProgramPressed_SIG, 0L);
              #endif
            } else if (DKbIn_isMotorButtonPressed(me)) {
              #ifdef MANUALMOTION
              QACTIVE_POST((QMActive *)&AO_ManualMotion, evMotorButtonPressed_SIG, me->dataBuffer);
              #endif
              #ifdef PRESET
              QACTIVE_POST((QMActive *)&AO_PreSet, evMotorButtonPressed_SIG, me->dataBuffer);
              #endif
              #ifdef USERPROGRAM
              QACTIVE_POST((QMActive *)&AO_UserProgram, evMotorButtonPressed_SIG, me->dataBuffer);
              #endif
              #ifdef DKBOUT
              QACTIVE_POST((QMActive *)&AO_DKbOut, evMotorButtonPressed_SIG, me->dataBuffer);
              #endif
            } else if (DKbIn_isProgramButtonPressed(me)) {
              #ifdef MANUALMOTION
              QACTIVE_POST((QMActive *)&AO_ManualMotion, evProgramButtonPressed_SIG, me->dataBuffer);
              #endif
              #ifdef PRESET
              QACTIVE_POST((QMActive *)&AO_PreSet, evProgramButtonPressed_SIG, me->dataBuffer);
              #endif
              #ifdef USERPROGRAM
              QACTIVE_POST((QMActive *)&AO_UserProgram, evProgramButtonPressed_SIG, me->dataBuffer);
              #endif
              #ifdef DKBOUT
              QACTIVE_POST((QMActive *)&AO_DKbOut, evProgramButtonPressed_SIG, me->dataBuffer);
              #endif
            } else if (data.FPP) {
              #ifdef MANUALMOTION
              QACTIVE_POST((QMActive *)&AO_ManualMotion, evUserProgramPlayPressed_SIG, me->dataBuffer);
              #endif
              #ifdef PRESET
              QACTIVE_POST((QMActive *)&AO_PreSet, evUserProgramPlayPressed_SIG, me->dataBuffer);
              #endif
              #ifdef USERPROGRAM
              QACTIVE_POST((QMActive *)&AO_UserProgram, evUserProgramPlayPressed_SIG, me->dataBuffer);
              #endif
              #ifdef DKBOUT
              QACTIVE_POST((QMActive *)&AO_DKbOut, evUserProgramPlayPressed_SIG, me->dataBuffer);
              #endif
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::DKbIn::SM::Dispatch::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&DKbIn_Read);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

#ifdef MANUALMOTION
/*${AOs::ManualMotion} .....................................................*/
/*${AOs::ManualMotion::SM} .................................................*/
static QState ManualMotion_initial(ManualMotion * const me) {
    /* ${AOs::ManualMotion::SM::initial} */
    me->speed = 4;

    Serial.println(F("ManualMotion Initialized"));
    return Q_TRAN(&ManualMotion_ManualMotion);
}
/*${AOs::ManualMotion::SM::ManualMotion} ...................................*/
static QState ManualMotion_ManualMotion(ManualMotion * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::ManualMotion::SM::ManualMotion} */
        case Q_ENTRY_SIG: {
            // Debug: Serial.println(F("ManualMotion: Enter Active"));
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::ManualMotion::SM::ManualMotion::evUserProgramPressed} */
        case evUserProgramPressed_SIG: {
            status_ = Q_TRAN(&ManualMotion_Idle);
            break;
        }
        /* ${AOs::ManualMotion::SM::ManualMotion::evPreSetPressed} */
        case evPreSetPressed_SIG: {
            status_ = Q_TRAN(&ManualMotion_Idle);
            break;
        }
        /* ${AOs::ManualMotion::SM::ManualMotion::evMotorButtonPressed} */
        case evMotorButtonPressed_SIG: {
            #ifdef MOTOROUT
            uint32_t par = Q_PAR(me);
            DKbInData dd(par);
            // Debug: Serial.println(par, HEX);

            uint8_t step = (me->speed / 3) + 1;

            if (dd.LUT) {
              // Debug: Serial.println(F("Move left upper lng"));
              MotorData dm(LULNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.LUB) {
              // Debug: Serial.println(F("Move left upper lng"));
              MotorData dm(LULNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }
            if (dd.LUR) {
              // Debug: Serial.println(F("Move left upper Rtn"));
              MotorData dm(LURTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.LUL) {
              // Debug: Serial.println(F("Move left upper Rtn"));
              MotorData dm(LURTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }

            if (dd.RUT) {
              // Debug: Serial.println(F("Move right upper lng"));
              MotorData dm(RULNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.RUB) {
              // Debug: Serial.println(F("Move right upper lng"));
              MotorData dm(RULNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }
            if (dd.RUR) {
              // Debug: Serial.println(F("Move right upper Rtn"));
              MotorData dm(RURTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.RUL) {
              // Debug: Serial.println(F("Move right upper Rtn"));
              MotorData dm(RURTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }

            if (dd.LLT) {
              // Debug: Serial.println(F("Move left lower lng"));
              MotorData dm(LLLNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.LLB) {
              // Debug: Serial.println(F("Move left lower lng"));
              MotorData dm(LLLNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }
            if (dd.LLR) {
              // Debug: Serial.println(F("Move left lower Rtn"));
              MotorData dm(LLRTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.LLL) {
              // Debug: Serial.println(F("Move left lower Rtn"));
              MotorData dm(LLRTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }

            if (dd.RLT) {
              // Debug: Serial.println(F("Move right lower lng"));
              MotorData dm(RLLNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.RLB) {
              // Debug: Serial.println(F("Move right lower lng"));
              MotorData dm(RLLNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }
            if (dd.RLR) {
              // Debug: Serial.println(F("Move right lower Rtn"));
              MotorData dm(RLRTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.RLL) {
              // Debug: Serial.println(F("Move right lower Rtn"));
              MotorData dm(RLRTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }

            if (dd.GAT) {
              //Serial.println(F("Move Gating lng"));
              MotorData dm(GALNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.GAB) {
              //Serial.println(F("Move Gating lng"));
              MotorData dm(GALNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }
            if (dd.GAR) {
              //Serial.println(F("Move Gating Rtn"));
              MotorData dm(GARTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.GAL) {
              //Serial.println(F("Move Gating Rtn"));
              MotorData dm(GARTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }

            #endif
            status_ = Q_TRAN(&ManualMotion_ManualMotion);
            break;
        }
        /* ${AOs::ManualMotion::SM::ManualMotion::evProgramButtonPressed} */
        case evProgramButtonPressed_SIG: {
            #ifdef MOTOROUT
            Serial.println(F("Change speed"));

            uint32_t par = Q_PAR(me);
            DKbInData dd(par);
            // Debug: Serial.println(par, HEX);

            if      (dd.FP1) { me->speed = 1; }
            else if (dd.FP2) { me->speed = 2; }
            else if (dd.FP3) { me->speed = 3; }
            else if (dd.FP4) { me->speed = 4; }
            else if (dd.FP5) { me->speed = 5; }
            else if (dd.FP6) { me->speed = 6; }
            else if (dd.FP7) { me->speed = 7; }
            else if (dd.FP8) { me->speed = 8; }

            #endif
            status_ = Q_TRAN(&ManualMotion_ManualMotion);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::ManualMotion::SM::Idle} ...........................................*/
static QState ManualMotion_Idle(ManualMotion * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::ManualMotion::SM::Idle} */
        case Q_ENTRY_SIG: {
            Serial.println("ManualMotion: Enter Idle");
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::ManualMotion::SM::Idle::evManualMotionPressed} */
        case evManualMotionPressed_SIG: {
            status_ = Q_TRAN(&ManualMotion_ManualMotion);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

#endif
#ifdef PRESET
/*${AOs::PreSet} ...........................................................*/
/*${AOs::PreSet::isCurrentPreSet} ..........................................*/
static bool PreSet_isCurrentPreSet(PreSet * const me) {
    uint32_t par = Q_PAR(me);
    DKbInData dd(par);

    if      (dd.FP1 && me->currentPreSet == 1) return true;
    else if (dd.FP2 && me->currentPreSet == 2) return true;
    else if (dd.FP3 && me->currentPreSet == 3) return true;
    else if (dd.FP4 && me->currentPreSet == 4) return true;
    else if (dd.FP5 && me->currentPreSet == 5) return true;
    else if (dd.FP6 && me->currentPreSet == 6) return true;
    else if (dd.FP7 && me->currentPreSet == 7) return true;
    else if (dd.FP8 && me->currentPreSet == 8) return true;
    else return false;

}
/*${AOs::PreSet::prog3} ....................................................*/
static void PreSet_prog3(PreSet * const me) {
    // Marker Position 1 <-> 2

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorData lulng(LULNG, 147, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData lurtn(LURTN, 147, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lurtn.raw);
      MotorData rulng(RULNG, 122, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData rurtn(RURTN, 122, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rurtn.raw);
      MotorData lllng(LLLNG, 107, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData llrtn(LLRTN, 132, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, llrtn.raw);
      MotorData rllng(RLLNG, 132, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData rlrtn(RLRTN, 107, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rlrtn.raw);

      MotorData galng(GALNG, 0, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
      MotorData gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {
      static const uint8_t PROGMEM STEPSZ = 1;
      float targetDeltaSmall = 10 * sin((me->preSetTimer - 3000) / 3000.0 * PI);
      float targetDeltaLarge = 40 * sin((me->preSetTimer - 3000) / 3000.0 * PI);

      MotorData lulng(LULNG, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData lurtn(LURTN, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lurtn.raw);
      MotorData rulng(RULNG, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData rurtn(RURTN, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rurtn.raw);
      MotorData lllng(LLLNG, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData llrtn(LLRTN, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, llrtn.raw);
      MotorData rllng(RLLNG, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData rlrtn(RLRTN, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rlrtn.raw);
    }

    if (me->preSetTimer == 8960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}
/*${AOs::PreSet::prog1} ....................................................*/
static void PreSet_prog1(PreSet * const me) {
    // Marker Position 1

    static const uint8_t PROGMEM STEPSZ = 2;
    if (me->preSetTimer == 0) {
      MotorData lulng(LULNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData lurtn(LURTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lurtn.raw);
      MotorData rulng(RULNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData rurtn(RURTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rurtn.raw);
      MotorData lllng(LLLNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData llrtn(LLRTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, llrtn.raw);
      MotorData rllng(RLLNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData rlrtn(RLRTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rlrtn.raw);

      MotorData galng(GALNG, 0, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
      MotorData gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, gartn.raw);
    }
    else if (me->preSetTimer == 3000) {
      MotorData lulng(LULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lurtn.raw);
      MotorData rulng(RULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rurtn.raw);
      MotorData lllng(LLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, llrtn.raw);
      MotorData rllng(RLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rlrtn.raw);
    }

    if (me->preSetTimer < 3000) {
      me->preSetTimer += PRESETTIMERINCR;
    }

}
/*${AOs::PreSet::prog2} ....................................................*/
static void PreSet_prog2(PreSet * const me) {
    // Marker Position 2

    static const uint8_t PROGMEM STEPSZ = 2;
    if (me->preSetTimer == 0) {
      MotorData lulng(LULNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData lurtn(LURTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lurtn.raw);
      MotorData rulng(RULNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData rurtn(RURTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rurtn.raw);
      MotorData lllng(LLLNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData llrtn(LLRTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, llrtn.raw);
      MotorData rllng(RLLNG, 70, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData rlrtn(RLRTN, 70, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rlrtn.raw);

      MotorData galng(GALNG, 0, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
      MotorData gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, gartn.raw);
    }
    else if (me->preSetTimer == 3000) {
      MotorData lulng(LULNG, 167, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData lurtn(LURTN, 167, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lurtn.raw);
      MotorData rulng(RULNG, 117, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData rurtn(RURTN, 117, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rurtn.raw);
      MotorData lllng(LLLNG, 87, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData llrtn(LLRTN, 137, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, llrtn.raw);
      MotorData rllng(RLLNG, 137, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData rlrtn(RLRTN, 87, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rlrtn.raw);
    }

    if (me->preSetTimer < 3000) {
      me->preSetTimer += PRESETTIMERINCR;
    }

}
/*${AOs::PreSet::prog4} ....................................................*/
static void PreSet_prog4(PreSet * const me) {
    // Free-breath Gating

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorData lulng(LULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lurtn.raw);
      MotorData rulng(RULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rurtn.raw);
      MotorData lllng(LLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, llrtn.raw);
      MotorData rllng(RLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rlrtn.raw);

      MotorData galng(GALNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
      MotorData gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {
      static const uint8_t PROGMEM STEPSZ = 10;
      float target = 127 + 80 * sin((me->preSetTimer - 3000) / 2500.0 * PI);

      MotorData lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);

      MotorData galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
    }

    if (me->preSetTimer == 7960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}
/*${AOs::PreSet::prog5} ....................................................*/
static void PreSet_prog5(PreSet * const me) {
    // Breath-hold Gating

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorData lulng(LULNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lurtn.raw);
      MotorData rulng(RULNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rurtn.raw);
      MotorData lllng(LLLNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, llrtn.raw);
      MotorData rllng(RLLNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rlrtn.raw);
      MotorData galng(GALNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
      MotorData gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000 && me->preSetTimer < 28000) {
      static const uint8_t PROGMEM STEPSZ = 10;
      float target = 60 + 50 * sin((me->preSetTimer - 3000) / 2500.0 * PI);

      MotorData lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
    }
    else if (me->preSetTimer == 28000) {
      static const uint8_t PROGMEM STEPSZ = 4;
      MotorData lulng(LULNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData rulng(RULNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData lllng(LLLNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData rllng(RLLNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData galng(GALNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
    }
    else if (me->preSetTimer > 28000 && me->preSetTimer < 38000) {
      static const uint8_t PROGMEM STEPSZ = 10;
      float target = 200 + 50 * cos((me->preSetTimer - 28000) / 40000.0 * PI);
      Serial.println(target);
      MotorData lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
    }
    else if (me->preSetTimer == 38000) {
      static const uint8_t PROGMEM STEPSZ = 4;
      MotorData lulng(LULNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData rulng(RULNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData lllng(LLLNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData rllng(RLLNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData galng(GALNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
    }

    if (me->preSetTimer == 40000) {
      me->preSetTimer = 6720;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}
/*${AOs::PreSet::prog6} ....................................................*/
static void PreSet_prog6(PreSet * const me) {
    // Free-breath Gating, Marker Position 1 <-> 2

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorData lulng(LULNG, 147, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData lurtn(LURTN, 147, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lurtn.raw);
      MotorData rulng(RULNG, 122, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData rurtn(RURTN, 122, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rurtn.raw);
      MotorData lllng(LLLNG, 107, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData llrtn(LLRTN, 132, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, llrtn.raw);
      MotorData rllng(RLLNG, 132, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData rlrtn(RLRTN, 107, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rlrtn.raw);

      MotorData galng(GALNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
      MotorData gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {

      static const uint8_t PROGMEM STEPSZ = 10;
      float targetDeltaSmall = 10 * sin((me->preSetTimer - 3000) / 3000.0 * PI);
      float targetDeltaLarge = 40 * sin((me->preSetTimer - 3000) / 3000.0 * PI);
      float targetGating = 127 + 80 * sin((me->preSetTimer - 3000) / 3000.0 * PI);

      MotorData lulng(LULNG, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData lurtn(LURTN, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lurtn.raw);
      MotorData rulng(RULNG, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData rurtn(RURTN, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rurtn.raw);
      MotorData lllng(LLLNG, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData llrtn(LLRTN, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, llrtn.raw);
      MotorData rllng(RLLNG, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData rlrtn(RLRTN, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rlrtn.raw);

      MotorData galng(GALNG, targetGating, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
    }

    if (me->preSetTimer == 8960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}
/*${AOs::PreSet::prog7} ....................................................*/
static void PreSet_prog7(PreSet * const me) {
    // Free-breath Gating loosing signal

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorData lulng(LULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lurtn.raw);
      MotorData rulng(RULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rurtn.raw);
      MotorData lllng(LLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, llrtn.raw);
      MotorData rllng(RLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rlrtn.raw);
      MotorData galng(GALNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
      MotorData gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {
      static const uint8_t PROGMEM STEPSZ = 10;
      float target = 127 + 80 * sin((me->preSetTimer - 3000) / 2500.0 * PI);

      MotorData lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
    }

    if (me->preSetTimer == 25000) {
      static const uint8_t PROGMEM STEPSZ = 3;

      MotorData gartn(GARTN, 255, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, gartn.raw);
    }
    else if (me->preSetTimer == 35000) {
      static const uint8_t PROGMEM STEPSZ = 3;

      MotorData gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, gartn.raw);
    }

    if (me->preSetTimer == 37960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}
/*${AOs::PreSet::prog8} ....................................................*/
static void PreSet_prog8(PreSet * const me) {
    // Free-breath Gating base line shift

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorData lulng(LULNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lurtn.raw);
      MotorData rulng(RULNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rurtn.raw);
      MotorData lllng(LLLNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, llrtn.raw);
      MotorData rllng(RLLNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rlrtn.raw);
      MotorData galng(GALNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
      MotorData gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {
      static const uint8_t PROGMEM STEPSZ = 10;
      float baseline = 130 + 30 * sin((me->preSetTimer - 3000) / 30000.0 * PI);
      float target = baseline + 50 * sin((me->preSetTimer - 3000) / 3000.0 * PI);

      MotorData lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
      MotorData rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rulng.raw);
      MotorData lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lllng.raw);
      MotorData rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, rllng.raw);
      MotorData galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, galng.raw);
    }

    if (me->preSetTimer == 62960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}
/*${AOs::PreSet::SM} .......................................................*/
static QState PreSet_initial(PreSet * const me) {
    /* ${AOs::PreSet::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      PRESETTIMERINTERVAL,
      PRESETTIMERINTERVAL);

    Serial.println(F("PreSet Initialized"));
    return Q_TRAN(&PreSet_Idle);
}
/*${AOs::PreSet::SM::Idle} .................................................*/
static QState PreSet_Idle(PreSet * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::PreSet::SM::Idle} */
        case Q_ENTRY_SIG: {
            Serial.println("PreSet: Enter Idle");
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::PreSet::SM::Idle::evPreSetPressed} */
        case evPreSetPressed_SIG: {
            status_ = Q_TRAN(&PreSet_WaitForProgram);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::PreSet::SM::WaitForProgram} .......................................*/
static QState PreSet_WaitForProgram(PreSet * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::PreSet::SM::WaitForProgram} */
        case Q_ENTRY_SIG: {
            Serial.println(F("PreSet: Enter WaitForProgram"));

            me->preSetTimer = 0;
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::PreSet::SM::WaitForProgram::evManualMotionPressed} */
        case evManualMotionPressed_SIG: {
            status_ = Q_TRAN(&PreSet_Idle);
            break;
        }
        /* ${AOs::PreSet::SM::WaitForProgram::evUserProgramPressed} */
        case evUserProgramPressed_SIG: {
            status_ = Q_TRAN(&PreSet_Idle);
            break;
        }
        /* ${AOs::PreSet::SM::WaitForProgram::evProgramButtonPressed} */
        case evProgramButtonPressed_SIG: {
            uint32_t par = Q_PAR(me);
            DKbInData dd(par);

            if      (dd.FP1) { me->currentPreSet = 1; }
            else if (dd.FP2) { me->currentPreSet = 2; }
            else if (dd.FP3) { me->currentPreSet = 3; }
            else if (dd.FP4) { me->currentPreSet = 4; }
            else if (dd.FP5) { me->currentPreSet = 5; }
            else if (dd.FP6) { me->currentPreSet = 6; }
            else if (dd.FP7) { me->currentPreSet = 7; }
            else if (dd.FP8) { me->currentPreSet = 8; }

            me->preSetTimer = 0;
            status_ = Q_TRAN(&PreSet_RunProgram);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::PreSet::SM::RunProgram} ...........................................*/
static QState PreSet_RunProgram(PreSet * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::PreSet::SM::RunProgram} */
        case Q_ENTRY_SIG: {
            // Debug: Serial.println(F("PreSet: Enter RunProgram"));

            // Debug:
            //Serial.print(me->currentPreSet);
            //Serial.print(" ");
            //Serial.println(me->preSetCounter);

            #ifdef MOTOROUT
            if (me->currentPreSet == 1) {
              PreSet_prog1(me);
            }
            else if (me->currentPreSet == 2) {
              PreSet_prog2(me);
            }
            else if (me->currentPreSet == 3) {
              PreSet_prog3(me);
            }
            else if (me->currentPreSet == 4) {
              PreSet_prog4(me);
            }
            else if (me->currentPreSet == 5) {
              PreSet_prog5(me);
            }
            else if (me->currentPreSet == 6) {
              PreSet_prog6(me);
            }
            else if (me->currentPreSet == 7) {
              PreSet_prog7(me);
            }
            else if (me->currentPreSet == 8) {
              PreSet_prog8(me);
            }
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::PreSet::SM::RunProgram::evUserProgramPressed} */
        case evUserProgramPressed_SIG: {
            status_ = Q_TRAN(&PreSet_Idle);
            break;
        }
        /* ${AOs::PreSet::SM::RunProgram::evProgramButtonPressed} */
        case evProgramButtonPressed_SIG: {
            /* ${AOs::PreSet::SM::RunProgram::evProgramButtonP~::[currentPreSet]} */
            if (PreSet_isCurrentPreSet(me)) {
                status_ = Q_TRAN(&PreSet_RunProgram);
            }
            /* ${AOs::PreSet::SM::RunProgram::evProgramButtonP~::[else]} */
            else {
                status_ = Q_TRAN(&PreSet_WaitForProgram);
            }
            break;
        }
        /* ${AOs::PreSet::SM::RunProgram::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&PreSet_RunProgram);
            break;
        }
        /* ${AOs::PreSet::SM::RunProgram::evPreSetPressed} */
        case evPreSetPressed_SIG: {
            status_ = Q_TRAN(&PreSet_WaitForProgram);
            break;
        }
        /* ${AOs::PreSet::SM::RunProgram::evManualMotionPressed} */
        case evManualMotionPressed_SIG: {
            status_ = Q_TRAN(&PreSet_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

#endif
#ifdef USERPROGRAM
/*${AOs::UserProgram} ......................................................*/
/*${AOs::UserProgram::SM} ..................................................*/
static QState UserProgram_initial(UserProgram * const me) {
    /* ${AOs::UserProgram::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      USERPROGRAMCOUNTERINTERVAL,
      USERPROGRAMCOUNTERINTERVAL);

    Serial.println(F("UserProgram Initialized"));
    return Q_TRAN(&UserProgram_Idle);
}
/*${AOs::UserProgram::SM::Idle} ............................................*/
static QState UserProgram_Idle(UserProgram * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::UserProgram::SM::Idle} */
        case Q_ENTRY_SIG: {
            Serial.println(F("UserProgram: Enter Idle"));
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::UserProgram::SM::Idle::evUserProgramPressed} */
        case evUserProgramPressed_SIG: {
            memset(me->userProgram, 0, sizeof(me->userProgram));
            status_ = Q_TRAN(&UserProgram_Record);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::UserProgram::SM::Record} ..........................................*/
static QState UserProgram_Record(UserProgram * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::UserProgram::SM::Record} */
        case Q_ENTRY_SIG: {
            Serial.println(F("UserProgram: Enter Record"));
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::UserProgram::SM::Record::evManualMotionPressed} */
        case evManualMotionPressed_SIG: {
            status_ = Q_TRAN(&UserProgram_Idle);
            break;
        }
        /* ${AOs::UserProgram::SM::Record::evUserProgramPlayPressed} */
        case evUserProgramPlayPressed_SIG: {
            me->userProgramCounter = 0;
            status_ = Q_TRAN(&UserProgram_Play);
            break;
        }
        /* ${AOs::UserProgram::SM::Record::evMotorButtonPressed} */
        case evMotorButtonPressed_SIG: {
            #ifdef MOTOROUT
            uint32_t par = Q_PAR(me);
            DKbInData dd(par);
            // Debug: Serial.println(par, HEX);

            const uint8_t SPEED = 6;
            const uint8_t STEP = 2;

            if (dd.LUT) {
              Serial.println(F("Move left upper lng"));
              MotorData dm(LULNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.LUB) {
              Serial.println(F("Move left upper lng"));
              MotorData dm(LULNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }
            else if (dd.LUR) {
              Serial.println(F("Move left upper Rtn"));
              MotorData dm(LURTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.LUL) {
              Serial.println(F("Move left upper Rtn"));
              MotorData dm(LURTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }

            if (dd.RUT) {
              Serial.println(F("Move right upper lng"));
              MotorData dm(RULNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.RUB) {
              Serial.println(F("Move right upper lng"));
              MotorData dm(RULNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }
            else if (dd.RUR) {
              Serial.println(F("Move right upper Rtn"));
              MotorData dm(RURTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.RUL) {
              Serial.println(F("Move right upper Rtn"));
              MotorData dm(RURTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }

            if (dd.LLT) {
              Serial.println(F("Move left lower lng"));
              MotorData dm(LLLNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.LLB) {
              Serial.println(F("Move left lower lng"));
              MotorData dm(LLLNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }
            else if (dd.LLR) {
              Serial.println(F("Move left lower Rtn"));
              MotorData dm(LLRTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.LLL) {
              Serial.println(F("Move left lower Rtn"));
              MotorData dm(LLRTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }

            if (dd.RLT) {
              Serial.println(F("Move right lower lng"));
              MotorData dm(RLLNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.RLB) {
              Serial.println(F("Move right lower lng"));
              MotorData dm(RLLNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }
            else if (dd.RLR) {
              Serial.println(F("Move right lower Rtn"));
              MotorData dm(RLRTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.RLL) {
              Serial.println(F("Move right lower Rtn"));
              MotorData dm(RLRTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }

            if (dd.GAT) {
              Serial.println(F("Move Gating lng"));
              MotorData dm(GALNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.GAB) {
              Serial.println(F("Move Gating lng"));
              MotorData dm(GALNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }
            else if (dd.GAR) {
              Serial.println(F("Move Gating Rtn"));
              MotorData dm(GARTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorForward_SIG, dm.raw);
            }
            else if (dd.GAL) {
              Serial.println(F("Move Gating Rtn"));
              MotorData dm(GARTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorBackward_SIG, dm.raw);
            }

            #endif
            status_ = Q_TRAN(&UserProgram_Record);
            break;
        }
        /* ${AOs::UserProgram::SM::Record::evProgramButtonPressed} */
        case evProgramButtonPressed_SIG: {
            #ifdef MOTOROUT
            uint32_t par = Q_PAR(me);
            DKbInData dd(par);

            uint8_t selection = 0;
            if (dd.FP1) { selection = 0; }
            else if (dd.FP2) { selection = 1; }
            else if (dd.FP3) { selection = 2; }
            else if (dd.FP4) { selection = 3; }
            else if (dd.FP5) { selection = 4; }
            else if (dd.FP6) { selection = 5; }
            else if (dd.FP7) { selection = 6; }
            else if (dd.FP8) { selection = 7; }


            Serial.print(F("Programmed positions at second: "));
            Serial.println(selection);

            me->userProgram[0][selection] = AO_MotorsOut.servoPosition[0];
            me->userProgram[1][selection] = AO_MotorsOut.servoPosition[1];
            me->userProgram[2][selection] = AO_MotorsOut.servoPosition[2];
            me->userProgram[3][selection] = AO_MotorsOut.servoPosition[3];
            me->userProgram[4][selection] = AO_MotorsOut.servoPosition[4];
            me->userProgram[5][selection] = AO_MotorsOut.servoPosition[5];
            me->userProgram[6][selection] = AO_MotorsOut.servoPosition[6];
            me->userProgram[7][selection] = AO_MotorsOut.servoPosition[7];
            me->userProgram[8][selection] = AO_MotorsOut.servoPosition[8];
            me->userProgram[9][selection] = AO_MotorsOut.servoPosition[9];
            #endif
            status_ = Q_TRAN(&UserProgram_Record);
            break;
        }
        /* ${AOs::UserProgram::SM::Record::evPreSetPressed} */
        case evPreSetPressed_SIG: {
            status_ = Q_TRAN(&UserProgram_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::UserProgram::SM::Play} ............................................*/
static QState UserProgram_Play(UserProgram * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::UserProgram::SM::Play} */
        case Q_ENTRY_SIG: {
            Serial.println(F("UserProgram: Enter Play"));

            #ifdef MOTOROUT

            for (int motor=0; motor < NUMSERVOS; motor++) {
              MotorData lulng(ServoNumber(motor), me->userProgram[motor][me->userProgramCounter], 2);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, evMotorAbsMove_SIG, lulng.raw);
            }

            me->userProgramCounter++;
            if (me->userProgramCounter >=8) { me->userProgramCounter = 0; }


            #endif
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::UserProgram::SM::Play::evUserProgramPressed} */
        case evUserProgramPressed_SIG: {
            status_ = Q_TRAN(&UserProgram_Record);
            break;
        }
        /* ${AOs::UserProgram::SM::Play::evManualMotionPressed} */
        case evManualMotionPressed_SIG: {
            status_ = Q_TRAN(&UserProgram_Idle);
            break;
        }
        /* ${AOs::UserProgram::SM::Play::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&UserProgram_Play);
            break;
        }
        /* ${AOs::UserProgram::SM::Play::evPreSetPressed} */
        case evPreSetPressed_SIG: {
            status_ = Q_TRAN(&UserProgram_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

#endif
#ifdef DKBOUT
/*${AOs::DKbOut} ...........................................................*/
/*${AOs::DKbOut::SM} .......................................................*/
static QState DKbOut_initial(DKbOut * const me) {
    /* ${AOs::DKbOut::SM::initial} */
    pinMode(CLOCKPIN_OUT, OUTPUT);
    pinMode(LATCHPIN_OUT, OUTPUT);
    pinMode(DATAPIN_OUT,  OUTPUT);

    Serial.println(F("DKbOut Initialized"));
    return Q_TRAN(&DKbOut_ManualMotionLED);
}
/*${AOs::DKbOut::SM::ManualMotionLED} ......................................*/
static QState DKbOut_ManualMotionLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::DKbOut::SM::ManualMotionLED} */
        case Q_ENTRY_SIG: {
            Serial.println(F("DKbOut: Enter ManualMotionLED |A|"));

            byte whichPin = 1; // DKb r0: 5;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::DKbOut::SM::ManualMotionLED::evPreSetPressed} */
        case evPreSetPressed_SIG: {
            status_ = Q_TRAN(&DKbOut_PreSetLED);
            break;
        }
        /* ${AOs::DKbOut::SM::ManualMotionLED::evUserProgramPressed} */
        case evUserProgramPressed_SIG: {
            status_ = Q_TRAN(&DKbOut_UserProgramRecordLED);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::PreSetLED} ............................................*/
static QState DKbOut_PreSetLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::DKbOut::SM::PreSetLED} */
        case Q_ENTRY_SIG: {
            Serial.println(F("DKbOut: Enter PreSetLED |B|"));

            byte whichPin = 0; // DKb r0: 4;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::DKbOut::SM::PreSetLED::evManualMotionPressed} */
        case evManualMotionPressed_SIG: {
            status_ = Q_TRAN(&DKbOut_ManualMotionLED);
            break;
        }
        /* ${AOs::DKbOut::SM::PreSetLED::evUserProgramPressed} */
        case evUserProgramPressed_SIG: {
            status_ = Q_TRAN(&DKbOut_UserProgramRecordLED);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::UserProgramRecordLED} .................................*/
static QState DKbOut_UserProgramRecordLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::DKbOut::SM::UserProgramRecordLED} */
        case Q_ENTRY_SIG: {
            Serial.println(F("DKbOut: Enter UserProgramRecordLED |C|"));

            byte whichPin = 3; // DKb r0: 2;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::DKbOut::SM::UserProgramRecor~::evManualMotionPressed} */
        case evManualMotionPressed_SIG: {
            status_ = Q_TRAN(&DKbOut_ManualMotionLED);
            break;
        }
        /* ${AOs::DKbOut::SM::UserProgramRecor~::evPreSetPressed} */
        case evPreSetPressed_SIG: {
            status_ = Q_TRAN(&DKbOut_PreSetLED);
            break;
        }
        /* ${AOs::DKbOut::SM::UserProgramRecor~::evUserProgramPlayPressed} */
        case evUserProgramPlayPressed_SIG: {
            status_ = Q_TRAN(&DKbOut_UserProgramPlayLED);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::UserProgramPlayLED} ...................................*/
static QState DKbOut_UserProgramPlayLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::DKbOut::SM::UserProgramPlayLED} */
        case Q_ENTRY_SIG: {
            Serial.println(F("DKbOut: Enter UserProgramPlayLED |D|"));

            byte whichPin = 2; // DKb r0: 3;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::DKbOut::SM::UserProgramPlayL~::evManualMotionPressed} */
        case evManualMotionPressed_SIG: {
            status_ = Q_TRAN(&DKbOut_ManualMotionLED);
            break;
        }
        /* ${AOs::DKbOut::SM::UserProgramPlayL~::evPreSetPressed} */
        case evPreSetPressed_SIG: {
            status_ = Q_TRAN(&DKbOut_PreSetLED);
            break;
        }
        /* ${AOs::DKbOut::SM::UserProgramPlayL~::evUserProgramPressed} */
        case evUserProgramPressed_SIG: {
            status_ = Q_TRAN(&DKbOut_UserProgramRecordLED);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

#endif
#ifdef MOTOROUT
/*${AOs::MotorsOut} ........................................................*/
/*${AOs::MotorsOut::isInitialized} .........................................*/
static bool MotorsOut_isInitialized(MotorsOut * const me) {
    return me->initializeCounter == NUMSERVOS;
}
/*${AOs::MotorsOut::SM} ....................................................*/
static QState MotorsOut_initial(MotorsOut * const me) {
    /* ${AOs::MotorsOut::SM::initial} */
    // Give the capacitor time to load
    QActive_armX((QActive *)me, 0U,
      MOTORSTARTUPDELAY*5,
      MOTORSTARTUPDELAY*5);

    servoLib.begin();
    me->initializeCounter = 0;

    Serial.println(F("MotorOut Initialized"));
    return Q_TRAN(&MotorsOut_Wait);
}

// Timings:
// servoLib.write for 16 motors takes 9 ms
// Serial print takes 0.2 ms
// Meassured with the oscilloscope and digitalWrite(HIGH/LOW)
/*${AOs::MotorsOut::SM::Active} ............................................*/
static QState MotorsOut_Active(MotorsOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::MotorsOut::SM::Active} */
        case Q_ENTRY_SIG: {
            //Serial.println(F("MotorsOut: Enter Active"));
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::MotorsOut::SM::Active::evMotorForward} */
        case evMotorForward_SIG: {
            uint32_t par = Q_PAR(me);
            MotorData dm(par);
            // Debug: Serial.println(par, HEX);

            me->stepSize[dm.ServoNum] = dm.StepSize;
            int pos = me->servoPosition[dm.ServoNum] + dm.relpos(); // relpos() can be negative or positive
            if (pos < 0) { pos = 0; }
            else if (pos > 255) { pos = 255; }

            me->target[dm.ServoNum] = pos;
            status_ = Q_TRAN(&MotorsOut_Active);
            break;
        }
        /* ${AOs::MotorsOut::SM::Active::evMotorBackward} */
        case evMotorBackward_SIG: {
            uint32_t par = Q_PAR(me);
            MotorData dm(par);
            // Debug: Serial.println(par, HEX);

            me->stepSize[dm.ServoNum] = dm.StepSize;
            // Debug: Serial.println(dm.StepSize);
            int pos = me->servoPosition[dm.ServoNum] - dm.relpos(); // pos() can be negative or positive
            if (pos < 0) { pos = 0; }
            else if (pos > 255) { pos = 255; }

            me->target[dm.ServoNum] = pos;
            status_ = Q_TRAN(&MotorsOut_Active);
            break;
        }
        /* ${AOs::MotorsOut::SM::Active::evMotorAbsMove} */
        case evMotorAbsMove_SIG: {
            uint32_t par = Q_PAR(me);
            MotorData dm(par);
            // Debug: Serial.println(par, HEX);

            me->stepSize[dm.ServoNum] = dm.StepSize;
            if (dm.abspos() >= 0 && dm.abspos() <= 255) {
              me->target[dm.ServoNum] = dm.abspos();
            } else {
              me->target[dm.ServoNum] = me->servoPosition[dm.ServoNum];
            }
            status_ = Q_TRAN(&MotorsOut_Active);
            break;
        }
        /* ${AOs::MotorsOut::SM::Active::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {

            #ifdef SERIALIN
            bool isMoving = false;
            #endif

            for (int n=0; n < NUMSERVOS; n++) {

              int newPos = me->servoPosition[n];
              if (me->servoPosition[n] < me->target[n]) {
                newPos = min(me->servoPosition[n]+me->stepSize[n], me->target[n]);
              }
              if (me->target[n] < me->servoPosition[n]) {
                newPos = max(me->servoPosition[n]-me->stepSize[n], me->target[n]);
              }
              if (newPos != me->servoPosition[n]) {
                me->servoPosition[n] = newPos;
                #ifdef SERIALIN
                isMoving = true;
                #endif
                servoLib.write(n, me->servoPosition[n]);
              }
            }

            #ifdef SERIALIN
            if (!isMoving) {
              if (me->_sendPositionCounter % 10  == 0) {
                int servo = (me->_sendPositionCounter / 10) - 1;
                Serial.print("|");
                Serial.print(servo);
                Serial.print(me->servoPosition[servo]);
                Serial.print("|");
                if (me->_sendPositionCounter == 100) me->_sendPositionCounter = 0;
              }
              me->_sendPositionCounter++;
            }
            #endif
            status_ = Q_TRAN(&MotorsOut_Active);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::MotorsOut::SM::Wait} ..............................................*/
static QState MotorsOut_Wait(MotorsOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::MotorsOut::SM::Wait::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            QActive_armX((QActive *)me, 0U,
              MOTORSTARTUPDELAY,
              MOTORSTARTUPDELAY);
            /* ${AOs::MotorsOut::SM::Wait::Q_TIMEOUT::[isinitialized]} */
            if (MotorsOut_isInitialized(me)) {
                QActive_armX((QActive *)me, 0U,
                  MOTORSENDINTERVAL,
                  MOTORSENDINTERVAL);

                Serial.println(F("MotorsOut: Enter Active"));
                status_ = Q_TRAN(&MotorsOut_Active);
            }
            /* ${AOs::MotorsOut::SM::Wait::Q_TIMEOUT::[else]} */
            else {
                // Debug: Serial.print("Initialize: "); Serial.println(me->initializeCounter);

                servoLib.write(me->initializeCounter, 127);
                me->servoPosition[me->initializeCounter] = 127;
                me->target[me->initializeCounter] = 127;
                me->stepSize[me->initializeCounter] = 1;

                me->initializeCounter++;
                status_ = Q_TRAN(&MotorsOut_Wait);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

#endif

