/*****************************************************************************
* Model: gris5A.qm
* File:  ./gris5A.ino
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::gris5A.ino} .........................................................*/
/* gris5A.qm - Arduino software for the GRIS5A (C) motion phantom
 * Copyright (C) 2018-2019 by Stefan Grimm
 */

#include "qpn.h"     // QP-nano framework
#include "Arduino.h" // Arduino API
#define DKBIN
#define SERIALIN
#define MANUALMOTION
#define PRESET
#define USERPROGRAM
#define DKBOUT
#define MOTOROUT

#include "FreeMemory.h"

#ifdef MOTOROUT
#include "_Adafruit_PWMServoDriver.h"
#include "prfServo.h"

class ServoShieldPCA9685Linear : public prfServoImplBase<uint16_t, float> {
  public:
  void begin() {
    pwm.begin();
    pwm.setPWMFreq(60);
    // Set pwm signal to off.
    // The servo shield does not like signal when it is powered. 1.5 Amperes are flowing.
    // setPWMOn() has interestingly the same effect.
    pwm.setPWMOff();
  }

  void get(float** params) const {
    // LURTN
    params[0][0] = 1.2942268654268088e+002;
    params[0][1] = 1.6668375402407262e+000;
    // LULNG
    params[1][0] = 5.5452380952380930e+002;
    params[1][1] = -2.6484593837534930e+000;
    params[1][2] = 1.1929477673422232e-002;
    params[1][3] = -2.7138883234954693e-005;
    // LLRTN
    params[2][0] = 1.5442914556378040e+002;
    params[2][1] = 1.5882527835305206e+000;
    // LLLNG
    params[3][0] = 1.3666666666666668e+002;
    params[3][1] = 2.8253968253968250e+000;
    params[3][2] = -1.3016971494480146e-002;
    params[3][3] = 3.0757400999615536e-005;
    // RLLNG
    params[4][0] = 5.7880952380952260e+002;
    params[4][1] = -2.3641456582632174e+000;
    params[4][2] = 9.3590377327392710e-003;
    params[4][3] = -2.1711106587961670e-005;
    // RLRTN
    params[5][0] = 1.3774938998134064e+002;
    params[5][1] = 1.5490885603559636e+000;
    // RULNG
    params[6][0] = 1.8559523809523685e+002;
    params[6][1] = 2.1031746031746907e+000;
    params[6][2] = -7.4147305981224840e-003;
    params[6][3] = 1.8092588823305492e-005;
    // RURTN
    params[7][0] = 1.6024944124341286e+002;
    params[7][1] = 1.6079886813344540e+000;
    // GALNG
    params[8][0] = 5.3464285714285590e+002;
    params[8][1] = -2.8109243697478114e+000;
    params[8][2] = 1.3346515076618000e-002;
    params[8][3] = -3.2566659881943620e-005;
    // GARTN
    params[9][0] = 1.4526246180975622e+002;
    params[9][1] = 1.5686194098710244e+000;
  }

  void write(uint8_t num, uint16_t servoVal) {
    pwm.setPWM(num, 0, servoVal);
  }

  private:
  Adafruit_PWMServoDriver pwm;
};

ServoShieldPCA9685Linear impl;
prfServo<uint32_t, uint8_t, uint16_t, float> servoLib(&impl, 0x777DD);

#define NUMSERVOS 10

#endif


#define Q_PARAM_SIZE   4

//============================================================================
// declare all AO classes...
#ifdef DKBIN

#if ((QP_VERSION < 591) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpn version 5.9.1 or higher required
#endif

/*${AOs::DKbIn} ............................................................*/
typedef struct DKbIn {
/* protected: */
    QActive super;

/* public: */
    uint32_t dataBuffer;
} DKbIn;

/* public: */
static uint32_t DKbIn_shiftIn32(DKbIn * const me);
static bool DKbIn_isMotorButtonPressed(DKbIn const * const me);
static bool DKbIn_isProgramButtonPressed(DKbIn const * const me);
static void DKbIn_printDKbInData(DKbIn * const me);
static void DKbIn_dispatchDKbIn(DKbIn const * const me);

/* protected: */
static QState DKbIn_initial(DKbIn * const me);
static QState DKbIn_Read(DKbIn * const me);

#endif
#ifdef SERIALIN
/*${AOs::SerialIn} .........................................................*/
typedef struct SerialIn {
/* protected: */
    QActive super;

/* public: */
    uint8_t remainingBytes;
} SerialIn;

/* public: */
static void SerialIn_processRemainingBytes(SerialIn * const me);

/* protected: */
static QState SerialIn_initial(SerialIn * const me);
static QState SerialIn_Receive(SerialIn * const me);

#endif
#ifdef MANUALMOTION
/*${AOs::ManualMotion} .....................................................*/
typedef struct ManualMotion {
/* protected: */
    QActive super;

/* public: */
    uint8_t speed;
} ManualMotion;

/* protected: */
static QState ManualMotion_initial(ManualMotion * const me);
static QState ManualMotion_ManualMotion(ManualMotion * const me);
static QState ManualMotion_Idle(ManualMotion * const me);

#endif
#ifdef PRESET
/*${AOs::PreSet} ...........................................................*/
typedef struct PreSet {
/* protected: */
    QActive super;

/* public: */
    uint8_t currentPreSet;
    uint16_t preSetTimer;
} PreSet;

/* public: */
static bool PreSet_isCurrentPreSet(PreSet * const me);
static void PreSet_prog3(PreSet * const me);
static void PreSet_prog1(PreSet * const me);
static void PreSet_prog2(PreSet * const me);
static void PreSet_prog4(PreSet * const me);
static void PreSet_prog5(PreSet * const me);
static void PreSet_prog6(PreSet * const me);
static void PreSet_prog7(PreSet * const me);
static void PreSet_prog8(PreSet * const me);

/* protected: */
static QState PreSet_initial(PreSet * const me);
static QState PreSet_Idle(PreSet * const me);
static QState PreSet_WaitForProgram(PreSet * const me);
static QState PreSet_RunProgram(PreSet * const me);

#endif
#ifdef USERPROGRAM
/*${AOs::UserProgram} ......................................................*/
typedef struct UserProgram {
/* protected: */
    QActive super;

/* public: */
    uint8_t userProgramCounter;
    uint8_t userProgram[NUMSERVOS][8];
} UserProgram;

/* protected: */
static QState UserProgram_initial(UserProgram * const me);
static QState UserProgram_Idle(UserProgram * const me);
static QState UserProgram_Record(UserProgram * const me);
static QState UserProgram_Play(UserProgram * const me);

#endif
#ifdef DKBOUT
/*${AOs::DKbOut} ...........................................................*/
typedef struct DKbOut {
/* protected: */
    QActive super;
} DKbOut;

/* protected: */
static QState DKbOut_initial(DKbOut * const me);
static QState DKbOut_ManualMotionLED(DKbOut * const me);
static QState DKbOut_PreSetLED(DKbOut * const me);
static QState DKbOut_UserProgramRecordLED(DKbOut * const me);
static QState DKbOut_UserProgramPlayLED(DKbOut * const me);

#endif
#ifdef MOTOROUT
/*${AOs::MotorsOut} ........................................................*/
typedef struct MotorsOut {
/* protected: */
    QActive super;

/* public: */
    uint8_t servoPosition[NUMSERVOS];
    uint8_t target[NUMSERVOS];
    uint8_t stepSize[NUMSERVOS];
    uint16_t _sendPositionCounter;
    uint8_t initializeCounter;
} MotorsOut;

/* public: */
static bool MotorsOut_isInitialized(MotorsOut * const me);

/* protected: */
static QState MotorsOut_initial(MotorsOut * const me);

// Timings:
// servoLib.write for 16 motors takes 9 ms
// Serial print takes 0.2 ms
// Meassured with the oscilloscope and digitalWrite(HIGH/LOW)
static QState MotorsOut_Active(MotorsOut * const me);
static QState MotorsOut_Wait(MotorsOut * const me);

#endif

// AO instances and event queue buffers for them...
#ifdef DKBIN
DKbIn AO_DKbIn;
static QEvt l_DKbInQSto[2];
#endif
#ifdef SERIALIN
SerialIn AO_SerialIn;
static QEvt l_SerialInQSto[1];
#endif
#ifdef MANUALMOTION
ManualMotion AO_ManualMotion;
static QEvt l_ManualMotionQSto[5];
#endif
#ifdef PRESET
PreSet AO_PreSet;
static QEvt l_PreSetQSto[5];
#endif
#ifdef USERPROGRAM
UserProgram AO_UserProgram;
static QEvt l_UserProgramQSto[5];
#endif
#ifdef DKBOUT
DKbOut AO_DKbOut;
static QEvt l_DKbOutQSto[1];
#endif
#ifdef MOTOROUT
MotorsOut AO_MotorsOut;
static QEvt l_MotorsOutQSto[NUMSERVOS*2];
#endif


//============================================================================
// events used in this application...
enum Signals {
  MANUAL_MOTION_PRESSED_SIG = Q_USER_SIG,
  PRESET_PRESSED_SIG,
  USERPROGRAM_PRESSED_SIG,
  USERPROGRAM_PLAY_PRESSED_SIG,
  MOTORBUTTON_PRESSED_SIG,
  PROGRAMBUTTON_PRESSED_SIG,
  MOTOR_STEP_FORWARD_SIG,
  MOTOR_STEP_BACKWARD_SIG,
  MOTOR_MOVE_ASOLUTE_SIG,
  DKBIN_DISPATCH_SIG
};

enum Pins {
  CLOCKPIN_IN = 4,  // yellow 1
  LATCHPIN_IN = 3,  // green 1
  DATAPIN_IN = 2,   // blue 1
  CLOCKPIN_OUT = 7, // yellow 2
  LATCHPIN_OUT = 6, // green 2
  DATAPIN_OUT = 5   // blue 2
};


// Timeout definitions
// Given BSP_TICKS_PER_SEC = 100:
// Possible are 1 for 10 ms or 100 Hz, 2 for 20 ms or 50 Hz, 3 for 30 ms or 33.3 Hz
enum Constants {
  BSP_TICKS_PER_SEC = 100,          // Number of system clock ticks in one second, e.g. an interrupt every 10 ms
  DKBREADINVERVAL = 10,             // Read control panel every 100 ms
  SERIALRECVINVERVAL = 4,           // Read serial in buffer every 40 ms
  MOTORSENDINTERVAL = 2,            // A move of a motor takes 20 ms. the term step is used in the source code
  PRESETTIMERINTERVAL = 4,          // Discrete step size between the positions is 40 ms
  USERPROGRAMCOUNTERINTERVAL = 100, // Discrete step size between positions is 1000 ms
  MOTORSTARTUPDELAY = 20,           // Wait 200 ms between the initialization of the motors (all at once draws too much current)
  PRESETTIMERINCR = 40              // Increment the preset timer by 40 ms on every PRESETTIMERINTERVAL
};

typedef struct DKbInEvArgs_r1_t {
  DKbInEvArgs_r1_t () : raw(0) {}
  DKbInEvArgs_r1_t (const struct DKbInEvArgs_r1_t& t) : raw(t.raw) {}
  DKbInEvArgs_r1_t (uint32_t rawValue) : raw(rawValue) {}
  union {
    struct {
      uint32_t GAL : 1;
      uint32_t GAT : 1;
      uint32_t GAB : 1;
      uint32_t GAR : 1;
      uint32_t FP7 : 1;
      uint32_t FP6 : 1;
      uint32_t FP5 : 1;
      uint32_t FP8 : 1;
      uint32_t RLB : 1;
      uint32_t RLR : 1;
      uint32_t RLL : 1;
      uint32_t RLT : 1;
      uint32_t RUR : 1;
      uint32_t RUL : 1;
      uint32_t RUT : 1;
      uint32_t RUB : 1;
      uint32_t FP4 : 1;
      uint32_t FP3 : 1;
      uint32_t FP2 : 1;
      uint32_t FP1 : 1;
      uint32_t FPG : 1;
      uint32_t FPS : 1;
      uint32_t FMM : 1;
      uint32_t FPP : 1;
      uint32_t LLB : 1;
      uint32_t LLR : 1;
      uint32_t LLL : 1;
      uint32_t LLT : 1;
      uint32_t LUR : 1;
      uint32_t LUL : 1;
      uint32_t LUT : 1;
      uint32_t LUB : 1;
    };
    uint32_t raw;
  };
} DKbInEvArgs;



#ifdef MOTOROUT
enum ServoNumber {
  LURTN=0,
  LULNG,
  LLRTN,
  LLLNG,
  RLLNG,
  RLRTN,
  RULNG,
  RURTN,
  GALNG,
  GARTN
};

typedef struct MotorEvArgs_t {
  MotorEvArgs_t () : raw(0) {}
  MotorEvArgs_t (const struct MotorEvArgs_t& t) : raw(t.raw) {}
  MotorEvArgs_t (uint16_t rawValue) : raw(rawValue) {}
  MotorEvArgs_t (ServoNumber m, uint8_t pos, uint8_t step)
    : raw((pos << 8) | (step << 4) | m) {}
  union {
    struct {
      uint16_t ServoNum : 4;
      uint16_t StepSize : 4;
      uint16_t Pos   : 8;
    };
    uint16_t raw;
  };
} MotorEvArgs;
#endif

//============================================================================

//============================================================================
// QF_active[] array defines all active object control blocks ----------------
QActiveCB const Q_ROM QF_active[] = {
  { (QActive *)0, (QEvt *)0, 0U}, // SGR: required...
  #ifdef DKBIN
  { (QActive *)&AO_DKbIn, l_DKbInQSto, Q_DIM(l_DKbInQSto) },
  #endif
  #ifdef SERIALIN
  { (QActive *)&AO_SerialIn, l_SerialInQSto, Q_DIM(l_SerialInQSto) },
  #endif
  #ifdef MANUALMOTION
  { (QActive *)&AO_ManualMotion, l_ManualMotionQSto, Q_DIM(l_ManualMotionQSto) },
  #endif
  #ifdef PRESET
  { (QActive *)&AO_PreSet, l_PreSetQSto, Q_DIM(l_PreSetQSto) },
  #endif
  #ifdef USERPROGRAM
  { (QActive *)&AO_UserProgram, l_UserProgramQSto, Q_DIM(l_UserProgramQSto) },
  #endif
  #ifdef DKBOUT
  { (QActive *)&AO_DKbOut, l_DKbOutQSto, Q_DIM(l_DKbOutQSto) },
  #endif
  #ifdef MOTOROUT
  { (QActive *)&AO_MotorsOut, l_MotorsOutQSto, Q_DIM(l_MotorsOutQSto) },
  #endif
};


//............................................................................
void setup() {
  // initialize the QF-nano framework
  QF_init(Q_DIM(QF_active));

  // initialize all AOs...
  #ifdef DKBIN
  QActive_ctor(&AO_DKbIn.super, Q_STATE_CAST(&DKbIn_initial));
  #endif
  #ifdef SERIALIN
  QActive_ctor(&AO_SerialIn.super, Q_STATE_CAST(&SerialIn_initial));
  #endif
  #ifdef MANUALMOTION
  QActive_ctor(&AO_ManualMotion.super, Q_STATE_CAST(&ManualMotion_initial));
  #endif
  #ifdef PRESET
  QActive_ctor(&AO_PreSet.super, Q_STATE_CAST(&PreSet_initial));
  #endif
  #ifdef USERPROGRAM
  QActive_ctor(&AO_UserProgram.super, Q_STATE_CAST(&UserProgram_initial));
  #endif
  #ifdef DKBOUT
  QActive_ctor(&AO_DKbOut.super, Q_STATE_CAST(&DKbOut_initial));
  #endif
  #ifdef MOTOROUT
  QActive_ctor(&AO_MotorsOut.super, Q_STATE_CAST(&MotorsOut_initial));
  #endif

  // initialize the hardware used in this sketch...
  Serial.begin(9600);   // Stanard baud rates: 9600, 38400, 115200 bps
  Serial.print(F("Synced"));
  Serial.print(F("Start, QP-nano: "));
  Serial.println(F(QP_VERSION_STR));

  // Send free memory
  Serial.print(F("|E"));
  Serial.print(freeMemory());
  Serial.print(F("|"));
}

//............................................................................
void loop() {
  QF_run(); // run the QF-nano framework
}

//============================================================================
// interrupts...
ISR(TIMER2_COMPA_vect) {
  QF_tickXISR(0); // process time events for tick rate 0
}

//============================================================================
// QF callbacks...
void QF_onStartup(void) {
  // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking...
  TCCR2A = (1U << WGM21) | (0U << WGM20);
  TCCR2B = (1U << CS22 ) | (1U << CS21) | (1U << CS20); // 1/2^10
  ASSR  &= ~(1U << AS2);
  TIMSK2 = (1U << OCIE2A); // enable TIMER2 compare Interrupt
  TCNT2  = 0U;

  // set the output-compare register based on the desired tick frequency
  OCR2A  = (F_CPU / BSP_TICKS_PER_SEC / 1024U) - 1U;
}
//............................................................................
void QV_onIdle(void) {   // called with interrupts DISABLED
  // Put the CPU and peripherals to the low-power mode. You might
  // need to customize the clock management for your application,
  // see the datasheet for your particular AVR MCU.
  SMCR = (0 << SM0) | (1 << SE); // idle mode, adjust to your project
  QV_CPU_SLEEP();  // atomically go to sleep and enable interrupts
}
//............................................................................
void Q_onAssert(char const Q_ROM * const file, int line) {
  // implement the error-handling policy for your application!!!
  QF_INT_DISABLE(); // disable all interrupts
  QF_RESET();  // reset the CPU
}

//============================================================================
// define all AO classes (state machine)...
#ifdef DKBIN
/*${AOs::DKbIn} ............................................................*/
/*${AOs::DKbIn::shiftIn32} .................................................*/
static uint32_t DKbIn_shiftIn32(DKbIn * const me) {
    uint32_t myDataIn = 0;

    for (int i=31; i>=0; i--)
    {
      digitalWrite(CLOCKPIN_IN, 0);
      delayMicroseconds(2);
      int temp = digitalRead(DATAPIN_IN);
      if (temp) {
        bitSet(myDataIn, i);
        // Debug: Serial.print(i);
      }
      digitalWrite(CLOCKPIN_IN, 1);
    }
    return myDataIn;

}
/*${AOs::DKbIn::isMotorButtonPressed} ......................................*/
static bool DKbIn_isMotorButtonPressed(DKbIn const * const me) {
    const DKbInEvArgs data(me->dataBuffer);

    return data.LUT  != 0 ||
           data.LUR  != 0 ||
           data.LUL  != 0 ||
           data.LLL  != 0 ||
           data.LUB  != 0 ||
           data.LLT  != 0 ||
           data.LLR  != 0 ||
           data.LLB  != 0 ||
           data.RUT  != 0 ||
           data.RUR  != 0 ||
           data.RUL  != 0 ||
           data.RUB  != 0 ||
           data.RLT  != 0 ||
           data.RLL  != 0 ||
           data.RLB  != 0 ||
           data.RLR  != 0 ||
           data.GAT  != 0 ||
           data.GAR  != 0 ||
           data.GAL  != 0 ||
           data.GAB  != 0;
}
/*${AOs::DKbIn::isProgramButtonPressed} ....................................*/
static bool DKbIn_isProgramButtonPressed(DKbIn const * const me) {
    const DKbInEvArgs data(me->dataBuffer);

    return data.FP1  != 0 ||
           data.FP2  != 0 ||
           data.FP3  != 0 ||
           data.FP4  != 0 ||
           data.FP5  != 0 ||
           data.FP6  != 0 ||
           data.FP7  != 0 ||
           data.FP8  != 0;
}
/*${AOs::DKbIn::printDKbInData} ............................................*/
static void DKbIn_printDKbInData(DKbIn * const me) {
    DKbInEvArgs s(me->dataBuffer);

    if (s.FMM) { Serial.println(F("DKbIn: Pressed Function Manual Motion")); }
    if (s.FPS) { Serial.println(F("DKbIn: Pressed Function Pre-Set")); }
    if (s.FPG) { Serial.println(F("DKbIn: Pressed Function User Program")); }
    if (s.FP2) { Serial.println(F("DKbIn: Pressed Function Program 2")); }
    if (s.FP1) { Serial.println(F("DKbIn: Pressed Function Program 1")); }
    if (s.FPP) { Serial.println(F("DKbIn: Pressed Function User Program Play")); }
    if (s.FP3) { Serial.println(F("DKbIn: Pressed Function Program 3")); }
    if (s.FP4) { Serial.println(F("DKbIn: Pressed Function Program 4")); }
    if (s.LUT) { Serial.println(F("DKbIn: Pressed Left Upper Top")); }
    if (s.LUR) { Serial.println(F("DKbIn: Pressed Left Upper Right")); }
    if (s.LUL) { Serial.println(F("DKbIn: Pressed Left Upper Left")); }
    if (s.LLL) { Serial.println(F("DKbIn: Pressed Left Lower Left")); }
    if (s.LUB) { Serial.println(F("DKbIn: Pressed Left Upper Bottom")); }
    if (s.LLT) { Serial.println(F("DKbIn: Pressed Left Lower Top")); }
    if (s.LLR) { Serial.println(F("DKbIn: Pressed Left Lower Right")); }
    if (s.LLB) { Serial.println(F("DKbIn: Pressed Left Lower Bottom")); }
    if (s.RUT) { Serial.println(F("DKbIn: Pressed Right Upper Top")); }
    if (s.RUR) { Serial.println(F("DKbIn: Pressed Right Upper Right")); }
    if (s.RUL) { Serial.println(F("DKbIn: Pressed Right Upper Left")); }
    if (s.RUB) { Serial.println(F("DKbIn: Pressed Right Upper Bottom")); }
    if (s.RLT) { Serial.println(F("DKbIn: Pressed Right Lower Top")); }
    if (s.RLL) { Serial.println(F("DKbIn: Pressed Right Lower Left")); }
    if (s.RLB) { Serial.println(F("DKbIn: Pressed Right Lower Bottom")); }
    if (s.RLR) { Serial.println(F("DKbIn: Pressed Right Lower Right")); }
    if (s.FP8) { Serial.println(F("DKbIn: Pressed Function Program 8")); }
    if (s.GAT) { Serial.println(F("DKbIn: Pressed Gating Top")); }
    if (s.GAR) { Serial.println(F("DKbIn: Pressed Gating Right")); }
    if (s.GAL) { Serial.println(F("DKbIn: Pressed Gating Left")); }
    if (s.FP5) { Serial.println(F("DKbIn: Pressed Function Program 5")); }
    if (s.FP6) { Serial.println(F("DKbIn: Pressed Function Program 6")); }
    if (s.FP7) { Serial.println(F("DKbIn: Pressed Function Program 7")); }
    if (s.GAB) { Serial.println(F("DKbIn: Pressed Gating Bottom")); }
}
/*${AOs::DKbIn::dispatchDKbIn} .............................................*/
static void DKbIn_dispatchDKbIn(DKbIn const * const me) {
    //Debug: DKbIn_printDKbInData(me);

    // Timing less than 0.05 ms

    const DKbInEvArgs data(me->dataBuffer);

    // Do some valitity checks here

    // Raise input event to all active object, even though they do not handle the event
    if (data.FMM) {
      #ifdef MANUALMOTION
      QACTIVE_POST((QMActive *)&AO_ManualMotion, MANUAL_MOTION_PRESSED_SIG, 0L);
      #endif
      #ifdef PRESET
      QACTIVE_POST((QMActive *)&AO_PreSet, MANUAL_MOTION_PRESSED_SIG, 0L);
      #endif
      #ifdef USERPROGRAM
      QACTIVE_POST((QMActive *)&AO_UserProgram, MANUAL_MOTION_PRESSED_SIG, 0L);
      #endif
      #ifdef DKBOUT
      QACTIVE_POST((QMActive *)&AO_DKbOut, MANUAL_MOTION_PRESSED_SIG, 0L);
      #endif
    } else if (data.FPS) {
      #ifdef MANUALMOTION
      QACTIVE_POST((QMActive *)&AO_ManualMotion, PRESET_PRESSED_SIG, 0L);
      #endif
      #ifdef PRESET
      QACTIVE_POST((QMActive *)&AO_PreSet, PRESET_PRESSED_SIG, 0L);
      #endif
      #ifdef USERPROGRAM
      QACTIVE_POST((QMActive *)&AO_UserProgram, PRESET_PRESSED_SIG, 0L);
      #endif
      #ifdef DKBOUT
      QACTIVE_POST((QMActive *)&AO_DKbOut, PRESET_PRESSED_SIG, 0L);
      #endif
    } else if (data.FPG) {
      #ifdef MANUALMOTION
      QACTIVE_POST((QMActive *)&AO_ManualMotion, USERPROGRAM_PRESSED_SIG, 0L);
      #endif
      #ifdef PRESET
      QACTIVE_POST((QMActive *)&AO_PreSet, USERPROGRAM_PRESSED_SIG, 0L);
      #endif
      #ifdef USERPROGRAM
      QACTIVE_POST((QMActive *)&AO_UserProgram, USERPROGRAM_PRESSED_SIG, 0L);
      #endif
      #ifdef DKBOUT
      QACTIVE_POST((QMActive *)&AO_DKbOut, USERPROGRAM_PRESSED_SIG, 0L);
      #endif
    } else if (DKbIn_isMotorButtonPressed(me)) {
      #ifdef MANUALMOTION
      QACTIVE_POST((QMActive *)&AO_ManualMotion, MOTORBUTTON_PRESSED_SIG, me->dataBuffer);
      #endif
      #ifdef PRESET
      QACTIVE_POST((QMActive *)&AO_PreSet, MOTORBUTTON_PRESSED_SIG, me->dataBuffer);
      #endif
      #ifdef USERPROGRAM
      QACTIVE_POST((QMActive *)&AO_UserProgram, MOTORBUTTON_PRESSED_SIG, me->dataBuffer);
      #endif
      #ifdef DKBOUT
      QACTIVE_POST((QMActive *)&AO_DKbOut, MOTORBUTTON_PRESSED_SIG, me->dataBuffer);
      #endif
    } else if (DKbIn_isProgramButtonPressed(me)) {
      #ifdef MANUALMOTION
      QACTIVE_POST((QMActive *)&AO_ManualMotion, PROGRAMBUTTON_PRESSED_SIG, me->dataBuffer);
      #endif
      #ifdef PRESET
      QACTIVE_POST((QMActive *)&AO_PreSet, PROGRAMBUTTON_PRESSED_SIG, me->dataBuffer);
      #endif
      #ifdef USERPROGRAM
      QACTIVE_POST((QMActive *)&AO_UserProgram, PROGRAMBUTTON_PRESSED_SIG, me->dataBuffer);
      #endif
      #ifdef DKBOUT
      QACTIVE_POST((QMActive *)&AO_DKbOut, PROGRAMBUTTON_PRESSED_SIG, me->dataBuffer);
      #endif
    } else if (data.FPP) {
      #ifdef MANUALMOTION
      QACTIVE_POST((QMActive *)&AO_ManualMotion, USERPROGRAM_PLAY_PRESSED_SIG, me->dataBuffer);
      #endif
      #ifdef PRESET
      QACTIVE_POST((QMActive *)&AO_PreSet, USERPROGRAM_PLAY_PRESSED_SIG, me->dataBuffer);
      #endif
      #ifdef USERPROGRAM
      QACTIVE_POST((QMActive *)&AO_UserProgram, USERPROGRAM_PLAY_PRESSED_SIG, me->dataBuffer);
      #endif
      #ifdef DKBOUT
      QACTIVE_POST((QMActive *)&AO_DKbOut, USERPROGRAM_PLAY_PRESSED_SIG, me->dataBuffer);
      #endif
    }
}
/*${AOs::DKbIn::SM} ........................................................*/
static QState DKbIn_initial(DKbIn * const me) {
    /* ${AOs::DKbIn::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      DKBREADINVERVAL,
      DKBREADINVERVAL);

    pinMode(LATCHPIN_IN, OUTPUT);
    pinMode(CLOCKPIN_IN, OUTPUT);
    pinMode(DATAPIN_IN,  INPUT);

    Serial.println(F("DKbIn Initialized"));
    return Q_TRAN(&DKbIn_Read);
}
/*${AOs::DKbIn::SM::Read} ..................................................*/
static QState DKbIn_Read(DKbIn * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::DKbIn::SM::Read::DKBIN_DISPATCH} */
        case DKBIN_DISPATCH_SIG: {
            me->dataBuffer = Q_PAR(me);
            DKbIn_dispatchDKbIn(me);
            status_ = Q_TRAN(&DKbIn_Read);
            break;
        }
        /* ${AOs::DKbIn::SM::Read::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            //me->dataBuffer = 0;

            // Timing 0.5 ms

            digitalWrite(LATCHPIN_IN, 1);
            delayMicroseconds(20);
            digitalWrite(LATCHPIN_IN,0);
            uint32_t dkbin = DKbIn_shiftIn32(me);
            // Debug: Serial.println(dkbin, HEX);

            QACTIVE_POST((QMActive *)&AO_DKbIn, DKBIN_DISPATCH_SIG, dkbin);
            status_ = Q_TRAN(&DKbIn_Read);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

#endif
#ifdef SERIALIN
/*${AOs::SerialIn} .........................................................*/
/*${AOs::SerialIn::processRemainingBytes} ..................................*/
static void SerialIn_processRemainingBytes(SerialIn * const me) {
    while (me->remainingBytes > 1 && Serial.available() > 1) {
      uint8_t tmpLow = Serial.read();
      uint8_t tmpHigh = Serial.read();
      // Debug: Serial.println(tmpLow, HEX); Serial.println(tmpHigh, HEX);
      uint16_t rawData = (tmpHigh << 8) | tmpLow;
      MotorEvArgs motorOut(rawData);
      // Debug:
      // Serial.println(F("Serial motor in"));
      // Serial.print(F("Servo Num: "));
      // Serial.println(motorOut.ServoNum);
      // Serial.print(F("Step Size: "));
      // Serial.println(motorOut.StepSize);
      // Serial.print(F("Servo Position: "));
      // Serial.println(motorOut.Pos);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, motorOut.raw);
      me->remainingBytes -= 2;
    }
}
/*${AOs::SerialIn::SM} .....................................................*/
static QState SerialIn_initial(SerialIn * const me) {
    /* ${AOs::SerialIn::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      SERIALRECVINVERVAL,
      SERIALRECVINVERVAL);

    me->remainingBytes = 0;

    Serial.println(F("SerialIn Initialized"));
    return Q_TRAN(&SerialIn_Receive);
}
/*${AOs::SerialIn::SM::Receive} ............................................*/
static QState SerialIn_Receive(SerialIn * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::SerialIn::SM::Receive} */
        case Q_ENTRY_SIG: {

            // process unfinished command
            if (me->remainingBytes != 0) {
              // Debug: Serial.print("Process unfinished cmd: "); Serial.println(me->remainingBytes);
              SerialIn_processRemainingBytes(me);
            }
            else if (Serial.available() > 0) {
              int serin = Serial.read();
              //Debug: Serial.println(serin, HEX);
              if (serin > -1) {
                if ((serin & 0x7) == 1) {
                  // Command 1: SoftDKb. The same bit is set as from the shift registers of the hardware DKb.
                  #ifdef DKBIN
                  int bitToSet = (serin >> 3);
                  uint32_t dkbIn = 0;
                  bitSet(dkbIn, bitToSet);
                  QACTIVE_POST((QMActive *)&AO_DKbIn, DKBIN_DISPATCH_SIG, dkbIn);
                  #endif
                }
                else if ((serin & 0x7) == 2) {
                  // Command 2: Absolute motion for the motors. Each motor requires 16bit/2 bytes.
                  me->remainingBytes = (serin >> 3);
                  // Debug: Serial.print(F("Num bytes: ")); Serial.println(me->remainingBytes);
                  // It is possible that not all bytes are in the serial-in buffer.
                  SerialIn_processRemainingBytes(me);
                }
                else if ((serin & 0x7) == 3) {
                  // Send free memory
                  Serial.print(F("|E"));
                  // Debug: int* p = new int[10];
                  // if (p == 0) { Serial.print(999); )
                  Serial.print(freeMemory());
                  Serial.print(F("|"));
                }
                else if ((serin & 0x7) == 4) {
                  // Send free memory
                  Serial.print(F("Synced"));
                }
              }
            }

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SerialIn::SM::Receive::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&SerialIn_Receive);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

#endif
#ifdef MANUALMOTION
/*${AOs::ManualMotion} .....................................................*/
/*${AOs::ManualMotion::SM} .................................................*/
static QState ManualMotion_initial(ManualMotion * const me) {
    /* ${AOs::ManualMotion::SM::initial} */
    me->speed = 4;

    Serial.println(F("ManualMotion Initialized"));
    return Q_TRAN(&ManualMotion_ManualMotion);
}
/*${AOs::ManualMotion::SM::ManualMotion} ...................................*/
static QState ManualMotion_ManualMotion(ManualMotion * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::ManualMotion::SM::ManualMotion} */
        case Q_ENTRY_SIG: {
            // Debug: Serial.println(F("ManualMotion: Enter Active"));
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::ManualMotion::SM::ManualMotion::USERPROGRAM_PRESSED} */
        case USERPROGRAM_PRESSED_SIG: {
            status_ = Q_TRAN(&ManualMotion_Idle);
            break;
        }
        /* ${AOs::ManualMotion::SM::ManualMotion::PRESET_PRESSED} */
        case PRESET_PRESSED_SIG: {
            status_ = Q_TRAN(&ManualMotion_Idle);
            break;
        }
        /* ${AOs::ManualMotion::SM::ManualMotion::MOTORBUTTON_PRESSED} */
        case MOTORBUTTON_PRESSED_SIG: {
            #ifdef MOTOROUT
            uint32_t par = Q_PAR(me);
            DKbInEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            uint8_t step = (me->speed / 3) + 1;

            if (data.LUT) {
              // Debug: Serial.println(F("Move left upper lng"));
              MotorEvArgs dm(LULNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LUB) {
              // Debug: Serial.println(F("Move left upper lng"));
              MotorEvArgs dm(LULNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            if (data.LUR) {
              // Debug: Serial.println(F("Move left upper Rtn"));
              MotorEvArgs dm(LURTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LUL) {
              // Debug: Serial.println(F("Move left upper Rtn"));
              MotorEvArgs dm(LURTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.RUT) {
              // Debug: Serial.println(F("Move right upper lng"));
              MotorEvArgs dm(RULNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RUB) {
              // Debug: Serial.println(F("Move right upper lng"));
              MotorEvArgs dm(RULNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            if (data.RUR) {
              // Debug: Serial.println(F("Move right upper Rtn"));
              MotorEvArgs dm(RURTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RUL) {
              // Debug: Serial.println(F("Move right upper Rtn"));
              MotorEvArgs dm(RURTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.LLT) {
              // Debug: Serial.println(F("Move left lower lng"));
              MotorEvArgs dm(LLLNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LLB) {
              // Debug: Serial.println(F("Move left lower lng"));
              MotorEvArgs dm(LLLNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            if (data.LLR) {
              // Debug: Serial.println(F("Move left lower Rtn"));
              MotorEvArgs dm(LLRTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LLL) {
              // Debug: Serial.println(F("Move left lower Rtn"));
              MotorEvArgs dm(LLRTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.RLT) {
              // Debug: Serial.println(F("Move right lower lng"));
              MotorEvArgs dm(RLLNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RLB) {
              // Debug: Serial.println(F("Move right lower lng"));
              MotorEvArgs dm(RLLNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            if (data.RLR) {
              // Debug: Serial.println(F("Move right lower Rtn"));
              MotorEvArgs dm(RLRTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RLL) {
              // Debug: Serial.println(F("Move right lower Rtn"));
              MotorEvArgs dm(RLRTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.GAT) {
              //Serial.println(F("Move Gating lng"));
              MotorEvArgs dm(GALNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.GAB) {
              //Serial.println(F("Move Gating lng"));
              MotorEvArgs dm(GALNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            if (data.GAR) {
              //Serial.println(F("Move Gating Rtn"));
              MotorEvArgs dm(GARTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.GAL) {
              //Serial.println(F("Move Gating Rtn"));
              MotorEvArgs dm(GARTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            #endif
            status_ = Q_TRAN(&ManualMotion_ManualMotion);
            break;
        }
        /* ${AOs::ManualMotion::SM::ManualMotion::PROGRAMBUTTON_PRESSED} */
        case PROGRAMBUTTON_PRESSED_SIG: {
            #ifdef MOTOROUT
            Serial.println(F("Change speed"));

            uint32_t par = Q_PAR(me);
            DKbInEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            if      (data.FP1) { me->speed = 1; }
            else if (data.FP2) { me->speed = 2; }
            else if (data.FP3) { me->speed = 3; }
            else if (data.FP4) { me->speed = 4; }
            else if (data.FP5) { me->speed = 5; }
            else if (data.FP6) { me->speed = 6; }
            else if (data.FP7) { me->speed = 7; }
            else if (data.FP8) { me->speed = 8; }

            #endif
            status_ = Q_TRAN(&ManualMotion_ManualMotion);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::ManualMotion::SM::Idle} ...........................................*/
static QState ManualMotion_Idle(ManualMotion * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::ManualMotion::SM::Idle} */
        case Q_ENTRY_SIG: {
            Serial.println("ManualMotion: Enter Idle");
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::ManualMotion::SM::Idle::MANUAL_MOTION_PRESSED} */
        case MANUAL_MOTION_PRESSED_SIG: {
            status_ = Q_TRAN(&ManualMotion_ManualMotion);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

#endif
#ifdef PRESET
/*${AOs::PreSet} ...........................................................*/
/*${AOs::PreSet::isCurrentPreSet} ..........................................*/
static bool PreSet_isCurrentPreSet(PreSet * const me) {
    uint32_t par = Q_PAR(me);
    DKbInEvArgs data(par);

    if      (data.FP1 && me->currentPreSet == 1) return true;
    else if (data.FP2 && me->currentPreSet == 2) return true;
    else if (data.FP3 && me->currentPreSet == 3) return true;
    else if (data.FP4 && me->currentPreSet == 4) return true;
    else if (data.FP5 && me->currentPreSet == 5) return true;
    else if (data.FP6 && me->currentPreSet == 6) return true;
    else if (data.FP7 && me->currentPreSet == 7) return true;
    else if (data.FP8 && me->currentPreSet == 8) return true;
    else return false;

}
/*${AOs::PreSet::prog3} ....................................................*/
static void PreSet_prog3(PreSet * const me) {
    // Marker Position 1 <-> 2

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 147, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 147, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 122, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 122, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 107, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 132, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 132, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 107, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, 0, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {
      static const uint8_t PROGMEM STEPSZ = 10;
      float targetDeltaSmall = 10 * sin((me->preSetTimer - 3000) / 3000.0 * PI);
      float targetDeltaLarge = 40 * sin((me->preSetTimer - 3000) / 3000.0 * PI);

      MotorEvArgs lulng(LULNG, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
    }

    if (me->preSetTimer == 8960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}
/*${AOs::PreSet::prog1} ....................................................*/
static void PreSet_prog1(PreSet * const me) {
    // Marker Position 1

    static const uint8_t PROGMEM STEPSZ = 2;
    if (me->preSetTimer == 0) {
      MotorEvArgs lulng(LULNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, 0, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer == 3000) {
      MotorEvArgs lulng(LULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
    }

    if (me->preSetTimer <= 3000) {
      me->preSetTimer += PRESETTIMERINCR;
    }

}
/*${AOs::PreSet::prog2} ....................................................*/
static void PreSet_prog2(PreSet * const me) {
    // Marker Position 2

    static const uint8_t PROGMEM STEPSZ = 2;
    if (me->preSetTimer == 0) {
      MotorEvArgs lulng(LULNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 70, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 70, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, 0, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer == 3000) {
      MotorEvArgs lulng(LULNG, 167, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 167, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 117, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 117, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 87, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 137, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 137, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 87, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
    }

    if (me->preSetTimer <= 3000) {
      me->preSetTimer += PRESETTIMERINCR;
    }

}
/*${AOs::PreSet::prog4} ....................................................*/
static void PreSet_prog4(PreSet * const me) {
    // Free-breath Gating

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
      MotorEvArgs galng(GALNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {
      static const uint8_t PROGMEM STEPSZ = 10;
      float target = 127 + 80 * sin((me->preSetTimer - 3000) / 2500.0 * PI);

      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (me->preSetTimer == 7960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}
/*${AOs::PreSet::prog5} ....................................................*/
static void PreSet_prog5(PreSet * const me) {
    // Breath-hold Gating

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
      MotorEvArgs galng(GALNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000 && me->preSetTimer < 28000) {
      static const uint8_t PROGMEM STEPSZ = 10;
      float target = 60 + 50 * sin((me->preSetTimer - 3000) / 2500.0 * PI);

      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }
    else if (me->preSetTimer == 28000) {
      static const uint8_t PROGMEM STEPSZ = 4;
      MotorEvArgs lulng(LULNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }
    else if (me->preSetTimer > 28000 && me->preSetTimer < 38000) {
      static const uint8_t PROGMEM STEPSZ = 10;
      float target = 200 + 50 * cos((me->preSetTimer - 28000) / 40000.0 * PI);
      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }
    else if (me->preSetTimer == 38000) {
      static const uint8_t PROGMEM STEPSZ = 4;
      MotorEvArgs lulng(LULNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (me->preSetTimer == 40000) {
      me->preSetTimer = 6720;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}
/*${AOs::PreSet::prog6} ....................................................*/
static void PreSet_prog6(PreSet * const me) {
    // Free-breath Gating, Marker Position 1 <-> 2

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 147, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 147, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 122, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 122, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 107, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 132, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 132, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 107, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {

      static const uint8_t PROGMEM STEPSZ = 10;
      float targetDeltaSmall = 10 * sin((me->preSetTimer - 3000) / 3000.0 * PI);
      float targetDeltaLarge = 40 * sin((me->preSetTimer - 3000) / 3000.0 * PI);
      float targetGating = 127 + 80 * sin((me->preSetTimer - 3000) / 3000.0 * PI);

      MotorEvArgs lulng(LULNG, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, targetGating, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (me->preSetTimer == 8960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}
/*${AOs::PreSet::prog7} ....................................................*/
static void PreSet_prog7(PreSet * const me) {
    // Free-breath Gating loosing signal

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
      MotorEvArgs galng(GALNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {
      static const uint8_t PROGMEM STEPSZ = 10;
      float target = 127 + 80 * sin((me->preSetTimer - 3000) / 2500.0 * PI);

      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (me->preSetTimer == 25000) {
      static const uint8_t PROGMEM STEPSZ = 3;

      MotorEvArgs gartn(GARTN, 255, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer == 35000) {
      static const uint8_t PROGMEM STEPSZ = 3;

      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }

    if (me->preSetTimer == 37960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}
/*${AOs::PreSet::prog8} ....................................................*/
static void PreSet_prog8(PreSet * const me) {
    // Free-breath Gating base line shift

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
      MotorEvArgs galng(GALNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {
      static const uint8_t PROGMEM STEPSZ = 10;
      float baseline = 130 + 30 * sin((me->preSetTimer - 3000) / 30000.0 * PI);
      float target = baseline + 50 * sin((me->preSetTimer - 3000) / 3000.0 * PI);

      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (me->preSetTimer == 62960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}
/*${AOs::PreSet::SM} .......................................................*/
static QState PreSet_initial(PreSet * const me) {
    /* ${AOs::PreSet::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      PRESETTIMERINTERVAL,
      PRESETTIMERINTERVAL);

    Serial.println(F("PreSet Initialized"));
    return Q_TRAN(&PreSet_Idle);
}
/*${AOs::PreSet::SM::Idle} .................................................*/
static QState PreSet_Idle(PreSet * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::PreSet::SM::Idle} */
        case Q_ENTRY_SIG: {
            Serial.println("PreSet: Enter Idle");
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::PreSet::SM::Idle::PRESET_PRESSED} */
        case PRESET_PRESSED_SIG: {
            status_ = Q_TRAN(&PreSet_WaitForProgram);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::PreSet::SM::WaitForProgram} .......................................*/
static QState PreSet_WaitForProgram(PreSet * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::PreSet::SM::WaitForProgram} */
        case Q_ENTRY_SIG: {
            Serial.println(F("PreSet: Enter WaitForProgram"));

            me->preSetTimer = 0;
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::PreSet::SM::WaitForProgram::MANUAL_MOTION_PRESSED} */
        case MANUAL_MOTION_PRESSED_SIG: {
            status_ = Q_TRAN(&PreSet_Idle);
            break;
        }
        /* ${AOs::PreSet::SM::WaitForProgram::USERPROGRAM_PRESSED} */
        case USERPROGRAM_PRESSED_SIG: {
            status_ = Q_TRAN(&PreSet_Idle);
            break;
        }
        /* ${AOs::PreSet::SM::WaitForProgram::PROGRAMBUTTON_PRESSED} */
        case PROGRAMBUTTON_PRESSED_SIG: {
            uint32_t par = Q_PAR(me);
            DKbInEvArgs data(par);

            if      (data.FP1) { me->currentPreSet = 1; }
            else if (data.FP2) { me->currentPreSet = 2; }
            else if (data.FP3) { me->currentPreSet = 3; }
            else if (data.FP4) { me->currentPreSet = 4; }
            else if (data.FP5) { me->currentPreSet = 5; }
            else if (data.FP6) { me->currentPreSet = 6; }
            else if (data.FP7) { me->currentPreSet = 7; }
            else if (data.FP8) { me->currentPreSet = 8; }

            me->preSetTimer = 0;
            status_ = Q_TRAN(&PreSet_RunProgram);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::PreSet::SM::RunProgram} ...........................................*/
static QState PreSet_RunProgram(PreSet * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::PreSet::SM::RunProgram} */
        case Q_ENTRY_SIG: {
            // Debug: Serial.println(F("PreSet: Enter RunProgram"));

            // Debug:
            //Serial.print(me->currentPreSet);
            //Serial.print(" ");
            //Serial.println(me->preSetCounter);

            #ifdef MOTOROUT
            if (me->currentPreSet == 1) {
              PreSet_prog1(me);
            }
            else if (me->currentPreSet == 2) {
              PreSet_prog2(me);
            }
            else if (me->currentPreSet == 3) {
              PreSet_prog3(me);
            }
            else if (me->currentPreSet == 4) {
              PreSet_prog4(me);
            }
            else if (me->currentPreSet == 5) {
              PreSet_prog5(me);
            }
            else if (me->currentPreSet == 6) {
              PreSet_prog6(me);
            }
            else if (me->currentPreSet == 7) {
              PreSet_prog7(me);
            }
            else if (me->currentPreSet == 8) {
              PreSet_prog8(me);
            }
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::PreSet::SM::RunProgram::USERPROGRAM_PRESSED} */
        case USERPROGRAM_PRESSED_SIG: {
            status_ = Q_TRAN(&PreSet_Idle);
            break;
        }
        /* ${AOs::PreSet::SM::RunProgram::PROGRAMBUTTON_PRESSED} */
        case PROGRAMBUTTON_PRESSED_SIG: {
            /* ${AOs::PreSet::SM::RunProgram::PROGRAMBUTTON_PR~::[currentPreSet]} */
            if (PreSet_isCurrentPreSet(me)) {
                status_ = Q_TRAN(&PreSet_RunProgram);
            }
            /* ${AOs::PreSet::SM::RunProgram::PROGRAMBUTTON_PR~::[else]} */
            else {
                status_ = Q_TRAN(&PreSet_WaitForProgram);
            }
            break;
        }
        /* ${AOs::PreSet::SM::RunProgram::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&PreSet_RunProgram);
            break;
        }
        /* ${AOs::PreSet::SM::RunProgram::PRESET_PRESSED} */
        case PRESET_PRESSED_SIG: {
            status_ = Q_TRAN(&PreSet_WaitForProgram);
            break;
        }
        /* ${AOs::PreSet::SM::RunProgram::MANUAL_MOTION_PRESSED} */
        case MANUAL_MOTION_PRESSED_SIG: {
            status_ = Q_TRAN(&PreSet_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

#endif
#ifdef USERPROGRAM
/*${AOs::UserProgram} ......................................................*/
/*${AOs::UserProgram::SM} ..................................................*/
static QState UserProgram_initial(UserProgram * const me) {
    /* ${AOs::UserProgram::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      USERPROGRAMCOUNTERINTERVAL,
      USERPROGRAMCOUNTERINTERVAL);

    Serial.println(F("UserProgram Initialized"));
    return Q_TRAN(&UserProgram_Idle);
}
/*${AOs::UserProgram::SM::Idle} ............................................*/
static QState UserProgram_Idle(UserProgram * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::UserProgram::SM::Idle} */
        case Q_ENTRY_SIG: {
            Serial.println(F("UserProgram: Enter Idle"));
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::UserProgram::SM::Idle::USERPROGRAM_PRESSED} */
        case USERPROGRAM_PRESSED_SIG: {
            memset(me->userProgram, 0, sizeof(me->userProgram));
            status_ = Q_TRAN(&UserProgram_Record);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::UserProgram::SM::Record} ..........................................*/
static QState UserProgram_Record(UserProgram * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::UserProgram::SM::Record} */
        case Q_ENTRY_SIG: {
            Serial.println(F("UserProgram: Enter Record"));
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::UserProgram::SM::Record::MANUAL_MOTION_PRESSED} */
        case MANUAL_MOTION_PRESSED_SIG: {
            status_ = Q_TRAN(&UserProgram_Idle);
            break;
        }
        /* ${AOs::UserProgram::SM::Record::USERPROGRAM_PLAY_PRESSED} */
        case USERPROGRAM_PLAY_PRESSED_SIG: {
            me->userProgramCounter = 0;
            status_ = Q_TRAN(&UserProgram_Play);
            break;
        }
        /* ${AOs::UserProgram::SM::Record::MOTORBUTTON_PRESSED} */
        case MOTORBUTTON_PRESSED_SIG: {
            #ifdef MOTOROUT
            uint32_t par = Q_PAR(me);
            DKbInEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            const uint8_t SPEED = 6;
            const uint8_t STEP = 2;

            if (data.LUT) {
              Serial.println(F("Move left upper lng"));
              MotorEvArgs dm(LULNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LUB) {
              Serial.println(F("Move left upper lng"));
              MotorEvArgs dm(LULNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            else if (data.LUR) {
              Serial.println(F("Move left upper Rtn"));
              MotorEvArgs dm(LURTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LUL) {
              Serial.println(F("Move left upper Rtn"));
              MotorEvArgs dm(LURTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.RUT) {
              Serial.println(F("Move right upper lng"));
              MotorEvArgs dm(RULNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RUB) {
              Serial.println(F("Move right upper lng"));
              MotorEvArgs dm(RULNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            else if (data.RUR) {
              Serial.println(F("Move right upper Rtn"));
              MotorEvArgs dm(RURTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RUL) {
              Serial.println(F("Move right upper Rtn"));
              MotorEvArgs dm(RURTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.LLT) {
              Serial.println(F("Move left lower lng"));
              MotorEvArgs dm(LLLNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LLB) {
              Serial.println(F("Move left lower lng"));
              MotorEvArgs dm(LLLNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            else if (data.LLR) {
              Serial.println(F("Move left lower Rtn"));
              MotorEvArgs dm(LLRTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LLL) {
              Serial.println(F("Move left lower Rtn"));
              MotorEvArgs dm(LLRTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.RLT) {
              Serial.println(F("Move right lower lng"));
              MotorEvArgs dm(RLLNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RLB) {
              Serial.println(F("Move right lower lng"));
              MotorEvArgs dm(RLLNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            else if (data.RLR) {
              Serial.println(F("Move right lower Rtn"));
              MotorEvArgs dm(RLRTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RLL) {
              Serial.println(F("Move right lower Rtn"));
              MotorEvArgs dm(RLRTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.GAT) {
              Serial.println(F("Move Gating lng"));
              MotorEvArgs dm(GALNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.GAB) {
              Serial.println(F("Move Gating lng"));
              MotorEvArgs dm(GALNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            else if (data.GAR) {
              Serial.println(F("Move Gating Rtn"));
              MotorEvArgs dm(GARTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.GAL) {
              Serial.println(F("Move Gating Rtn"));
              MotorEvArgs dm(GARTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            #endif
            status_ = Q_TRAN(&UserProgram_Record);
            break;
        }
        /* ${AOs::UserProgram::SM::Record::PROGRAMBUTTON_PRESSED} */
        case PROGRAMBUTTON_PRESSED_SIG: {
            #ifdef MOTOROUT
            uint32_t par = Q_PAR(me);
            DKbInEvArgs data(par);

            uint8_t selection = 0;
            if (data.FP1) { selection = 0; }
            else if (data.FP2) { selection = 1; }
            else if (data.FP3) { selection = 2; }
            else if (data.FP4) { selection = 3; }
            else if (data.FP5) { selection = 4; }
            else if (data.FP6) { selection = 5; }
            else if (data.FP7) { selection = 6; }
            else if (data.FP8) { selection = 7; }


            Serial.print(F("Programmed positions at second: "));
            Serial.println(selection);

            me->userProgram[0][selection] = AO_MotorsOut.servoPosition[0];
            me->userProgram[1][selection] = AO_MotorsOut.servoPosition[1];
            me->userProgram[2][selection] = AO_MotorsOut.servoPosition[2];
            me->userProgram[3][selection] = AO_MotorsOut.servoPosition[3];
            me->userProgram[4][selection] = AO_MotorsOut.servoPosition[4];
            me->userProgram[5][selection] = AO_MotorsOut.servoPosition[5];
            me->userProgram[6][selection] = AO_MotorsOut.servoPosition[6];
            me->userProgram[7][selection] = AO_MotorsOut.servoPosition[7];
            me->userProgram[8][selection] = AO_MotorsOut.servoPosition[8];
            me->userProgram[9][selection] = AO_MotorsOut.servoPosition[9];
            #endif
            status_ = Q_TRAN(&UserProgram_Record);
            break;
        }
        /* ${AOs::UserProgram::SM::Record::PRESET_PRESSED} */
        case PRESET_PRESSED_SIG: {
            status_ = Q_TRAN(&UserProgram_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::UserProgram::SM::Play} ............................................*/
static QState UserProgram_Play(UserProgram * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::UserProgram::SM::Play} */
        case Q_ENTRY_SIG: {
            Serial.println(F("UserProgram: Enter Play"));

            #ifdef MOTOROUT

            for (int motor=0; motor < NUMSERVOS; motor++) {
              MotorEvArgs lulng(ServoNumber(motor), me->userProgram[motor][me->userProgramCounter], 2);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
            }

            me->userProgramCounter++;
            if (me->userProgramCounter >=8) { me->userProgramCounter = 0; }


            #endif
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::UserProgram::SM::Play::USERPROGRAM_PRESSED} */
        case USERPROGRAM_PRESSED_SIG: {
            status_ = Q_TRAN(&UserProgram_Record);
            break;
        }
        /* ${AOs::UserProgram::SM::Play::MANUAL_MOTION_PRESSED} */
        case MANUAL_MOTION_PRESSED_SIG: {
            status_ = Q_TRAN(&UserProgram_Idle);
            break;
        }
        /* ${AOs::UserProgram::SM::Play::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&UserProgram_Play);
            break;
        }
        /* ${AOs::UserProgram::SM::Play::PRESET_PRESSED} */
        case PRESET_PRESSED_SIG: {
            status_ = Q_TRAN(&UserProgram_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

#endif
#ifdef DKBOUT
/*${AOs::DKbOut} ...........................................................*/
/*${AOs::DKbOut::SM} .......................................................*/
static QState DKbOut_initial(DKbOut * const me) {
    /* ${AOs::DKbOut::SM::initial} */
    pinMode(CLOCKPIN_OUT, OUTPUT);
    pinMode(LATCHPIN_OUT, OUTPUT);
    pinMode(DATAPIN_OUT,  OUTPUT);

    Serial.println(F("DKbOut Initialized"));
    return Q_TRAN(&DKbOut_ManualMotionLED);
}
/*${AOs::DKbOut::SM::ManualMotionLED} ......................................*/
static QState DKbOut_ManualMotionLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::DKbOut::SM::ManualMotionLED} */
        case Q_ENTRY_SIG: {
            Serial.println(F("DKbOut: Enter ManualMotionLED |A|"));

            byte whichPin = 1; // DKb r0: 5;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::DKbOut::SM::ManualMotionLED::PRESET_PRESSED} */
        case PRESET_PRESSED_SIG: {
            status_ = Q_TRAN(&DKbOut_PreSetLED);
            break;
        }
        /* ${AOs::DKbOut::SM::ManualMotionLED::USERPROGRAM_PRESSED} */
        case USERPROGRAM_PRESSED_SIG: {
            status_ = Q_TRAN(&DKbOut_UserProgramRecordLED);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::PreSetLED} ............................................*/
static QState DKbOut_PreSetLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::DKbOut::SM::PreSetLED} */
        case Q_ENTRY_SIG: {
            Serial.println(F("DKbOut: Enter PreSetLED |B|"));

            byte whichPin = 0; // DKb r0: 4;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::DKbOut::SM::PreSetLED::MANUAL_MOTION_PRESSED} */
        case MANUAL_MOTION_PRESSED_SIG: {
            status_ = Q_TRAN(&DKbOut_ManualMotionLED);
            break;
        }
        /* ${AOs::DKbOut::SM::PreSetLED::USERPROGRAM_PRESSED} */
        case USERPROGRAM_PRESSED_SIG: {
            status_ = Q_TRAN(&DKbOut_UserProgramRecordLED);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::UserProgramRecordLED} .................................*/
static QState DKbOut_UserProgramRecordLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::DKbOut::SM::UserProgramRecordLED} */
        case Q_ENTRY_SIG: {
            Serial.println(F("DKbOut: Enter UserProgramRecordLED |C|"));

            byte whichPin = 3; // DKb r0: 2;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::DKbOut::SM::UserProgramRecor~::MANUAL_MOTION_PRESSED} */
        case MANUAL_MOTION_PRESSED_SIG: {
            status_ = Q_TRAN(&DKbOut_ManualMotionLED);
            break;
        }
        /* ${AOs::DKbOut::SM::UserProgramRecor~::PRESET_PRESSED} */
        case PRESET_PRESSED_SIG: {
            status_ = Q_TRAN(&DKbOut_PreSetLED);
            break;
        }
        /* ${AOs::DKbOut::SM::UserProgramRecor~::USERPROGRAM_PLAY_PRESSED} */
        case USERPROGRAM_PLAY_PRESSED_SIG: {
            status_ = Q_TRAN(&DKbOut_UserProgramPlayLED);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::UserProgramPlayLED} ...................................*/
static QState DKbOut_UserProgramPlayLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::DKbOut::SM::UserProgramPlayLED} */
        case Q_ENTRY_SIG: {
            Serial.println(F("DKbOut: Enter UserProgramPlayLED |D|"));

            byte whichPin = 2; // DKb r0: 3;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::DKbOut::SM::UserProgramPlayL~::MANUAL_MOTION_PRESSED} */
        case MANUAL_MOTION_PRESSED_SIG: {
            status_ = Q_TRAN(&DKbOut_ManualMotionLED);
            break;
        }
        /* ${AOs::DKbOut::SM::UserProgramPlayL~::PRESET_PRESSED} */
        case PRESET_PRESSED_SIG: {
            status_ = Q_TRAN(&DKbOut_PreSetLED);
            break;
        }
        /* ${AOs::DKbOut::SM::UserProgramPlayL~::USERPROGRAM_PRESSED} */
        case USERPROGRAM_PRESSED_SIG: {
            status_ = Q_TRAN(&DKbOut_UserProgramRecordLED);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

#endif
#ifdef MOTOROUT
/*${AOs::MotorsOut} ........................................................*/
/*${AOs::MotorsOut::isInitialized} .........................................*/
static bool MotorsOut_isInitialized(MotorsOut * const me) {
    return me->initializeCounter == NUMSERVOS;
}
/*${AOs::MotorsOut::SM} ....................................................*/
static QState MotorsOut_initial(MotorsOut * const me) {
    /* ${AOs::MotorsOut::SM::initial} */
    // Give the capacitor time to load
    QActive_armX((QActive *)me, 0U,
      MOTORSTARTUPDELAY*5,
      MOTORSTARTUPDELAY*5);

    servoLib.begin();
    me->initializeCounter = 0;

    Serial.println(F("MotorOut Initialized"));
    return Q_TRAN(&MotorsOut_Wait);
}

// Timings:
// servoLib.write for 16 motors takes 9 ms
// Serial print takes 0.2 ms
// Meassured with the oscilloscope and digitalWrite(HIGH/LOW)
/*${AOs::MotorsOut::SM::Active} ............................................*/
static QState MotorsOut_Active(MotorsOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::MotorsOut::SM::Active} */
        case Q_ENTRY_SIG: {
            //Serial.println(F("MotorsOut: Enter Active"));
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::MotorsOut::SM::Active::MOTOR_STEP_FORWARD} */
        case MOTOR_STEP_FORWARD_SIG: {
            uint32_t par = Q_PAR(me);
            MotorEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            me->stepSize[data.ServoNum] = data.StepSize;
            int pos = me->servoPosition[data.ServoNum] + data.Pos;
            if (pos < 0) { pos = 0; }
            else if (pos > 255) { pos = 255; }

            me->target[data.ServoNum] = pos;
            status_ = Q_TRAN(&MotorsOut_Active);
            break;
        }
        /* ${AOs::MotorsOut::SM::Active::MOTOR_STEP_BACKWARD} */
        case MOTOR_STEP_BACKWARD_SIG: {
            uint32_t par = Q_PAR(me);
            MotorEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            me->stepSize[data.ServoNum] = data.StepSize;
            // Debug: Serial.println(data.StepSize);
            int pos = me->servoPosition[data.ServoNum] - data.Pos;
            if (pos < 0) { pos = 0; }
            else if (pos > 255) { pos = 255; }

            me->target[data.ServoNum] = pos;
            status_ = Q_TRAN(&MotorsOut_Active);
            break;
        }
        /* ${AOs::MotorsOut::SM::Active::MOTOR_MOVE_ASOLUTE} */
        case MOTOR_MOVE_ASOLUTE_SIG: {
            uint32_t par = Q_PAR(me);
            MotorEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            me->stepSize[data.ServoNum] = data.StepSize;
            if (data.Pos >= 0 && data.Pos <= 255) {
              me->target[data.ServoNum] = data.Pos;
            } else {
              me->target[data.ServoNum] = me->servoPosition[data.ServoNum];
            }
            status_ = Q_TRAN(&MotorsOut_Active);
            break;
        }
        /* ${AOs::MotorsOut::SM::Active::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {

            #ifdef SERIALIN
            bool isMoving = false;
            #endif

            for (int n=0; n < NUMSERVOS; n++) {

              int newPos = me->servoPosition[n];
              if (me->servoPosition[n] < me->target[n]) {
                newPos = min(me->servoPosition[n]+me->stepSize[n], me->target[n]);
              }
              if (me->target[n] < me->servoPosition[n]) {
                newPos = max(me->servoPosition[n]-me->stepSize[n], me->target[n]);
              }
              if (newPos != me->servoPosition[n]) {
                me->servoPosition[n] = newPos;
                #ifdef SERIALIN
                isMoving = true;
                #endif
                servoLib.write(n, me->servoPosition[n]);
              }
            }

            #ifdef SERIALIN
            if (!isMoving) {
              if (me->_sendPositionCounter % 10  == 0) {
                int servo = (me->_sendPositionCounter / 10) - 1;
                Serial.print("|");
                Serial.print(servo);
                Serial.print(me->servoPosition[servo]);
                Serial.print("|");
                if (me->_sendPositionCounter == 100) me->_sendPositionCounter = 0;
              }
              me->_sendPositionCounter++;
            }
            #endif
            status_ = Q_TRAN(&MotorsOut_Active);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::MotorsOut::SM::Wait} ..............................................*/
static QState MotorsOut_Wait(MotorsOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::MotorsOut::SM::Wait::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            QActive_armX((QActive *)me, 0U,
              MOTORSTARTUPDELAY,
              MOTORSTARTUPDELAY);
            /* ${AOs::MotorsOut::SM::Wait::Q_TIMEOUT::[isinitialized]} */
            if (MotorsOut_isInitialized(me)) {
                QActive_armX((QActive *)me, 0U,
                  MOTORSENDINTERVAL,
                  MOTORSENDINTERVAL);

                Serial.println(F("MotorsOut: Enter Active"));
                status_ = Q_TRAN(&MotorsOut_Active);
            }
            /* ${AOs::MotorsOut::SM::Wait::Q_TIMEOUT::[else]} */
            else {
                // Debug: Serial.print("Initialize: "); Serial.println(me->initializeCounter);

                servoLib.write(me->initializeCounter, 127);
                me->servoPosition[me->initializeCounter] = 127;
                me->target[me->initializeCounter] = 127;
                me->stepSize[me->initializeCounter] = 1;

                me->initializeCounter++;
                status_ = Q_TRAN(&MotorsOut_Wait);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

#endif

