/*$file${.::gris5A.ino} ####################################################*/
/*
* Model: gris5A.qm
* File:  ${.::gris5A.ino}
*
* This code has been generated by QM 4.4.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${.::gris5A.ino} #################################################*/
/* gris5A.qm - Arduino software for the GRIS5A (C) motion phantom
 * Copyright (C) 2018-2019 by Stefan Grimm
 */

#include "qpn.h"
#include "Arduino.h"

#define GRIS5A 1
//#define NO2 1

#define DKBIN
#define DKBOUT
#define SERIALIN
#define MOTOROUT

#ifdef GRIS5A
#define NUMSERVOS 10
#elif NO2
#define NUMSERVOS 6
#endif

#define Q_PARAM_SIZE 4

#include "FreeMemory.h"
#include "dkb.h"
#include "preset.h"
#include "events.h"
#include "constants.h"

#ifdef MOTOROUT
#include "_Adafruit_PWMServoDriver.h"
#include "prfServo2.h"

class ServoShieldPCA9685Linear : public prfServo2ImplBase<uint16_t, float> {
  public:
  ServoShieldPCA9685Linear(Adafruit_PWMServoDriver& pwm) : _pwm(pwm) {
    Calibration = false;
  }

  bool Calibration;

  void begin() {
    _pwm.begin();
    _pwm.setPWMFreq(60);
    // Set pwm signal to off.
    // The servo shield does not like signal when it is powered. 1.5 Amperes are flowing.
    // setPWMOn() has interestingly the same effect.
    _pwm.setPWMOff();
  }

  void get(float** params, float** offsets) const {
    #ifdef GRIS5A
    if (!Calibration) {
    // LURTN
    params[0][0] = 1.2942268654268088e+002;
    params[0][1] = 1.6668375402407262e+000;
    offsets[0][0] = 0;
    // LULNG
    params[1][0] = 5.5452380952380930e+002;
    params[1][1] = -2.6484593837534930e+000;
    params[1][2] = 1.1929477673422232e-002;
    params[1][3] = -2.7138883234954693e-005;
    offsets[1][0] = 0;
    // LLRTN
    params[2][0] = 1.5442914556378040e+002;
    params[2][1] = 1.5882527835305206e+000;
    offsets[2][0] = 0;
    // LLLNG
    params[3][0] = 1.3666666666666668e+002;
    params[3][1] = 2.8253968253968250e+000;
    params[3][2] = -1.3016971494480146e-002;
    params[3][3] = 3.0757400999615536e-005;
    offsets[3][0] = 0;
    // RLLNG
    params[4][0] = 5.7880952380952260e+002;
    params[4][1] = -2.3641456582632174e+000;
    params[4][2] = 9.3590377327392710e-003;
    params[4][3] = -2.1711106587961670e-005;
    offsets[4][0] = 0;
    // RLRTN
    params[5][0] = 1.3774938998134064e+002;
    params[5][1] = 1.5490885603559636e+000;
    offsets[5][0] = 0;
    // RULNG
    params[6][0] = 1.8559523809523685e+002;
    params[6][1] = 2.1031746031746907e+000;
    params[6][2] = -7.4147305981224840e-003;
    params[6][3] = 1.8092588823305492e-005;
    offsets[6][0] = 0;
    // RURTN
    params[7][0] = 1.6024944124341286e+002;
    params[7][1] = 1.6079886813344540e+000;
    offsets[7][0] = 0;
    // GALNG
    params[8][0] = 5.3464285714285590e+002;
    params[8][1] = -2.8109243697478114e+000;
    params[8][2] = 1.3346515076618000e-002;
    params[8][3] = -3.2566659881943620e-005;
    offsets[8][0] = 0;
    // GARTN
    params[9][0] = 1.4526246180975622e+002;
    params[9][1] = 1.5686194098710244e+000;
    offsets[9][0] = 0;
    }
    else {
    // LURTN
    params[0][0] = 100;
    params[0][1] = 2;
    offsets[0][0] = 0;
    // LULNG
    params[1][0] = 100;
    params[1][1] = 2;
    params[1][2] = 0;
    params[1][3] = 0;
    offsets[1][0] = 0;
    // LLRTN
    params[2][0] = 100;
    params[2][1] = 2;
    offsets[2][0] = 0;
    // LLLNG
    params[3][0] = 100;
    params[3][1] = 2;
    params[3][2] = 0;
    params[3][3] = 0;
    offsets[3][0] = 0;
    // RLLNG
    params[4][0] = 100;
    params[4][1] = 2;
    params[4][2] = 0;
    params[4][3] = 0;
    offsets[4][0] = 0;
    // RLRTN
    params[5][0] = 100;
    params[5][1] = 2;
    offsets[5][0] = 0;
    // RULNG
    params[6][0] = 100;
    params[6][1] = 2;
    params[6][2] = 0;
    params[6][3] = 0;
    offsets[6][0] = 0;
    // RURTN
    params[7][0] = 100;
    params[7][1] = 2;
    offsets[7][0] = 0;
    // GALNG
    params[8][0] = 100;
    params[8][1] = 2;
    params[8][2] = 0;
    params[8][3] = 0;
    offsets[8][0] = 0;
    // GARTN
    params[9][0] = 100;
    params[9][1] = 2;
    offsets[9][0] = 0;
    }
    #elif NO2
    if (!Calibration) {
    // LLLNG
    params[0][0] = 5.3400000000000000e+002;
    params[0][1] = -1.5833333333333320e+000;
    params[0][2] = 3.6621093749999844e-003;
    params[0][3] = -6.3578287760416260e-006;
    offsets[0][0] = -1.3322676295501878e-015;
    offsets[0][1] = 7.8125000000000080e-002;
    offsets[0][2] = -2.4414062500000030e-004;
    // RLLNG
    params[1][0] = 2.3420000000000002e+002;
    params[1][1] = 1.5338541666666618e+000;
    params[1][2] = -3.6621093749999460e-003;
    params[1][3] = 6.9936116536456924e-006;
    offsets[1][0] = -4.0000000000000000e+000;
    offsets[1][1] = 1.5625000000000000e-002;
    // GALNG
    params[2][0] = 1.8751428571428568e+002;
    params[2][1] = 2.1677827380952457e+000;
    params[2][2] = -6.6266741071429420e-003;
    params[2][3] = 1.0808308919271054e-005;
    offsets[2][0] = 0;
    // LLRTN
    params[3][0] = 1.9000000000000000e+002;
    params[3][1] = 1.3671874999999997e+000;
    params[3][2] = 5.4931640625000050e-004;
    offsets[3][0] = 0;
    // RLRTN
    params[4][0] = 1.2999999999999994e+002;
    params[4][1] = 1.3750000000000033e+000;
    params[4][2] = 6.1035156249998670e-004;
    offsets[4][0] = -4;
    // GARTN
    params[5][0] = 1.5000000000000000e+002;
    params[5][1] = 1.4843749999999997e+000;
    params[5][2] = 7.3242187500000060e-004;
    offsets[5][0] = 0;
    }
    else {
    // LLLNG
    params[0][0] = 100;
    params[0][1] = 2;
    params[0][2] = 0;
    params[0][3] = 0;
    offsets[0][0] = 0;
    offsets[0][1] = 0;
    offsets[0][2] = 0;
    // RLLNG
    params[1][0] = 100;
    params[1][1] = 2;
    params[1][2] = 0;
    params[1][3] = 0;
    offsets[1][0] = 0;
    offsets[1][1] = 0;
    // GALNG
    params[2][0] = 100;
    params[2][1] = 2;
    params[2][2] = 0;
    params[2][3] = 0;
    offsets[2][0] = 0;
    // LLRTN
    params[3][0] = 100;
    params[3][1] = 2;
    params[3][2] = 0;
    offsets[3][0] = 0;
    // RLRTN
    params[4][0] = 100;
    params[4][1] = 2;
    params[4][2] = 0;
    offsets[4][0] = 0;
    // GARTN
    params[5][0] = 100;
    params[5][1] = 2;
    params[5][2] = 0;
    offsets[5][0] = 0;
    }
    #endif
  }

  void write(uint8_t num, uint16_t servoVal) {
    _pwm.setPWM(num, 0, servoVal);
  }

  private:
  Adafruit_PWMServoDriver& _pwm;
};

Adafruit_PWMServoDriver pwm;
ServoShieldPCA9685Linear impl(pwm);
#ifdef GRIS5A
prfServo2<uint32_t, uint8_t, uint16_t, float> servoLib(&impl, 0x0777DD, 0x0);
#elif NO2
prfServo2<uint16_t, uint8_t, uint16_t, float> servoLib(&impl, 0b101010111111, 0b000000000110);
#endif

#endif

//============================================================================
// declare all AO classes...
/*$declare${AOs::Application} ##############################################*/
/*${AOs::Application} ......................................................*/
typedef struct Application {
/* protected: */
    QActive super;

/* public: */
    uint8_t speed;
    uint8_t currentPreSet;
    uint16_t preSetTimer;
} Application;

/* public: */
static bool Application_isCurrentPreSet(Application * const me);

/* protected: */
static QState Application_initial(Application * const me);
static QState Application_Calibration(Application * const me);
static QState Application_Simulation(Application * const me);
static QState Application_ManualMotion(Application * const me);
static QState Application_PreSet(Application * const me);
static QState Application_Wait(Application * const me);
static QState Application_Run(Application * const me);
static QState Application_Remote(Application * const me);
static QState Application_Init(Application * const me);
/*$enddecl${AOs::Application} ##############################################*/
#ifdef DKBIN
/*$declare${AOs::DKbIn} ####################################################*/
/*${AOs::DKbIn} ............................................................*/
typedef struct DKbIn {
/* protected: */
    QActive super;
} DKbIn;

/* public: */
static uint32_t DKbIn_shiftIn32(DKbIn * const me);

/* protected: */
static QState DKbIn_initial(DKbIn * const me);
static QState DKbIn_Read(DKbIn * const me);
/*$enddecl${AOs::DKbIn} ####################################################*/
#endif
#ifdef SERIALIN
/*$declare${AOs::SerialIn} #################################################*/
/*${AOs::SerialIn} .........................................................*/
typedef struct SerialIn {
/* protected: */
    QActive super;

/* public: */
    uint8_t remainingBytes;
} SerialIn;

/* public: */
static void SerialIn_processRemainingBytes(SerialIn * const me);

/* protected: */
static QState SerialIn_initial(SerialIn * const me);
static QState SerialIn_Receive(SerialIn * const me);
/*$enddecl${AOs::SerialIn} #################################################*/
#endif
#ifdef DKBOUT
/*$declare${AOs::DKbOut} ###################################################*/
/*${AOs::DKbOut} ...........................................................*/
typedef struct DKbOut {
/* protected: */
    QActive super;
} DKbOut;

/* protected: */
static QState DKbOut_initial(DKbOut * const me);
static QState DKbOut_LED(DKbOut * const me);
static QState DKbOut_PreSetLED(DKbOut * const me);
static QState DKbOut_ManualMotionLED(DKbOut * const me);
static QState DKbOut_RemoteLED(DKbOut * const me);
static QState DKbOut_CalibrationLED(DKbOut * const me);
/*$enddecl${AOs::DKbOut} ###################################################*/
#endif
#ifdef MOTOROUT
/*$declare${AOs::MotorsOut} ################################################*/
/*${AOs::MotorsOut} ........................................................*/
typedef struct MotorsOut {
/* protected: */
    QActive super;

/* public: */
    uint8_t servoPosition[NUMSERVOS];
    uint8_t target[NUMSERVOS];
    uint8_t stepSize[NUMSERVOS];
    uint16_t _sendPositionCounter;
    uint8_t initializeCounter;
} MotorsOut;

/* public: */
static bool MotorsOut_isInitialized(MotorsOut * const me);

/* protected: */
static QState MotorsOut_initial(MotorsOut * const me);

// Timings:
// servoLib.write for 16 motors takes 9 ms
// Serial print takes 0.2 ms
// Meassured with the oscilloscope and digitalWrite(HIGH/LOW)
static QState MotorsOut_Active(MotorsOut * const me);
static QState MotorsOut_Simulation(MotorsOut * const me);
static QState MotorsOut_Calibration(MotorsOut * const me);
static QState MotorsOut_Wait(MotorsOut * const me);
/*$enddecl${AOs::MotorsOut} ################################################*/
#endif


// AO instances and event queue buffers for them...
Application AO_Application;
static QEvt l_ApplicationQSto[10];
#ifdef DKBIN
DKbIn AO_DKbIn;
static QEvt l_DKbInQSto[1];
#endif
#ifdef SERIALIN
SerialIn AO_SerialIn;
static QEvt l_SerialInQSto[1];
#endif
#ifdef DKBOUT
DKbOut AO_DKbOut;
static QEvt l_DKbOutQSto[1];
#endif
#ifdef MOTOROUT
MotorsOut AO_MotorsOut;
static QEvt l_MotorsOutQSto[NUMSERVOS*2];
#endif

//============================================================================
// events used in this application...
// events.h
// constants.h
//============================================================================

//============================================================================
// QF_active[] array defines all active object control blocks ----------------
QActiveCB const Q_ROM QF_active[] = {
  { (QActive*)0, (QEvt *)0, 0U}, // SGR: required...
  { (QActive*)&AO_Application, l_ApplicationQSto, Q_DIM(l_ApplicationQSto) },
  #ifdef DKBIN
  { (QActive*)&AO_DKbIn, l_DKbInQSto, Q_DIM(l_DKbInQSto) },
  #endif
  #ifdef SERIALIN
  { (QActive*)&AO_SerialIn, l_SerialInQSto, Q_DIM(l_SerialInQSto) },
  #endif
  #ifdef DKBOUT
  { (QActive*)&AO_DKbOut, l_DKbOutQSto, Q_DIM(l_DKbOutQSto) },
  #endif
  #ifdef MOTOROUT
  { (QActive*)&AO_MotorsOut, l_MotorsOutQSto, Q_DIM(l_MotorsOutQSto) }
  #endif
};


//............................................................................
void setup() {
  // initialize the QF-nano framework
  QF_init(Q_DIM(QF_active));

  // initialize all AOs...
  QActive_ctor(&AO_Application.super, Q_STATE_CAST(&Application_initial));
  #ifdef DKBIN
  QActive_ctor(&AO_DKbIn.super, Q_STATE_CAST(&DKbIn_initial));
  #endif
  #ifdef SERIALIN
  QActive_ctor(&AO_SerialIn.super, Q_STATE_CAST(&SerialIn_initial));
  #endif
  #ifdef DKBOUT
  QActive_ctor(&AO_DKbOut.super, Q_STATE_CAST(&DKbOut_initial));
  #endif
  #ifdef MOTOROUT
  QActive_ctor(&AO_MotorsOut.super, Q_STATE_CAST(&MotorsOut_initial));
  #endif

  // initialize the hardware used in this sketch...
  Serial.begin(9600);   // Stanard baud rates: 9600, 38400, 115200 bps
  Serial.print(F("Synced"));
  Serial.print(F("Start, QP-nano: "));
  Serial.println(F(QP_VERSION_STR));

  // Send free memory
  Serial.print(F("|K"));
  Serial.print(freeMemory());
  Serial.print(F("|"));
}

//............................................................................
void loop() {
  QF_run(); // run the QF-nano framework
}

//============================================================================
// interrupts...
ISR(TIMER2_COMPA_vect) {
  QF_tickXISR(0); // process time events for tick rate 0
}

//============================================================================
// QF callbacks...
void QF_onStartup(void) {
  // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking...
  TCCR2A = (1U << WGM21) | (0U << WGM20);
  TCCR2B = (1U << CS22 ) | (1U << CS21) | (1U << CS20); // 1/2^10
  ASSR  &= ~(1U << AS2);
  TIMSK2 = (1U << OCIE2A); // enable TIMER2 compare Interrupt
  TCNT2  = 0U;

  // set the output-compare register based on the desired tick frequency
  OCR2A  = (F_CPU / BSP_TICKS_PER_SEC / 1024U) - 1U;
}
//............................................................................
void QV_onIdle(void) {   // called with interrupts DISABLED
  // Put the CPU and peripherals to the low-power mode. You might
  // need to customize the clock management for your application,
  // see the datasheet for your particular AVR MCU.
  SMCR = (0 << SM0) | (1 << SE); // idle mode, adjust to your project
  QV_CPU_SLEEP();  // atomically go to sleep and enable interrupts
}
//............................................................................
void Q_onAssert(char const Q_ROM* const file, int line) {
  // implement the error-handling policy for your application!!!
  QF_INT_DISABLE(); // disable all interrupts
  QF_RESET();  // reset the CPU
}

//============================================================================
// define all AO classes (state machine)...
/*$skip${QP_VERSION} #######################################################*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 640U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpn version 6.4.0 or higher required
#endif
/*$endskip${QP_VERSION} ####################################################*/
/*$define${AOs::Application} ###############################################*/
/*${AOs::Application} ......................................................*/
/*${AOs::Application::isCurrentPreSet} .....................................*/
static bool Application_isCurrentPreSet(Application * const me) {
    Serial.println("PreSet isCurrentPreSet");

    ProgramChangeEvArgs args(Q_PAR(me));
    return me->currentPreSet == args.ProgNo;
}

/*${AOs::Application::SM} ..................................................*/
static QState Application_initial(Application * const me) {
    /*${AOs::Application::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      PRESETTIMERINTERVAL,
      PRESETTIMERINTERVAL);
    return Q_TRAN(&Application_Simulation);
}
/*${AOs::Application::SM::Calibration} .....................................*/
static QState Application_Calibration(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Calibration} */
        case Q_ENTRY_SIG: {
            Serial.println(F("Calibration"));

            me->speed = 1;

            #ifdef DKBOUT
            QACTIVE_POST((QMActive*)&AO_DKbOut, CALIBRATION_MODE_SIG, 0L);
            #endif

            #ifdef MOTOROUT

            servoLib.end();
            impl.Calibration = true;
            servoLib.begin();
            delay(20);

            QACTIVE_POST((QMActive*)&AO_MotorsOut, CALIBRATION_MODE_SIG, 0L);

            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Calibration::MOTOR_MOVE_RELATIVE} */
        case MOTOR_MOVE_RELATIVE_SIG: {
            // Debug: Serial.println("Calibration Motor Button Pressed");

            MotorMoveRelativeEvArgs args(Q_PAR(me));
            uint8_t step = (me->speed / 3) + 1;
            uint8_t dir = args.getDirection() == FORWARDS ? MOTOR_STEP_FORWARD_SIG : MOTOR_STEP_BACKWARD_SIG;
            // Debug: Serial.print("Servo Num: "); Serial.println(args.ServoNum);

            #ifdef MOTOROUT
              MotorEvArgs m(args.ServoNum, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, dir, m.raw);
            #endif
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Application::SM::Simulation} ......................................*/
static QState Application_Simulation(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Simulation} */
        case Q_ENTRY_SIG: {
            Serial.println("Simulation entry");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::initial} */
        case Q_INIT_SIG: {
            me->speed = 4;
            status_ = Q_TRAN(&Application_Init);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Application::SM::Simulation::ManualMotion} ........................*/
static QState Application_ManualMotion(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Simulation::ManualMotion} */
        case Q_ENTRY_SIG: {
            Serial.println(F("ManualMotion entry"));

            #ifdef DKBOUT
            QACTIVE_POST((QMActive *)&AO_DKbOut, MANUAL_MOTION_MODE_SIG, 0L);
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::ManualMotion::MOTOR_MOVE_RELATIVE} */
        case MOTOR_MOVE_RELATIVE_SIG: {
            // Debug: Serial.print(F("ManualMotion Motor Button Pressed"));

            MotorMoveRelativeEvArgs args(Q_PAR(me));
            uint8_t step = (me->speed / 3) + 1;
            uint8_t dir = args.getDirection() == FORWARDS ? MOTOR_STEP_FORWARD_SIG : MOTOR_STEP_BACKWARD_SIG;
            //Debug: Serial.print("Servo Num: "); Serial.println(args.ServoNum);

            #ifdef MOTOROUT
              MotorEvArgs m(args.ServoNum, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, dir, m.raw);
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::ManualMotion::PROGRAM_CHANGE} */
        case PROGRAM_CHANGE_SIG: {
            Serial.println("ManualMotion Program Button Pressed");

            ProgramChangeEvArgs args(Q_PAR(me));
            me->speed = args.ProgNo;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::ManualMotion::PRESET_MODE} */
        case PRESET_MODE_SIG: {
            Serial.println(F("StateChange PreSet |H|"));
            status_ = Q_TRAN(&Application_PreSet);
            break;
        }
        /*${AOs::Application::SM::Simulation::ManualMotion::REMOTE_MODE} */
        case REMOTE_MODE_SIG: {
            Serial.println(F("StateChange Remote |I|"));
            status_ = Q_TRAN(&Application_Remote);
            break;
        }
        default: {
            status_ = Q_SUPER(&Application_Simulation);
            break;
        }
    }
    return status_;
}
/*${AOs::Application::SM::Simulation::PreSet} ..............................*/
static QState Application_PreSet(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Simulation::PreSet} */
        case Q_ENTRY_SIG: {
            Serial.println(F("PreSet entry"));

            #ifdef DKBOUT
            QACTIVE_POST((QMActive *)&AO_DKbOut, PRESET_MODE_SIG, 0L);
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::PreSet::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Application_Wait);
            break;
        }
        /*${AOs::Application::SM::Simulation::PreSet::REMOTE_MODE} */
        case REMOTE_MODE_SIG: {
            Serial.println(F("StateChange Remote |I|"));
            status_ = Q_TRAN(&Application_Remote);
            break;
        }
        /*${AOs::Application::SM::Simulation::PreSet::MANUAL_MOTION_MODE} */
        case MANUAL_MOTION_MODE_SIG: {
            Serial.println(F("StateChange ManualMotion |G|"));
            status_ = Q_TRAN(&Application_ManualMotion);
            break;
        }
        default: {
            status_ = Q_SUPER(&Application_Simulation);
            break;
        }
    }
    return status_;
}
/*${AOs::Application::SM::Simulation::PreSet::Wait} ........................*/
static QState Application_Wait(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Simulation::PreSet::Wait} */
        case Q_ENTRY_SIG: {
            Serial.println(F("PreSet Wait"));

            me->preSetTimer = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::PreSet::Wait::PROGRAM_CHANGE} */
        case PROGRAM_CHANGE_SIG: {
            Serial.println("PreSet Program Button Pressed");

            ProgramChangeEvArgs args(Q_PAR(me));
            me->currentPreSet = args.ProgNo;
            me->preSetTimer = 0;
            status_ = Q_TRAN(&Application_Run);
            break;
        }
        default: {
            status_ = Q_SUPER(&Application_PreSet);
            break;
        }
    }
    return status_;
}
/*${AOs::Application::SM::Simulation::PreSet::Run} .........................*/
static QState Application_Run(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Simulation::PreSet::Run} */
        case Q_ENTRY_SIG: {
            Serial.println(F("PreSet Run"));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::PreSet::Run::PROGRAM_CHANGE} */
        case PROGRAM_CHANGE_SIG: {
            /*${AOs::Application::SM::Simulation::PreSet::Run::PROGRAM_CHANGE::[currentPreSet]} */
            if (Application_isCurrentPreSet(me)) {
                status_ = Q_HANDLED();
            }
            /*${AOs::Application::SM::Simulation::PreSet::Run::PROGRAM_CHANGE::[else]} */
            else {
                status_ = Q_TRAN(&Application_Wait);
            }
            break;
        }
        /*${AOs::Application::SM::Simulation::PreSet::Run::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            #ifdef MOTOROUT

            if (me->currentPreSet == 1) {
              Serial.println(me->preSetTimer);
              prog1((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 2) {
              prog2((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 3) {
             prog3((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 4) {
              prog4((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 5) {
              prog5((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 6) {
              prog6((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 7) {
              prog7((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 8) {
              prog8((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }

            #endif
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Application_PreSet);
            break;
        }
    }
    return status_;
}
/*${AOs::Application::SM::Simulation::Remote} ..............................*/
static QState Application_Remote(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Simulation::Remote} */
        case Q_ENTRY_SIG: {
            Serial.println(F("Remote"));

            #ifdef DKBOUT
            QACTIVE_POST((QMActive *)&AO_DKbOut, REMOTE_MODE_SIG, 0L);
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::Remote::CALIBRATION_MODE} */
        case CALIBRATION_MODE_SIG: {
            Serial.println(F("StateChange Calibration |J|"));
            status_ = Q_TRAN(&Application_Calibration);
            break;
        }
        /*${AOs::Application::SM::Simulation::Remote::MOTOR_MOVE_ASOLUTE} */
        case MOTOR_MOVE_ASOLUTE_SIG: {
            // Debug: Serial.println("Remote Motor Move Absolute");

            //MotorEvArgs args(rawData);
            #ifdef MOTOROUT
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, Q_PAR(me));
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::Remote::PRESET_MODE} */
        case PRESET_MODE_SIG: {
            Serial.println(F("StateChange PreSet |H|"));
            status_ = Q_TRAN(&Application_PreSet);
            break;
        }
        /*${AOs::Application::SM::Simulation::Remote::MANUAL_MOTION_MODE} */
        case MANUAL_MOTION_MODE_SIG: {
            Serial.println(F("StateChange ManualMotion |G|"));
            status_ = Q_TRAN(&Application_ManualMotion);
            break;
        }
        default: {
            status_ = Q_SUPER(&Application_Simulation);
            break;
        }
    }
    return status_;
}
/*${AOs::Application::SM::Simulation::Init} ................................*/
static QState Application_Init(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Simulation::Init::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            /*${AOs::Application::SM::Simulation::Init::Q_TIMEOUT::[DKbconnected]} */
            if (isDKbEnabled()) {
                Serial.println(F("StateChange ManualMotion |G|"));
                status_ = Q_TRAN(&Application_ManualMotion);
            }
            /*${AOs::Application::SM::Simulation::Init::Q_TIMEOUT::[else]} */
            else {
                Serial.println(F("StateChange Remote |I|"));
                status_ = Q_TRAN(&Application_Remote);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Application_Simulation);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::Application} ###############################################*/
#ifdef DKBIN
/*$define${AOs::DKbIn} #####################################################*/
/*${AOs::DKbIn} ............................................................*/
/*${AOs::DKbIn::shiftIn32} .................................................*/
static uint32_t DKbIn_shiftIn32(DKbIn * const me) {
    uint32_t myDataIn = 0;

    for (int i=31; i>=0; i--)
    {
      digitalWrite(CLOCKPIN_IN, 0);
      delayMicroseconds(2);
      int temp = digitalRead(DATAPIN_IN);
      if (temp) {
        bitSet(myDataIn, i);
        // Debug: Serial.print(i);
      }
      digitalWrite(CLOCKPIN_IN, 1);
    }
    return myDataIn;

}

/*${AOs::DKbIn::SM} ........................................................*/
static QState DKbIn_initial(DKbIn * const me) {
    /*${AOs::DKbIn::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      DKBREADINVERVAL,
      DKBREADINVERVAL);

    pinMode(LATCHPIN_IN, OUTPUT);
    pinMode(CLOCKPIN_IN, OUTPUT);
    pinMode(DATAPIN_IN,  INPUT);

    Serial.println(F("DKbIn Initialized"));
    return Q_TRAN(&DKbIn_Read);
}
/*${AOs::DKbIn::SM::Read} ..................................................*/
static QState DKbIn_Read(DKbIn * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::DKbIn::SM::Read::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            digitalWrite(LATCHPIN_IN, 1);
            delayMicroseconds(20);
            digitalWrite(LATCHPIN_IN, 0);
            uint32_t dkbin = DKbIn_shiftIn32(me);
            // Debug: Serial.println(dkbin, HEX);

            if (dkbin != 0) {
              processDKb((QMActive*)&AO_Application, dkbin);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::DKbIn} #####################################################*/
#endif
#ifdef SERIALIN
/*$define${AOs::SerialIn} ##################################################*/
/*${AOs::SerialIn} .........................................................*/
/*${AOs::SerialIn::processRemainingBytes} ..................................*/
static void SerialIn_processRemainingBytes(SerialIn * const me) {
    while (me->remainingBytes > 1 && Serial.available() > 1) {
      uint8_t tmpLow = Serial.read();
      uint8_t tmpHigh = Serial.read();
      // Debug: Serial.println(tmpLow, HEX); Serial.println(tmpHigh, HEX);
      uint16_t rawData = (tmpHigh << 8) | tmpLow;
      #ifdef MOTOROUT
      MotorEvArgs motorOut(rawData);
      // Debug:
      // Serial.println(F("Serial motor in"));
      // Serial.print(F("Servo Num: "));
      // Serial.println(motorOut.ServoNum);
      // Serial.print(F("Step Size: "));
      // Serial.println(motorOut.StepSize);
      // Serial.print(F("Servo Position: "));
      // Serial.println(motorOut.Pos);
      QACTIVE_POST((QMActive *)&AO_Application, MOTOR_MOVE_ASOLUTE_SIG, motorOut.raw);
      #endif
      me->remainingBytes -= 2;
    }
}

/*${AOs::SerialIn::SM} .....................................................*/
static QState SerialIn_initial(SerialIn * const me) {
    /*${AOs::SerialIn::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      SERIALRECVINVERVAL,
      SERIALRECVINVERVAL);

    me->remainingBytes = 0;

    Serial.println(F("SerialIn Initialized"));
    return Q_TRAN(&SerialIn_Receive);
}
/*${AOs::SerialIn::SM::Receive} ............................................*/
static QState SerialIn_Receive(SerialIn * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::SerialIn::SM::Receive::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            // process unfinished command
            if (me->remainingBytes != 0) {
              // Debug: Serial.print("Process unfinished cmd: "); Serial.println(me->remainingBytes);
              SerialIn_processRemainingBytes(me);
            }
            else if (Serial.available() > 0) {
              int serin = Serial.read();
              //Debug: Serial.println(serin, HEX);

              if (serin > -1) {
                SerialInEvArgs input(serin);
                // Debug: Serial.print(F("Serial Byte: Cmd: 0x"));
                // Debug: Serial.println(input.getCmd(), HEX);
                // Debug: Serial.print(F("Data "));
                // Debug: Serial.println(input.Data, BIN);

                if (input.getCmd() == SOFTDKB) {
                  // Debug: Serial.println(F(" SOFTDKB"));
                  // Command 1: SoftDKb. The same bit is set as from the shift registers of the hardware DKb.
                  processSoftDKb((QMActive*)&AO_Application, input);
                }
                else if (input.getCmd() == ABSMOVE) {
                  // Command 2: Absolute motion for the motors. Each motor requires 16bit/2 bytes.
                  me->remainingBytes = (serin >> 3);
                  // Debug: Serial.print(F("Num bytes: ")); Serial.println(me->remainingBytes);
                  // It is possible that not all bytes are in the serial-in buffer.
                  SerialIn_processRemainingBytes(me);
                }
                else if (input.getCmd() == FREEMEM) {
                  // Send free memory
                  Serial.print(F("|K"));
                  // Debug: int* p = new int[10];
                  // if (p == 0) { Serial.print(999); )
                  Serial.print(freeMemory());
                  Serial.print(F("|"));
                }
                else if (input.getCmd() == SYNC) {
                  // Send sync
                  Serial.print(F("Synced"));
                }
              }
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::SerialIn} ##################################################*/
#endif
#ifdef DKBOUT
/*$define${AOs::DKbOut} ####################################################*/
/*${AOs::DKbOut} ...........................................................*/
/*${AOs::DKbOut::SM} .......................................................*/
static QState DKbOut_initial(DKbOut * const me) {
    /*${AOs::DKbOut::SM::initial} */
    pinMode(CLOCKPIN_OUT, OUTPUT);
    pinMode(LATCHPIN_OUT, OUTPUT);
    pinMode(DATAPIN_OUT,  OUTPUT);

    Serial.println(F("DKbOut Initialized"));
    return Q_TRAN(&DKbOut_LED);
}
/*${AOs::DKbOut::SM::LED} ..................................................*/
static QState DKbOut_LED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::DKbOut::SM::LED::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&DKbOut_ManualMotionLED);
            break;
        }
        /*${AOs::DKbOut::SM::LED::REMOTE_MODE} */
        case REMOTE_MODE_SIG: {
            status_ = Q_TRAN(&DKbOut_RemoteLED);
            break;
        }
        /*${AOs::DKbOut::SM::LED::CALIBRATION_MODE} */
        case CALIBRATION_MODE_SIG: {
            status_ = Q_TRAN(&DKbOut_CalibrationLED);
            break;
        }
        /*${AOs::DKbOut::SM::LED::PRESET_MODE} */
        case PRESET_MODE_SIG: {
            status_ = Q_TRAN(&DKbOut_PreSetLED);
            break;
        }
        /*${AOs::DKbOut::SM::LED::MANUAL_MOTION_MODE} */
        case MANUAL_MOTION_MODE_SIG: {
            status_ = Q_TRAN(&DKbOut_ManualMotionLED);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::LED::PreSetLED} .......................................*/
static QState DKbOut_PreSetLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::DKbOut::SM::LED::PreSetLED} */
        case Q_ENTRY_SIG: {
            // Debug: Serial.println(F("DKbOut: Enter PreSetLED"));

            byte whichPin = 0; // DKb r0: 4;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DKbOut_LED);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::LED::ManualMotionLED} .................................*/
static QState DKbOut_ManualMotionLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::DKbOut::SM::LED::ManualMotionLED} */
        case Q_ENTRY_SIG: {
            // Debug: Serial.println(F("DKbOut: Enter ManualMotionLED"));

            byte whichPin = 1; // DKb r0: 5;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DKbOut_LED);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::LED::RemoteLED} .......................................*/
static QState DKbOut_RemoteLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::DKbOut::SM::LED::RemoteLED} */
        case Q_ENTRY_SIG: {
            // Debug: Serial.println(F("DKbOut: Enter RemoteLED"));

            byte whichPin = 3; // DKb r0: 2;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DKbOut_LED);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::LED::CalibrationLED} ..................................*/
static QState DKbOut_CalibrationLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::DKbOut::SM::LED::CalibrationLED} */
        case Q_ENTRY_SIG: {
            // Debug: Serial.println(F("DKbOut: Enter CalibrationLED"));

            byte whichPin = 2; // DKb r0: 3;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DKbOut_LED);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::DKbOut} ####################################################*/
#endif
#ifdef MOTOROUT
/*$define${AOs::MotorsOut} #################################################*/
/*${AOs::MotorsOut} ........................................................*/
/*${AOs::MotorsOut::isInitialized} .........................................*/
static bool MotorsOut_isInitialized(MotorsOut * const me) {
    return me->initializeCounter == NUMSERVOS;
}

/*${AOs::MotorsOut::SM} ....................................................*/
static QState MotorsOut_initial(MotorsOut * const me) {
    /*${AOs::MotorsOut::SM::initial} */
    // Give the capacitor time to load
    QActive_armX((QActive *)me, 0U,
      MOTORSTARTUPDELAY*5,
      MOTORSTARTUPDELAY*5);

    servoLib.begin();
    me->initializeCounter = 0;

    Serial.println(F("MotorOut Initialized"));
    return Q_TRAN(&MotorsOut_Wait);
}

// Timings:
// servoLib.write for 16 motors takes 9 ms
// Serial print takes 0.2 ms
// Meassured with the oscilloscope and digitalWrite(HIGH/LOW)
/*${AOs::MotorsOut::SM::Active} ............................................*/
static QState MotorsOut_Active(MotorsOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::MotorsOut::SM::Active} */
        case Q_ENTRY_SIG: {
            //
            Serial.println(F("MotorsOut: Enter Active"));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::MotorsOut::SM::Active::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&MotorsOut_Simulation);
            break;
        }
        /*${AOs::MotorsOut::SM::Active::MOTOR_STEP_FORWARD} */
        case MOTOR_STEP_FORWARD_SIG: {
            uint32_t par = Q_PAR(me);
            MotorEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            me->stepSize[data.ServoNum] = data.StepSize;
            int pos = me->servoPosition[data.ServoNum] + data.Pos;
            if (pos < 0) { pos = 0; }
            else if (pos > 255) { pos = 255; }

            me->target[data.ServoNum] = pos;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::MotorsOut::SM::Active::MOTOR_STEP_BACKWARD} */
        case MOTOR_STEP_BACKWARD_SIG: {
            uint32_t par = Q_PAR(me);
            MotorEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            me->stepSize[data.ServoNum] = data.StepSize;
            // Debug: Serial.println(data.StepSize);
            int pos = me->servoPosition[data.ServoNum] - data.Pos;
            if (pos < 0) { pos = 0; }
            else if (pos > 255) { pos = 255; }

            me->target[data.ServoNum] = pos;
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::MotorsOut::SM::Active::Simulation} ................................*/
static QState MotorsOut_Simulation(MotorsOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::MotorsOut::SM::Active::Simulation} */
        case Q_ENTRY_SIG: {
            Serial.println(F("MotorsOut: Enter Simulation"));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::MotorsOut::SM::Active::Simulation::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {

            #ifdef SERIALIN
            bool isMoving = false;
            #endif

            for (int n=0; n < NUMSERVOS; n++) {

              int newPos = me->servoPosition[n];
              if (me->servoPosition[n] < me->target[n]) {
                newPos = min(me->servoPosition[n]+me->stepSize[n], me->target[n]);
              }
              if (me->target[n] < me->servoPosition[n]) {
                newPos = max(me->servoPosition[n]-me->stepSize[n], me->target[n]);
              }
              if (newPos != me->servoPosition[n]) {
                me->servoPosition[n] = newPos;
                #ifdef SERIALIN
                isMoving = true;
                #endif
                servoLib.write(n, me->servoPosition[n]);
              }
            }

            #ifdef SERIALIN
            if (!isMoving) {
              if (me->_sendPositionCounter % NUMSERVOS == 0) {
                int servo = (me->_sendPositionCounter / NUMSERVOS) - 1;
                Serial.print("|");
                Serial.print(servo, HEX);
                Serial.print(me->servoPosition[servo]);
                Serial.print("|");
                if (me->_sendPositionCounter == (NUMSERVOS * NUMSERVOS)) me->_sendPositionCounter = 0;
              }
              me->_sendPositionCounter++;
            }
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::MotorsOut::SM::Active::Simulation::CALIBRATION_MODE} */
        case CALIBRATION_MODE_SIG: {
            Serial.println(F("MotorsOut: Enter Calibration"));

            for (int n = 0; n < NUMSERVOS; n++) {
              servoLib.write(n, 100);
              me->servoPosition[n] = 100;
              me->target[n] = 100;
              me->stepSize[n] = 1;
            }
            status_ = Q_TRAN(&MotorsOut_Calibration);
            break;
        }
        /*${AOs::MotorsOut::SM::Active::Simulation::MOTOR_MOVE_ASOLUTE} */
        case MOTOR_MOVE_ASOLUTE_SIG: {
            uint32_t par = Q_PAR(me);
            MotorEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            me->stepSize[data.ServoNum] = data.StepSize;
            if (data.Pos >= 0 && data.Pos <= 255) {
              me->target[data.ServoNum] = data.Pos;
            } else {
              me->target[data.ServoNum] = me->servoPosition[data.ServoNum];
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&MotorsOut_Active);
            break;
        }
    }
    return status_;
}
/*${AOs::MotorsOut::SM::Active::Calibration} ...............................*/
static QState MotorsOut_Calibration(MotorsOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::MotorsOut::SM::Active::Calibration} */
        case Q_ENTRY_SIG: {
            // Debug: crashes the application Serial.println(F("MotorsOut: Enter Calibration"));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::MotorsOut::SM::Active::Calibration::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {

            #ifdef SERIALIN
            bool isMoving = false;
            #endif

            for (int n=0; n < NUMSERVOS; n++) {

              int newPos = me->servoPosition[n];
              if (me->servoPosition[n] < me->target[n]) {
                newPos = min(me->servoPosition[n]+me->stepSize[n], me->target[n]);
              }
              if (me->target[n] < me->servoPosition[n]) {
                newPos = max(me->servoPosition[n]-me->stepSize[n], me->target[n]);
              }
              if (newPos != me->servoPosition[n]) {
                me->servoPosition[n] = newPos;
                #ifdef SERIALIN
                isMoving = true;
                #endif
                servoLib.write(n, me->servoPosition[n]);
              }
            }

            #ifdef SERIALIN
            if (!isMoving) {
              if (me->_sendPositionCounter % NUMSERVOS  == 0) {
                int servo = (me->_sendPositionCounter / NUMSERVOS) - 1;
                Serial.print("|");
                Serial.print(servo);
                Serial.print(me->servoPosition[servo] * 2 + 100);
                Serial.print("|");
                if (me->_sendPositionCounter == (NUMSERVOS * 10)) me->_sendPositionCounter = 0;
              }
              me->_sendPositionCounter++;
            }
            #endif
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&MotorsOut_Active);
            break;
        }
    }
    return status_;
}
/*${AOs::MotorsOut::SM::Wait} ..............................................*/
static QState MotorsOut_Wait(MotorsOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::MotorsOut::SM::Wait::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            QActive_armX((QActive *)me, 0U,
              MOTORSTARTUPDELAY,
              MOTORSTARTUPDELAY);
            /*${AOs::MotorsOut::SM::Wait::Q_TIMEOUT::[isinitialized]} */
            if (MotorsOut_isInitialized(me)) {
                QActive_armX((QActive *)me, 0U,
                  MOTORSENDINTERVAL,
                  MOTORSENDINTERVAL);

                Serial.println(F("MotorsOut: Enter Active"));
                status_ = Q_TRAN(&MotorsOut_Active);
            }
            /*${AOs::MotorsOut::SM::Wait::Q_TIMEOUT::[else]} */
            else {
                // Debug: Serial.print("Initialize: "); Serial.println(me->initializeCounter);

                servoLib.write(me->initializeCounter, 127);
                me->servoPosition[me->initializeCounter] = 127;
                me->target[me->initializeCounter] = 127;
                me->stepSize[me->initializeCounter] = 1;

                me->initializeCounter++;
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::MotorsOut} #################################################*/
#endif
