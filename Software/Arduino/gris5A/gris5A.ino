/*$file${.::gris5A.ino} ####################################################*/
/*
* Model: gris5A.qm
* File:  ${.::gris5A.ino}
*
* This code has been generated by QM 4.4.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${.::gris5A.ino} #################################################*/
/* gris5A.qm - Arduino software for the GRIS5A (C) motion phantom
 * Copyright (C) 2018-2019 by Stefan Grimm
 */

#include "qpn.h"
#include "Arduino.h"

#define GRIS5A 1
//#define NO2 1

#define DKBIN
#define DKBOUT
#define SERIALIN
#define MOTOROUT

#include "FreeMemory.h"
#include "dkb.h"
#include "preset.h"
#include "events.h"
#include "constants.h"

#ifdef MOTOROUT
#include "_Adafruit_PWMServoDriver.h"
#include "prfServo.h"

class ServoShieldPCA9685Linear : public prfServoImplBase<uint16_t, float> {
  public:
  ServoShieldPCA9685Linear(Adafruit_PWMServoDriver& pwm) : _pwm(pwm) {
    Calibration = false;
  }

  bool Calibration;

  void begin() {
    _pwm.begin();
    _pwm.setPWMFreq(60);
    // Set pwm signal to off.
    // The servo shield does not like signal when it is powered. 1.5 Amperes are flowing.
    // setPWMOn() has interestingly the same effect.
    _pwm.setPWMOff();
  }

  void get(float** params) const {
    if (!Calibration) {
    // LURTN
    params[0][0] = 1.2942268654268088e+002;
    params[0][1] = 1.6668375402407262e+000;
    // LULNG
    params[1][0] = 5.5452380952380930e+002;
    params[1][1] = -2.6484593837534930e+000;
    params[1][2] = 1.1929477673422232e-002;
    params[1][3] = -2.7138883234954693e-005;
    // LLRTN
    params[2][0] = 1.5442914556378040e+002;
    params[2][1] = 1.5882527835305206e+000;
    // LLLNG
    params[3][0] = 1.3666666666666668e+002;
    params[3][1] = 2.8253968253968250e+000;
    params[3][2] = -1.3016971494480146e-002;
    params[3][3] = 3.0757400999615536e-005;
    // RLLNG
    params[4][0] = 5.7880952380952260e+002;
    params[4][1] = -2.3641456582632174e+000;
    params[4][2] = 9.3590377327392710e-003;
    params[4][3] = -2.1711106587961670e-005;
    // RLRTN
    params[5][0] = 1.3774938998134064e+002;
    params[5][1] = 1.5490885603559636e+000;
    // RULNG
    params[6][0] = 1.8559523809523685e+002;
    params[6][1] = 2.1031746031746907e+000;
    params[6][2] = -7.4147305981224840e-003;
    params[6][3] = 1.8092588823305492e-005;
    // RURTN
    params[7][0] = 1.6024944124341286e+002;
    params[7][1] = 1.6079886813344540e+000;
    // GALNG
    params[8][0] = 5.3464285714285590e+002;
    params[8][1] = -2.8109243697478114e+000;
    params[8][2] = 1.3346515076618000e-002;
    params[8][3] = -3.2566659881943620e-005;
    // GARTN
    params[9][0] = 1.4526246180975622e+002;
    params[9][1] = 1.5686194098710244e+000;
    }
    else {
      Serial.println("Calibration");
    // LURTN
    params[0][0] = 100;
    params[0][1] = 2;
    // LULNG
    params[1][0] = 100;
    params[1][1] = 2;
    params[1][2] = 0;
    params[1][3] = 0;
    // LLRTN
    params[2][0] = 100;
    params[2][1] = 2;
    // LLLNG
    params[3][0] = 100;
    params[3][1] = 2;
    params[3][2] = 0;
    params[3][3] = 0;
    // RLLNG
    params[4][0] = 100;
    params[4][1] = 2;
    params[4][2] = 0;
    params[4][3] = 0;
    // RLRTN
    params[5][0] = 100;
    params[5][1] = 2;
    // RULNG
    params[6][0] = 100;
    params[6][1] = 2;
    params[6][2] = 0;
    params[6][3] = 0;
    // RURTN
    params[7][0] = 100;
    params[7][1] = 2;
    // GALNG
    params[8][0] = 100;
    params[8][1] = 4;
    params[8][2] = 0;
    params[8][3] = 0;
    // GARTN
    params[9][0] = 100;
    params[9][1] = 2;
    }
  }

  void write(uint8_t num, uint16_t servoVal) {
    _pwm.setPWM(num, 0, servoVal);
  }

  private:
  Adafruit_PWMServoDriver& _pwm;
};

Adafruit_PWMServoDriver pwm;
ServoShieldPCA9685Linear impl(pwm);
prfServo<uint32_t, uint8_t, uint16_t, float> servoLib(&impl, 0x0777DD);

#define NUMSERVOS 10

#endif


#define Q_PARAM_SIZE   4

//============================================================================
// declare all AO classes...
/*$declare${AOs::Application} ##############################################*/
/*${AOs::Application} ......................................................*/
typedef struct Application {
/* protected: */
    QActive super;

/* public: */
    uint8_t speed;
    uint8_t currentPreSet;
    uint16_t preSetTimer;
} Application;

/* public: */
static bool Application_isCurrentPreSet(Application * const me);

/* protected: */
static QState Application_initial(Application * const me);
static QState Application_Calibration(Application * const me);
static QState Application_Simulation(Application * const me);
static QState Application_ManualMotion(Application * const me);
static QState Application_PreSet(Application * const me);
static QState Application_Wait(Application * const me);
static QState Application_Run(Application * const me);
static QState Application_Remote(Application * const me);
/*$enddecl${AOs::Application} ##############################################*/
#ifdef DKBIN
/*$declare${AOs::DKbIn} ####################################################*/
/*${AOs::DKbIn} ............................................................*/
typedef struct DKbIn {
/* protected: */
    QActive super;
} DKbIn;

/* public: */
static uint32_t DKbIn_shiftIn32(DKbIn * const me);

/* protected: */
static QState DKbIn_initial(DKbIn * const me);
static QState DKbIn_Read(DKbIn * const me);
/*$enddecl${AOs::DKbIn} ####################################################*/
#endif
#ifdef SERIALIN
/*$declare${AOs::SerialIn} #################################################*/
/*${AOs::SerialIn} .........................................................*/
typedef struct SerialIn {
/* protected: */
    QActive super;

/* public: */
    uint8_t remainingBytes;
} SerialIn;

/* public: */
static void SerialIn_processRemainingBytes(SerialIn * const me);

/* protected: */
static QState SerialIn_initial(SerialIn * const me);
static QState SerialIn_Receive(SerialIn * const me);
/*$enddecl${AOs::SerialIn} #################################################*/
#endif
#ifdef MANUALMOTION
/*$declare${AOs::ManualMotion} #############################################*/
/*${AOs::ManualMotion} .....................................................*/
typedef struct ManualMotion {
/* protected: */
    QActive super;

/* public: */
    uint8_t speed;
} ManualMotion;

/* protected: */
static QState ManualMotion_initial(ManualMotion * const me);
static QState ManualMotion_ManualMotion(ManualMotion * const me);
static QState ManualMotion_Idle(ManualMotion * const me);
/*$enddecl${AOs::ManualMotion} #############################################*/
#endif
#ifdef PRESET
/*$declare${AOs::PreSet} ###################################################*/
/*${AOs::PreSet} ...........................................................*/
typedef struct PreSet {
/* protected: */
    QActive super;

/* public: */
    uint8_t currentPreSet;
    uint16_t preSetTimer;
} PreSet;

/* public: */
static bool PreSet_isCurrentPreSet(PreSet * const me);
static void PreSet_prog3(PreSet * const me);
static void PreSet_prog1(PreSet * const me);
static void PreSet_prog2(PreSet * const me);
static void PreSet_prog4(PreSet * const me);
static void PreSet_prog5(PreSet * const me);
static void PreSet_prog6(PreSet * const me);
static void PreSet_prog7(PreSet * const me);
static void PreSet_prog8(PreSet * const me);

/* protected: */
static QState PreSet_initial(PreSet * const me);
static QState PreSet_Idle(PreSet * const me);
static QState PreSet_WaitForProgram(PreSet * const me);
static QState PreSet_RunProgram(PreSet * const me);
/*$enddecl${AOs::PreSet} ###################################################*/
#endif
#ifdef USERPROGRAM
/*$declare${AOs::UserProgram} ##############################################*/
/*${AOs::UserProgram} ......................................................*/
typedef struct UserProgram {
/* protected: */
    QActive super;

/* public: */
    uint8_t userProgramCounter;
    uint8_t userProgram[NUMSERVOS][8];
} UserProgram;

/* protected: */
static QState UserProgram_initial(UserProgram * const me);
static QState UserProgram_Idle(UserProgram * const me);
static QState UserProgram_Record(UserProgram * const me);
static QState UserProgram_Play(UserProgram * const me);
/*$enddecl${AOs::UserProgram} ##############################################*/
#endif
#ifdef DKBOUT
/*$declare${AOs::DKbOut} ###################################################*/
/*${AOs::DKbOut} ...........................................................*/
typedef struct DKbOut {
/* protected: */
    QActive super;
} DKbOut;

/* protected: */
static QState DKbOut_initial(DKbOut * const me);
static QState DKbOut_LED(DKbOut * const me);
static QState DKbOut_PreSetLED(DKbOut * const me);
static QState DKbOut_ManualMotionLED(DKbOut * const me);
static QState DKbOut_RemoteLED(DKbOut * const me);
static QState DKbOut_CalibrationLED(DKbOut * const me);
/*$enddecl${AOs::DKbOut} ###################################################*/
#endif
#ifdef MOTOROUT
/*$declare${AOs::MotorsOut} ################################################*/
/*${AOs::MotorsOut} ........................................................*/
typedef struct MotorsOut {
/* protected: */
    QActive super;

/* public: */
    uint8_t servoPosition[NUMSERVOS];
    uint8_t target[NUMSERVOS];
    uint8_t stepSize[NUMSERVOS];
    uint16_t _sendPositionCounter;
    uint8_t initializeCounter;
} MotorsOut;

/* public: */
static bool MotorsOut_isInitialized(MotorsOut * const me);

/* protected: */
static QState MotorsOut_initial(MotorsOut * const me);

// Timings:
// servoLib.write for 16 motors takes 9 ms
// Serial print takes 0.2 ms
// Meassured with the oscilloscope and digitalWrite(HIGH/LOW)
static QState MotorsOut_Active(MotorsOut * const me);
static QState MotorsOut_Simulation(MotorsOut * const me);
static QState MotorsOut_Calibration(MotorsOut * const me);
static QState MotorsOut_Wait(MotorsOut * const me);
/*$enddecl${AOs::MotorsOut} ################################################*/
#endif


// AO instances and event queue buffers for them...
Application AO_Application;
static QEvt l_ApplicationQSto[10];
#ifdef DKBIN
DKbIn AO_DKbIn;
static QEvt l_DKbInQSto[1];
#endif
#ifdef SERIALIN
SerialIn AO_SerialIn;
static QEvt l_SerialInQSto[1];
#endif
#ifdef MANUALMOTION
ManualMotion AO_ManualMotion;
static QEvt l_ManualMotionQSto[5];
#endif
#ifdef PRESET
PreSet AO_PreSet;
static QEvt l_PreSetQSto[5];
#endif
#ifdef USERPROGRAM
UserProgram AO_UserProgram;
static QEvt l_UserProgramQSto[5];
#endif
#ifdef DKBOUT
DKbOut AO_DKbOut;
static QEvt l_DKbOutQSto[1];
#endif
#ifdef MOTOROUT
MotorsOut AO_MotorsOut;
static QEvt l_MotorsOutQSto[NUMSERVOS*2];
#endif

//============================================================================
// events used in this application...
// events.h
// constants.h
//============================================================================

//============================================================================
// QF_active[] array defines all active object control blocks ----------------
QActiveCB const Q_ROM QF_active[] = {
  { (QActive *)0, (QEvt *)0, 0U}, // SGR: required...
  { (QActive *)&AO_Application, l_ApplicationQSto, Q_DIM(l_ApplicationQSto) },
  #ifdef DKBIN
  { (QActive *)&AO_DKbIn, l_DKbInQSto, Q_DIM(l_DKbInQSto) },
  #endif
  #ifdef SERIALIN
  { (QActive *)&AO_SerialIn, l_SerialInQSto, Q_DIM(l_SerialInQSto) },
  #endif
  #ifdef MANUALMOTION
  { (QActive *)&AO_ManualMotion, l_ManualMotionQSto, Q_DIM(l_ManualMotionQSto) },
  #endif
  #ifdef PRESET
  { (QActive *)&AO_PreSet, l_PreSetQSto, Q_DIM(l_PreSetQSto) },
  #endif
  #ifdef USERPROGRAM
  { (QActive *)&AO_UserProgram, l_UserProgramQSto, Q_DIM(l_UserProgramQSto) },
  #endif
  #ifdef DKBOUT
  { (QActive *)&AO_DKbOut, l_DKbOutQSto, Q_DIM(l_DKbOutQSto) },
  #endif
  #ifdef MOTOROUT
  { (QActive *)&AO_MotorsOut, l_MotorsOutQSto, Q_DIM(l_MotorsOutQSto) }
  #endif
};


//............................................................................
void setup() {
  // initialize the QF-nano framework
  QF_init(Q_DIM(QF_active));

  // initialize all AOs...
  QActive_ctor(&AO_Application.super, Q_STATE_CAST(&Application_initial));
  #ifdef DKBIN
  QActive_ctor(&AO_DKbIn.super, Q_STATE_CAST(&DKbIn_initial));
  #endif
  #ifdef SERIALIN
  QActive_ctor(&AO_SerialIn.super, Q_STATE_CAST(&SerialIn_initial));
  #endif
  #ifdef MANUALMOTION
  QActive_ctor(&AO_ManualMotion.super, Q_STATE_CAST(&ManualMotion_initial));
  #endif
  #ifdef PRESET
  QActive_ctor(&AO_PreSet.super, Q_STATE_CAST(&PreSet_initial));
  #endif
  #ifdef USERPROGRAM
  QActive_ctor(&AO_UserProgram.super, Q_STATE_CAST(&UserProgram_initial));
  #endif
  #ifdef DKBOUT
  QActive_ctor(&AO_DKbOut.super, Q_STATE_CAST(&DKbOut_initial));
  #endif
  #ifdef MOTOROUT
  QActive_ctor(&AO_MotorsOut.super, Q_STATE_CAST(&MotorsOut_initial));
  #endif

  // initialize the hardware used in this sketch...
  Serial.begin(9600);   // Stanard baud rates: 9600, 38400, 115200 bps
  Serial.print(F("Synced"));
  Serial.print(F("Start, QP-nano: "));
  Serial.println(F(QP_VERSION_STR));

  // Send free memory
  Serial.print(F("|E"));
  Serial.print(freeMemory());
  Serial.print(F("|"));
}

//............................................................................
void loop() {
  QF_run(); // run the QF-nano framework
}

//============================================================================
// interrupts...
ISR(TIMER2_COMPA_vect) {
  QF_tickXISR(0); // process time events for tick rate 0
}

//============================================================================
// QF callbacks...
void QF_onStartup(void) {
  // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking...
  TCCR2A = (1U << WGM21) | (0U << WGM20);
  TCCR2B = (1U << CS22 ) | (1U << CS21) | (1U << CS20); // 1/2^10
  ASSR  &= ~(1U << AS2);
  TIMSK2 = (1U << OCIE2A); // enable TIMER2 compare Interrupt
  TCNT2  = 0U;

  // set the output-compare register based on the desired tick frequency
  OCR2A  = (F_CPU / BSP_TICKS_PER_SEC / 1024U) - 1U;
}
//............................................................................
void QV_onIdle(void) {   // called with interrupts DISABLED
  // Put the CPU and peripherals to the low-power mode. You might
  // need to customize the clock management for your application,
  // see the datasheet for your particular AVR MCU.
  SMCR = (0 << SM0) | (1 << SE); // idle mode, adjust to your project
  QV_CPU_SLEEP();  // atomically go to sleep and enable interrupts
}
//............................................................................
void Q_onAssert(char const Q_ROM * const file, int line) {
  // implement the error-handling policy for your application!!!
  QF_INT_DISABLE(); // disable all interrupts
  QF_RESET();  // reset the CPU
}

//============================================================================
// define all AO classes (state machine)...
/*$skip${QP_VERSION} #######################################################*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 640U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpn version 6.4.0 or higher required
#endif
/*$endskip${QP_VERSION} ####################################################*/
/*$define${AOs::Application} ###############################################*/
/*${AOs::Application} ......................................................*/
/*${AOs::Application::isCurrentPreSet} .....................................*/
static bool Application_isCurrentPreSet(Application * const me) {
    Serial.println("PreSet isCurrentPreSet");

    ProgramChangeEvArgs args(Q_PAR(me));
    return me->currentPreSet == args.ProgNo;
}

/*${AOs::Application::SM} ..................................................*/
static QState Application_initial(Application * const me) {
    /*${AOs::Application::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      PRESETTIMERINTERVAL,
      PRESETTIMERINTERVAL);
    return Q_TRAN(&Application_Simulation);
}
/*${AOs::Application::SM::Calibration} .....................................*/
static QState Application_Calibration(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Calibration} */
        case Q_ENTRY_SIG: {
            Serial.println(F("Calibration"));

            me->speed = 1;

            #ifdef DKBOUT
            QACTIVE_POST((QMActive*)&AO_DKbOut, CALIBRATION_MODE_SIG, 0L);
            #endif

            #ifdef MOTOROUT
            QACTIVE_POST((QMActive*)&AO_MotorsOut, CALIBRATION_MODE_SIG, 0L);

            servoLib.end();
            impl.Calibration = true;
            servoLib.begin();

            for (int n=0; n< NUMSERVOS; n++) {
              MotorEvArgs motorOut(n, 127, 1);
              QACTIVE_POST((QMActive*)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, motorOut.raw);
            }
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Calibration::MOTOR_MOVE_RELATIVE} */
        case MOTOR_MOVE_RELATIVE_SIG: {
            // Debug: Serial.println("Calibration Motor Button Pressed");

            MotorMoveRelativeEvArgs args(Q_PAR(me));
            uint8_t step = (me->speed / 3) + 1;
            uint8_t dir = args.getDirection() == FORWARDS ? MOTOR_STEP_FORWARD_SIG : MOTOR_STEP_BACKWARD_SIG;
            // Debug: Serial.print("Servo Num: "); Serial.println(args.ServoNum);

            #ifdef MOTOROUT
              MotorEvArgs m(args.ServoNum, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, dir, m.raw);
            #endif
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Application::SM::Simulation} ......................................*/
static QState Application_Simulation(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Simulation} */
        case Q_ENTRY_SIG: {
            Serial.println("Simulation entry");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::initial} */
        case Q_INIT_SIG: {
            Serial.println(F("StateChange ManualMotion |A|"));

            me->speed = 4;
            status_ = Q_TRAN(&Application_ManualMotion);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Application::SM::Simulation::ManualMotion} ........................*/
static QState Application_ManualMotion(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Simulation::ManualMotion} */
        case Q_ENTRY_SIG: {
            Serial.println(F("ManualMotion entry"));

            #ifdef DKBOUT
            QACTIVE_POST((QMActive *)&AO_DKbOut, MANUAL_MOTION_MODE_SIG, 0L);
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::ManualMotion::MOTOR_MOVE_RELATIVE} */
        case MOTOR_MOVE_RELATIVE_SIG: {
            // Debug: Serial.print(F("ManualMotion Motor Button Pressed"));

            MotorMoveRelativeEvArgs args(Q_PAR(me));
            uint8_t step = (me->speed / 3) + 1;
            uint8_t dir = args.getDirection() == FORWARDS ? MOTOR_STEP_FORWARD_SIG : MOTOR_STEP_BACKWARD_SIG;
            //Debug: Serial.print("Servo Num: "); Serial.println(args.ServoNum);

            #ifdef MOTOROUT
              MotorEvArgs m(args.ServoNum, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, dir, m.raw);
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::ManualMotion::PROGRAM_CHANGE} */
        case PROGRAM_CHANGE_SIG: {
            Serial.println("ManualMotion Program Button Pressed");

            ProgramChangeEvArgs args(Q_PAR(me));
            me->speed = args.ProgNo;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::ManualMotion::PRESET_MODE} */
        case PRESET_MODE_SIG: {
            Serial.println(F("StateChange PreSet |B|"));
            status_ = Q_TRAN(&Application_PreSet);
            break;
        }
        /*${AOs::Application::SM::Simulation::ManualMotion::REMOTE_MODE} */
        case REMOTE_MODE_SIG: {
            Serial.println(F("StateChange Remote |C|"));
            status_ = Q_TRAN(&Application_Remote);
            break;
        }
        default: {
            status_ = Q_SUPER(&Application_Simulation);
            break;
        }
    }
    return status_;
}
/*${AOs::Application::SM::Simulation::PreSet} ..............................*/
static QState Application_PreSet(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Simulation::PreSet} */
        case Q_ENTRY_SIG: {
            Serial.println(F("PreSet entry"));

            #ifdef DKBOUT
            QACTIVE_POST((QMActive *)&AO_DKbOut, PRESET_MODE_SIG, 0L);
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::PreSet::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Application_Wait);
            break;
        }
        /*${AOs::Application::SM::Simulation::PreSet::REMOTE_MODE} */
        case REMOTE_MODE_SIG: {
            status_ = Q_TRAN(&Application_Remote);
            break;
        }
        /*${AOs::Application::SM::Simulation::PreSet::MANUAL_MOTION_MODE} */
        case MANUAL_MOTION_MODE_SIG: {
            status_ = Q_TRAN(&Application_ManualMotion);
            break;
        }
        default: {
            status_ = Q_SUPER(&Application_Simulation);
            break;
        }
    }
    return status_;
}
/*${AOs::Application::SM::Simulation::PreSet::Wait} ........................*/
static QState Application_Wait(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Simulation::PreSet::Wait} */
        case Q_ENTRY_SIG: {
            Serial.println(F("PreSet Wait"));

            me->preSetTimer = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::PreSet::Wait::PROGRAM_CHANGE} */
        case PROGRAM_CHANGE_SIG: {
            Serial.println("PreSet Program Button Pressed");

            ProgramChangeEvArgs args(Q_PAR(me));
            me->currentPreSet = args.ProgNo;
            status_ = Q_TRAN(&Application_Run);
            break;
        }
        default: {
            status_ = Q_SUPER(&Application_PreSet);
            break;
        }
    }
    return status_;
}
/*${AOs::Application::SM::Simulation::PreSet::Run} .........................*/
static QState Application_Run(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Simulation::PreSet::Run} */
        case Q_ENTRY_SIG: {
            Serial.println(F("PreSet Run"));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::PreSet::Run::PROGRAM_CHANGE} */
        case PROGRAM_CHANGE_SIG: {
            /*${AOs::Application::SM::Simulation::PreSet::Run::PROGRAM_CHANGE::[currentPreSet]} */
            if (Application_isCurrentPreSet(me)) {
                status_ = Q_HANDLED();
            }
            /*${AOs::Application::SM::Simulation::PreSet::Run::PROGRAM_CHANGE::[else]} */
            else {
                status_ = Q_TRAN(&Application_Wait);
            }
            break;
        }
        /*${AOs::Application::SM::Simulation::PreSet::Run::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            #ifdef MOTOROUT

            if (me->currentPreSet == 1) {
              prog1((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 2) {
              prog2((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 3) {
             prog3((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 4) {
              prog4((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 5) {
              prog5((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 6) {
              prog6((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 7) {
              prog7((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }
            else if (me->currentPreSet == 8) {
              prog8((QMActive*)&AO_MotorsOut, me->preSetTimer);
            }

            #endif
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Application_PreSet);
            break;
        }
    }
    return status_;
}
/*${AOs::Application::SM::Simulation::Remote} ..............................*/
static QState Application_Remote(Application * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::Application::SM::Simulation::Remote} */
        case Q_ENTRY_SIG: {
            Serial.println(F("Remote"));

            #ifdef DKBOUT
            QACTIVE_POST((QMActive *)&AO_DKbOut, REMOTE_MODE_SIG, 0L);
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::Remote::CALIBRATION_MODE} */
        case CALIBRATION_MODE_SIG: {
            Serial.println(F("StateChange Calibration |D|"));
            status_ = Q_TRAN(&Application_Calibration);
            break;
        }
        /*${AOs::Application::SM::Simulation::Remote::MOTOR_MOVE_ASOLUTE} */
        case MOTOR_MOVE_ASOLUTE_SIG: {
            // Debug: Serial.println("Remote Motor Move Absolute");

            //MotorEvArgs args(rawData);
            #ifdef MOTOROUT
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, Q_PAR(me));
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::Application::SM::Simulation::Remote::PRESET_MODE} */
        case PRESET_MODE_SIG: {
            status_ = Q_TRAN(&Application_PreSet);
            break;
        }
        /*${AOs::Application::SM::Simulation::Remote::MANUAL_MOTION_MODE} */
        case MANUAL_MOTION_MODE_SIG: {
            Serial.println(F("StateChange ManualMotion |A|"));
            status_ = Q_TRAN(&Application_ManualMotion);
            break;
        }
        default: {
            status_ = Q_SUPER(&Application_Simulation);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::Application} ###############################################*/
#ifdef DKBIN
/*$define${AOs::DKbIn} #####################################################*/
/*${AOs::DKbIn} ............................................................*/
/*${AOs::DKbIn::shiftIn32} .................................................*/
static uint32_t DKbIn_shiftIn32(DKbIn * const me) {
    uint32_t myDataIn = 0;

    for (int i=31; i>=0; i--)
    {
      digitalWrite(CLOCKPIN_IN, 0);
      delayMicroseconds(2);
      int temp = digitalRead(DATAPIN_IN);
      if (temp) {
        bitSet(myDataIn, i);
        // Debug: Serial.print(i);
      }
      digitalWrite(CLOCKPIN_IN, 1);
    }
    return myDataIn;

}

/*${AOs::DKbIn::SM} ........................................................*/
static QState DKbIn_initial(DKbIn * const me) {
    /*${AOs::DKbIn::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      DKBREADINVERVAL,
      DKBREADINVERVAL);

    pinMode(LATCHPIN_IN, OUTPUT);
    pinMode(CLOCKPIN_IN, OUTPUT);
    pinMode(DATAPIN_IN,  INPUT);

    Serial.println(F("DKbIn Initialized"));
    return Q_TRAN(&DKbIn_Read);
}
/*${AOs::DKbIn::SM::Read} ..................................................*/
static QState DKbIn_Read(DKbIn * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::DKbIn::SM::Read::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            digitalWrite(LATCHPIN_IN, 1);
            delayMicroseconds(20);
            digitalWrite(LATCHPIN_IN, 0);
            uint32_t dkbin = DKbIn_shiftIn32(me);
            // Debug: Serial.println(dkbin, HEX);

            if (dkbin != 0) {
              processDKb((QMActive*)&AO_Application, dkbin);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::DKbIn} #####################################################*/
#endif
#ifdef SERIALIN
/*$define${AOs::SerialIn} ##################################################*/
/*${AOs::SerialIn} .........................................................*/
/*${AOs::SerialIn::processRemainingBytes} ..................................*/
static void SerialIn_processRemainingBytes(SerialIn * const me) {
    while (me->remainingBytes > 1 && Serial.available() > 1) {
      uint8_t tmpLow = Serial.read();
      uint8_t tmpHigh = Serial.read();
      // Debug: Serial.println(tmpLow, HEX); Serial.println(tmpHigh, HEX);
      uint16_t rawData = (tmpHigh << 8) | tmpLow;
      #ifdef MOTOROUT
      MotorEvArgs motorOut(rawData);
      // Debug:
      // Serial.println(F("Serial motor in"));
      // Serial.print(F("Servo Num: "));
      // Serial.println(motorOut.ServoNum);
      // Serial.print(F("Step Size: "));
      // Serial.println(motorOut.StepSize);
      // Serial.print(F("Servo Position: "));
      // Serial.println(motorOut.Pos);
      QACTIVE_POST((QMActive *)&AO_Application, MOTOR_MOVE_ASOLUTE_SIG, motorOut.raw);
      #endif
      me->remainingBytes -= 2;
    }
}

/*${AOs::SerialIn::SM} .....................................................*/
static QState SerialIn_initial(SerialIn * const me) {
    /*${AOs::SerialIn::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      SERIALRECVINVERVAL,
      SERIALRECVINVERVAL);

    me->remainingBytes = 0;

    Serial.println(F("SerialIn Initialized"));
    return Q_TRAN(&SerialIn_Receive);
}
/*${AOs::SerialIn::SM::Receive} ............................................*/
static QState SerialIn_Receive(SerialIn * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::SerialIn::SM::Receive::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            // process unfinished command
            if (me->remainingBytes != 0) {
              // Debug: Serial.print("Process unfinished cmd: "); Serial.println(me->remainingBytes);
              SerialIn_processRemainingBytes(me);
            }
            else if (Serial.available() > 0) {
              int serin = Serial.read();
              //Debug: Serial.println(serin, HEX);

              if (serin > -1) {
                SerialInEvArgs input(serin);
                // Debug: Serial.print(F("Serial Byte: Cmd: 0x"));
                // Debug: Serial.println(input.getCmd(), HEX);
                // Debug: Serial.print(F("Data "));
                // Debug: Serial.println(input.Data, BIN);

                if (input.getCmd() == SOFTDKB) {
                  // Debug: Serial.println(F(" SOFTDKB"));
                  // Command 1: SoftDKb. The same bit is set as from the shift registers of the hardware DKb.
                  processSoftDKb((QMActive*)&AO_Application, input);
                }
                else if (input.getCmd() == ABSMOVE) {
                  // Command 2: Absolute motion for the motors. Each motor requires 16bit/2 bytes.
                  me->remainingBytes = (serin >> 3);
                  // Debug: Serial.print(F("Num bytes: ")); Serial.println(me->remainingBytes);
                  // It is possible that not all bytes are in the serial-in buffer.
                  SerialIn_processRemainingBytes(me);
                }
                else if (input.getCmd() == FREEMEM) {
                  // Send free memory
                  Serial.print(F("|E"));
                  // Debug: int* p = new int[10];
                  // if (p == 0) { Serial.print(999); )
                  Serial.print(freeMemory());
                  Serial.print(F("|"));
                }
                else if (input.getCmd() == SYNC) {
                  // Send sync
                  Serial.print(F("Synced"));
                }
              }
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::SerialIn} ##################################################*/
#endif
#ifdef MANUALMOTION
/*$define${AOs::ManualMotion} ##############################################*/
/*${AOs::ManualMotion} .....................................................*/
/*${AOs::ManualMotion::SM} .................................................*/
static QState ManualMotion_initial(ManualMotion * const me) {
    /*${AOs::ManualMotion::SM::initial} */
    me->speed = 4;

    Serial.println(F("ManualMotion Initialized"));
    return Q_TRAN(&ManualMotion_ManualMotion);
}
/*${AOs::ManualMotion::SM::ManualMotion} ...................................*/
static QState ManualMotion_ManualMotion(ManualMotion * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::ManualMotion::SM::ManualMotion} */
        case Q_ENTRY_SIG: {
            // Debug: Serial.println(F("ManualMotion: Enter Active"));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::ManualMotion::SM::ManualMotion::USERPROGRAM_PRESSED} */
        case USERPROGRAM_PRESSED_SIG: {
            status_ = Q_TRAN(&ManualMotion_Idle);
            break;
        }
        /*${AOs::ManualMotion::SM::ManualMotion::PRESET_PRESSED} */
        case PRESET_PRESSED_SIG: {
            status_ = Q_TRAN(&ManualMotion_Idle);
            break;
        }
        /*${AOs::ManualMotion::SM::ManualMotion::MOTORBUTTON_PRESSED} */
        case MOTORBUTTON_PRESSED_SIG: {
            #ifdef MOTOROUT
            uint32_t par = Q_PAR(me);
            DKbInEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            uint8_t step = (me->speed / 3) + 1;

            if (data.LUT) {
              // Debug: Serial.println(F("Move left upper lng"));
              MotorEvArgs dm(LULNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LUB) {
              // Debug: Serial.println(F("Move left upper lng"));
              MotorEvArgs dm(LULNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            if (data.LUR) {
              // Debug: Serial.println(F("Move left upper Rtn"));
              MotorEvArgs dm(LURTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LUL) {
              // Debug: Serial.println(F("Move left upper Rtn"));
              MotorEvArgs dm(LURTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.RUT) {
              // Debug: Serial.println(F("Move right upper lng"));
              MotorEvArgs dm(RULNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RUB) {
              // Debug: Serial.println(F("Move right upper lng"));
              MotorEvArgs dm(RULNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            if (data.RUR) {
              // Debug: Serial.println(F("Move right upper Rtn"));
              MotorEvArgs dm(RURTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RUL) {
              // Debug: Serial.println(F("Move right upper Rtn"));
              MotorEvArgs dm(RURTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.LLT) {
              // Debug: Serial.println(F("Move left lower lng"));
              MotorEvArgs dm(LLLNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LLB) {
              // Debug: Serial.println(F("Move left lower lng"));
              MotorEvArgs dm(LLLNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            if (data.LLR) {
              // Debug: Serial.println(F("Move left lower Rtn"));
              MotorEvArgs dm(LLRTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LLL) {
              // Debug: Serial.println(F("Move left lower Rtn"));
              MotorEvArgs dm(LLRTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.RLT) {
              // Debug: Serial.println(F("Move right lower lng"));
              MotorEvArgs dm(RLLNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RLB) {
              // Debug: Serial.println(F("Move right lower lng"));
              MotorEvArgs dm(RLLNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            if (data.RLR) {
              // Debug: Serial.println(F("Move right lower Rtn"));
              MotorEvArgs dm(RLRTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RLL) {
              // Debug: Serial.println(F("Move right lower Rtn"));
              MotorEvArgs dm(RLRTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.GAT) {
              //Serial.println(F("Move Gating lng"));
              MotorEvArgs dm(GALNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.GAB) {
              //Serial.println(F("Move Gating lng"));
              MotorEvArgs dm(GALNG, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            if (data.GAR) {
              //Serial.println(F("Move Gating Rtn"));
              MotorEvArgs dm(GARTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.GAL) {
              //Serial.println(F("Move Gating Rtn"));
              MotorEvArgs dm(GARTN, me->speed, step);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            #endif
            status_ = Q_TRAN(&ManualMotion_ManualMotion);
            break;
        }
        /*${AOs::ManualMotion::SM::ManualMotion::PROGRAMBUTTON_PRESSED} */
        case PROGRAMBUTTON_PRESSED_SIG: {
            #ifdef MOTOROUT
            Serial.println(F("Change speed"));

            uint32_t par = Q_PAR(me);
            DKbInEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            if      (data.FP1) { me->speed = 1; }
            else if (data.FP2) { me->speed = 2; }
            else if (data.FP3) { me->speed = 3; }
            else if (data.FP4) { me->speed = 4; }
            else if (data.FP5) { me->speed = 5; }
            else if (data.FP6) { me->speed = 6; }
            else if (data.FP7) { me->speed = 7; }
            else if (data.FP8) { me->speed = 8; }

            #endif
            status_ = Q_TRAN(&ManualMotion_ManualMotion);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::ManualMotion::SM::Idle} ...........................................*/
static QState ManualMotion_Idle(ManualMotion * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::ManualMotion::SM::Idle} */
        case Q_ENTRY_SIG: {
            Serial.println("ManualMotion: Enter Idle");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::ManualMotion::SM::Idle::MANUAL_MOTION_PRESSED} */
        case MANUAL_MOTION_PRESSED_SIG: {
            status_ = Q_TRAN(&ManualMotion_ManualMotion);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::ManualMotion} ##############################################*/
#endif
#ifdef PRESET
/*$define${AOs::PreSet} ####################################################*/
/*${AOs::PreSet} ...........................................................*/
/*${AOs::PreSet::isCurrentPreSet} ..........................................*/
static bool PreSet_isCurrentPreSet(PreSet * const me) {
    uint32_t par = Q_PAR(me);
    DKbInEvArgs data(par);

    if      (data.FP1 && me->currentPreSet == 1) return true;
    else if (data.FP2 && me->currentPreSet == 2) return true;
    else if (data.FP3 && me->currentPreSet == 3) return true;
    else if (data.FP4 && me->currentPreSet == 4) return true;
    else if (data.FP5 && me->currentPreSet == 5) return true;
    else if (data.FP6 && me->currentPreSet == 6) return true;
    else if (data.FP7 && me->currentPreSet == 7) return true;
    else if (data.FP8 && me->currentPreSet == 8) return true;
    else return false;

}

/*${AOs::PreSet::prog3} ....................................................*/
static void PreSet_prog3(PreSet * const me) {
    // Marker Position 1 <-> 2

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 147, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 147, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 122, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 122, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 107, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 132, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 132, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 107, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, 0, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {
      static const uint8_t PROGMEM STEPSZ = 8;
      float targetDeltaSmall = 10 * sin((me->preSetTimer - 3000) / 3000.0 * PI);
      float targetDeltaLarge = 40 * sin((me->preSetTimer - 3000) / 3000.0 * PI);

      MotorEvArgs lulng(LULNG, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
    }

    if (me->preSetTimer == 8960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}

/*${AOs::PreSet::prog1} ....................................................*/
static void PreSet_prog1(PreSet * const me) {
    // Marker Position 1

    static const uint8_t PROGMEM STEPSZ = 2;
    if (me->preSetTimer == 0) {
      MotorEvArgs lulng(LULNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, 0, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer == 3000) {
      MotorEvArgs lulng(LULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
    }

    if (me->preSetTimer <= 3000) {
      me->preSetTimer += PRESETTIMERINCR;
    }

}

/*${AOs::PreSet::prog2} ....................................................*/
static void PreSet_prog2(PreSet * const me) {
    // Marker Position 2

    static const uint8_t PROGMEM STEPSZ = 2;
    if (me->preSetTimer == 0) {
      MotorEvArgs lulng(LULNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 100, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 70, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 70, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, 0, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer == 3000) {
      MotorEvArgs lulng(LULNG, 167, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 167, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 117, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 117, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 87, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 137, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 137, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 87, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
    }

    if (me->preSetTimer <= 3000) {
      me->preSetTimer += PRESETTIMERINCR;
    }

}

/*${AOs::PreSet::prog4} ....................................................*/
static void PreSet_prog4(PreSet * const me) {
    // Free-breath Gating

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
      MotorEvArgs galng(GALNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {
      static const uint8_t PROGMEM STEPSZ = 8;
      float target = 127 + 80 * sin((me->preSetTimer - 3000) / 2500.0 * PI);

      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (me->preSetTimer == 7960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}

/*${AOs::PreSet::prog5} ....................................................*/
static void PreSet_prog5(PreSet * const me) {
    // Breath-hold Gating

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
      MotorEvArgs galng(GALNG, 60, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000 && me->preSetTimer < 28000) {
      static const uint8_t PROGMEM STEPSZ = 8;
      float target = 60 + 50 * sin((me->preSetTimer - 3000) / 2500.0 * PI);

      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }
    else if (me->preSetTimer == 28000) {
      static const uint8_t PROGMEM STEPSZ = 4;
      MotorEvArgs lulng(LULNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, 250, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }
    else if (me->preSetTimer > 28000 && me->preSetTimer < 38000) {
      static const uint8_t PROGMEM STEPSZ = 8;
      float target = 200 + 50 * cos((me->preSetTimer - 28000) / 40000.0 * PI);
      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }
    else if (me->preSetTimer == 38000) {
      static const uint8_t PROGMEM STEPSZ = 4;
      MotorEvArgs lulng(LULNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, 10, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (me->preSetTimer == 40000) {
      me->preSetTimer = 6720;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}

/*${AOs::PreSet::prog6} ....................................................*/
static void PreSet_prog6(PreSet * const me) {
    // Free-breath Gating, Marker Position 1 <-> 2

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 147, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 147, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 122, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 122, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 107, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 132, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 132, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 107, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {

      static const uint8_t PROGMEM STEPSZ = 8;
      float targetDeltaSmall = 10 * sin((me->preSetTimer - 3000) / 3000.0 * PI);
      float targetDeltaLarge = 40 * sin((me->preSetTimer - 3000) / 3000.0 * PI);
      float targetGating = 127 + 80 * sin((me->preSetTimer - 3000) / 3000.0 * PI);

      MotorEvArgs lulng(LULNG, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 147 + targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 122 - targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 132 + targetDeltaSmall, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 107 - targetDeltaLarge, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);

      MotorEvArgs galng(GALNG, targetGating, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (me->preSetTimer == 8960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}

/*${AOs::PreSet::prog7} ....................................................*/
static void PreSet_prog7(PreSet * const me) {
    // Free-breath Gating loosing signal

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
      MotorEvArgs galng(GALNG, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {
      static const uint8_t PROGMEM STEPSZ = 8;
      float target = 127 + 80 * sin((me->preSetTimer - 3000) / 2500.0 * PI);

      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (me->preSetTimer == 25000) {
      static const uint8_t PROGMEM STEPSZ = 3;

      MotorEvArgs gartn(GARTN, 255, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer == 35000) {
      static const uint8_t PROGMEM STEPSZ = 3;

      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }

    if (me->preSetTimer == 37960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}

/*${AOs::PreSet::prog8} ....................................................*/
static void PreSet_prog8(PreSet * const me) {
    // Free-breath Gating base line shift

    if (me->preSetTimer == 0) {
      static const uint8_t PROGMEM STEPSZ = 2;
      MotorEvArgs lulng(LULNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs lurtn(LURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lurtn.raw);
      MotorEvArgs rulng(RULNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs rurtn(RURTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rurtn.raw);
      MotorEvArgs lllng(LLLNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs llrtn(LLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, llrtn.raw);
      MotorEvArgs rllng(RLLNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs rlrtn(RLRTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rlrtn.raw);
      MotorEvArgs galng(GALNG, 130, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
      MotorEvArgs gartn(GARTN, 127, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, gartn.raw);
    }
    else if (me->preSetTimer >= 3000) {
      static const uint8_t PROGMEM STEPSZ = 8;
      float baseline = 130 + 30 * sin((me->preSetTimer - 3000) / 30000.0 * PI);
      float target = baseline + 50 * sin((me->preSetTimer - 3000) / 3000.0 * PI);

      MotorEvArgs lulng(LULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
      MotorEvArgs rulng(RULNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rulng.raw);
      MotorEvArgs lllng(LLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lllng.raw);
      MotorEvArgs rllng(RLLNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, rllng.raw);
      MotorEvArgs galng(GALNG, target, STEPSZ);
      QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, galng.raw);
    }

    if (me->preSetTimer == 62960) {
      me->preSetTimer = 3000;
    }
    else {
      me->preSetTimer += PRESETTIMERINCR;
    }
}

/*${AOs::PreSet::SM} .......................................................*/
static QState PreSet_initial(PreSet * const me) {
    /*${AOs::PreSet::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      PRESETTIMERINTERVAL,
      PRESETTIMERINTERVAL);

    Serial.println(F("PreSet Initialized"));
    return Q_TRAN(&PreSet_Idle);
}
/*${AOs::PreSet::SM::Idle} .................................................*/
static QState PreSet_Idle(PreSet * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::PreSet::SM::Idle} */
        case Q_ENTRY_SIG: {
            Serial.println("PreSet: Enter Idle");
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::PreSet::SM::Idle::PRESET_PRESSED} */
        case PRESET_PRESSED_SIG: {
            status_ = Q_TRAN(&PreSet_WaitForProgram);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::PreSet::SM::WaitForProgram} .......................................*/
static QState PreSet_WaitForProgram(PreSet * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::PreSet::SM::WaitForProgram} */
        case Q_ENTRY_SIG: {
            Serial.println(F("PreSet: Enter WaitForProgram"));

            me->preSetTimer = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::PreSet::SM::WaitForProgram::MANUAL_MOTION_PRESSED} */
        case MANUAL_MOTION_PRESSED_SIG: {
            status_ = Q_TRAN(&PreSet_Idle);
            break;
        }
        /*${AOs::PreSet::SM::WaitForProgram::USERPROGRAM_PRESSED} */
        case USERPROGRAM_PRESSED_SIG: {
            status_ = Q_TRAN(&PreSet_Idle);
            break;
        }
        /*${AOs::PreSet::SM::WaitForProgram::PROGRAMBUTTON_PRESSED} */
        case PROGRAMBUTTON_PRESSED_SIG: {
            uint32_t par = Q_PAR(me);
            DKbInEvArgs data(par);

            if      (data.FP1) { me->currentPreSet = 1; }
            else if (data.FP2) { me->currentPreSet = 2; }
            else if (data.FP3) { me->currentPreSet = 3; }
            else if (data.FP4) { me->currentPreSet = 4; }
            else if (data.FP5) { me->currentPreSet = 5; }
            else if (data.FP6) { me->currentPreSet = 6; }
            else if (data.FP7) { me->currentPreSet = 7; }
            else if (data.FP8) { me->currentPreSet = 8; }

            me->preSetTimer = 0;
            status_ = Q_TRAN(&PreSet_RunProgram);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::PreSet::SM::RunProgram} ...........................................*/
static QState PreSet_RunProgram(PreSet * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::PreSet::SM::RunProgram} */
        case Q_ENTRY_SIG: {
            // Debug: Serial.println(F("PreSet: Enter RunProgram"));

            // Debug:
            //Serial.print(me->currentPreSet);
            //Serial.print(" ");
            //Serial.println(me->preSetCounter);

            #ifdef MOTOROUT
            if (me->currentPreSet == 1) {
              PreSet_prog1(me);
            }
            else if (me->currentPreSet == 2) {
              PreSet_prog2(me);
            }
            else if (me->currentPreSet == 3) {
              PreSet_prog3(me);
            }
            else if (me->currentPreSet == 4) {
              PreSet_prog4(me);
            }
            else if (me->currentPreSet == 5) {
              PreSet_prog5(me);
            }
            else if (me->currentPreSet == 6) {
              PreSet_prog6(me);
            }
            else if (me->currentPreSet == 7) {
              PreSet_prog7(me);
            }
            else if (me->currentPreSet == 8) {
              PreSet_prog8(me);
            }
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::PreSet::SM::RunProgram::USERPROGRAM_PRESSED} */
        case USERPROGRAM_PRESSED_SIG: {
            status_ = Q_TRAN(&PreSet_Idle);
            break;
        }
        /*${AOs::PreSet::SM::RunProgram::PROGRAMBUTTON_PRESSED} */
        case PROGRAMBUTTON_PRESSED_SIG: {
            /*${AOs::PreSet::SM::RunProgram::PROGRAMBUTTON_PR~::[currentPreSet]} */
            if (PreSet_isCurrentPreSet(me)) {
                status_ = Q_TRAN(&PreSet_RunProgram);
            }
            /*${AOs::PreSet::SM::RunProgram::PROGRAMBUTTON_PR~::[else]} */
            else {
                status_ = Q_TRAN(&PreSet_WaitForProgram);
            }
            break;
        }
        /*${AOs::PreSet::SM::RunProgram::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&PreSet_RunProgram);
            break;
        }
        /*${AOs::PreSet::SM::RunProgram::PRESET_PRESSED} */
        case PRESET_PRESSED_SIG: {
            status_ = Q_TRAN(&PreSet_WaitForProgram);
            break;
        }
        /*${AOs::PreSet::SM::RunProgram::MANUAL_MOTION_PRESSED} */
        case MANUAL_MOTION_PRESSED_SIG: {
            status_ = Q_TRAN(&PreSet_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::PreSet} ####################################################*/
#endif
#ifdef USERPROGRAM
/*$define${AOs::UserProgram} ###############################################*/
/*${AOs::UserProgram} ......................................................*/
/*${AOs::UserProgram::SM} ..................................................*/
static QState UserProgram_initial(UserProgram * const me) {
    /*${AOs::UserProgram::SM::initial} */
    QActive_armX((QActive *)me, 0U,
      USERPROGRAMCOUNTERINTERVAL,
      USERPROGRAMCOUNTERINTERVAL);

    Serial.println(F("UserProgram Initialized"));
    return Q_TRAN(&UserProgram_Idle);
}
/*${AOs::UserProgram::SM::Idle} ............................................*/
static QState UserProgram_Idle(UserProgram * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::UserProgram::SM::Idle} */
        case Q_ENTRY_SIG: {
            Serial.println(F("UserProgram: Enter Idle"));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::UserProgram::SM::Idle::USERPROGRAM_PRESSED} */
        case USERPROGRAM_PRESSED_SIG: {
            memset(me->userProgram, 0, sizeof(me->userProgram));
            status_ = Q_TRAN(&UserProgram_Record);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::UserProgram::SM::Record} ..........................................*/
static QState UserProgram_Record(UserProgram * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::UserProgram::SM::Record} */
        case Q_ENTRY_SIG: {
            Serial.println(F("UserProgram: Enter Record"));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::UserProgram::SM::Record::MANUAL_MOTION_PRESSED} */
        case MANUAL_MOTION_PRESSED_SIG: {
            status_ = Q_TRAN(&UserProgram_Idle);
            break;
        }
        /*${AOs::UserProgram::SM::Record::USERPROGRAM_PLAY_PRESSED} */
        case USERPROGRAM_PLAY_PRESSED_SIG: {
            me->userProgramCounter = 0;
            status_ = Q_TRAN(&UserProgram_Play);
            break;
        }
        /*${AOs::UserProgram::SM::Record::MOTORBUTTON_PRESSED} */
        case MOTORBUTTON_PRESSED_SIG: {
            #ifdef MOTOROUT
            uint32_t par = Q_PAR(me);
            DKbInEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            const uint8_t SPEED = 6;
            const uint8_t STEP = 2;

            if (data.LUT) {
              Serial.println(F("Move left upper lng"));
              MotorEvArgs dm(LULNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LUB) {
              Serial.println(F("Move left upper lng"));
              MotorEvArgs dm(LULNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            else if (data.LUR) {
              Serial.println(F("Move left upper Rtn"));
              MotorEvArgs dm(LURTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LUL) {
              Serial.println(F("Move left upper Rtn"));
              MotorEvArgs dm(LURTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.RUT) {
              Serial.println(F("Move right upper lng"));
              MotorEvArgs dm(RULNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RUB) {
              Serial.println(F("Move right upper lng"));
              MotorEvArgs dm(RULNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            else if (data.RUR) {
              Serial.println(F("Move right upper Rtn"));
              MotorEvArgs dm(RURTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RUL) {
              Serial.println(F("Move right upper Rtn"));
              MotorEvArgs dm(RURTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.LLT) {
              Serial.println(F("Move left lower lng"));
              MotorEvArgs dm(LLLNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LLB) {
              Serial.println(F("Move left lower lng"));
              MotorEvArgs dm(LLLNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            else if (data.LLR) {
              Serial.println(F("Move left lower Rtn"));
              MotorEvArgs dm(LLRTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.LLL) {
              Serial.println(F("Move left lower Rtn"));
              MotorEvArgs dm(LLRTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.RLT) {
              Serial.println(F("Move right lower lng"));
              MotorEvArgs dm(RLLNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RLB) {
              Serial.println(F("Move right lower lng"));
              MotorEvArgs dm(RLLNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            else if (data.RLR) {
              Serial.println(F("Move right lower Rtn"));
              MotorEvArgs dm(RLRTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.RLL) {
              Serial.println(F("Move right lower Rtn"));
              MotorEvArgs dm(RLRTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            if (data.GAT) {
              Serial.println(F("Move Gating lng"));
              MotorEvArgs dm(GALNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.GAB) {
              Serial.println(F("Move Gating lng"));
              MotorEvArgs dm(GALNG, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }
            else if (data.GAR) {
              Serial.println(F("Move Gating Rtn"));
              MotorEvArgs dm(GARTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_FORWARD_SIG, dm.raw);
            }
            else if (data.GAL) {
              Serial.println(F("Move Gating Rtn"));
              MotorEvArgs dm(GARTN, SPEED, STEP);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_STEP_BACKWARD_SIG, dm.raw);
            }

            #endif
            status_ = Q_TRAN(&UserProgram_Record);
            break;
        }
        /*${AOs::UserProgram::SM::Record::PROGRAMBUTTON_PRESSED} */
        case PROGRAMBUTTON_PRESSED_SIG: {
            #ifdef MOTOROUT
            uint32_t par = Q_PAR(me);
            DKbInEvArgs data(par);

            uint8_t selection = 0;
            if (data.FP1) { selection = 0; }
            else if (data.FP2) { selection = 1; }
            else if (data.FP3) { selection = 2; }
            else if (data.FP4) { selection = 3; }
            else if (data.FP5) { selection = 4; }
            else if (data.FP6) { selection = 5; }
            else if (data.FP7) { selection = 6; }
            else if (data.FP8) { selection = 7; }


            Serial.print(F("Programmed positions at second: "));
            Serial.println(selection);

            me->userProgram[0][selection] = AO_MotorsOut.servoPosition[0];
            me->userProgram[1][selection] = AO_MotorsOut.servoPosition[1];
            me->userProgram[2][selection] = AO_MotorsOut.servoPosition[2];
            me->userProgram[3][selection] = AO_MotorsOut.servoPosition[3];
            me->userProgram[4][selection] = AO_MotorsOut.servoPosition[4];
            me->userProgram[5][selection] = AO_MotorsOut.servoPosition[5];
            me->userProgram[6][selection] = AO_MotorsOut.servoPosition[6];
            me->userProgram[7][selection] = AO_MotorsOut.servoPosition[7];
            me->userProgram[8][selection] = AO_MotorsOut.servoPosition[8];
            me->userProgram[9][selection] = AO_MotorsOut.servoPosition[9];
            #endif
            status_ = Q_TRAN(&UserProgram_Record);
            break;
        }
        /*${AOs::UserProgram::SM::Record::PRESET_PRESSED} */
        case PRESET_PRESSED_SIG: {
            status_ = Q_TRAN(&UserProgram_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::UserProgram::SM::Play} ............................................*/
static QState UserProgram_Play(UserProgram * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::UserProgram::SM::Play} */
        case Q_ENTRY_SIG: {
            Serial.println(F("UserProgram: Enter Play"));

            #ifdef MOTOROUT

            for (int motor=0; motor < NUMSERVOS; motor++) {
              MotorEvArgs lulng(ServoNumber(motor), me->userProgram[motor][me->userProgramCounter], 2);
              QACTIVE_POST((QMActive *)&AO_MotorsOut, MOTOR_MOVE_ASOLUTE_SIG, lulng.raw);
            }

            me->userProgramCounter++;
            if (me->userProgramCounter >=8) { me->userProgramCounter = 0; }


            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::UserProgram::SM::Play::USERPROGRAM_PRESSED} */
        case USERPROGRAM_PRESSED_SIG: {
            status_ = Q_TRAN(&UserProgram_Record);
            break;
        }
        /*${AOs::UserProgram::SM::Play::MANUAL_MOTION_PRESSED} */
        case MANUAL_MOTION_PRESSED_SIG: {
            status_ = Q_TRAN(&UserProgram_Idle);
            break;
        }
        /*${AOs::UserProgram::SM::Play::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&UserProgram_Play);
            break;
        }
        /*${AOs::UserProgram::SM::Play::PRESET_PRESSED} */
        case PRESET_PRESSED_SIG: {
            status_ = Q_TRAN(&UserProgram_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::UserProgram} ###############################################*/
#endif
#ifdef DKBOUT
/*$define${AOs::DKbOut} ####################################################*/
/*${AOs::DKbOut} ...........................................................*/
/*${AOs::DKbOut::SM} .......................................................*/
static QState DKbOut_initial(DKbOut * const me) {
    /*${AOs::DKbOut::SM::initial} */
    pinMode(CLOCKPIN_OUT, OUTPUT);
    pinMode(LATCHPIN_OUT, OUTPUT);
    pinMode(DATAPIN_OUT,  OUTPUT);

    Serial.println(F("DKbOut Initialized"));
    return Q_TRAN(&DKbOut_LED);
}
/*${AOs::DKbOut::SM::LED} ..................................................*/
static QState DKbOut_LED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::DKbOut::SM::LED::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&DKbOut_ManualMotionLED);
            break;
        }
        /*${AOs::DKbOut::SM::LED::REMOTE_MODE} */
        case REMOTE_MODE_SIG: {
            status_ = Q_TRAN(&DKbOut_RemoteLED);
            break;
        }
        /*${AOs::DKbOut::SM::LED::CALIBRATION_MODE} */
        case CALIBRATION_MODE_SIG: {
            status_ = Q_TRAN(&DKbOut_CalibrationLED);
            break;
        }
        /*${AOs::DKbOut::SM::LED::PRESET_MODE} */
        case PRESET_MODE_SIG: {
            status_ = Q_TRAN(&DKbOut_PreSetLED);
            break;
        }
        /*${AOs::DKbOut::SM::LED::MANUAL_MOTION_MODE} */
        case MANUAL_MOTION_MODE_SIG: {
            status_ = Q_TRAN(&DKbOut_ManualMotionLED);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::LED::PreSetLED} .......................................*/
static QState DKbOut_PreSetLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::DKbOut::SM::LED::PreSetLED} */
        case Q_ENTRY_SIG: {
            Serial.println(F("DKbOut: Enter PreSetLED |B|"));

            byte whichPin = 0; // DKb r0: 4;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DKbOut_LED);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::LED::ManualMotionLED} .................................*/
static QState DKbOut_ManualMotionLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::DKbOut::SM::LED::ManualMotionLED} */
        case Q_ENTRY_SIG: {
            Serial.println(F("DKbOut: Enter ManualMotionLED |A|"));

            byte whichPin = 1; // DKb r0: 5;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DKbOut_LED);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::LED::RemoteLED} .......................................*/
static QState DKbOut_RemoteLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::DKbOut::SM::LED::RemoteLED} */
        case Q_ENTRY_SIG: {
            Serial.println(F("DKbOut: Enter RemoteLED |C|"));

            byte whichPin = 3; // DKb r0: 2;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DKbOut_LED);
            break;
        }
    }
    return status_;
}
/*${AOs::DKbOut::SM::LED::CalibrationLED} ..................................*/
static QState DKbOut_CalibrationLED(DKbOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::DKbOut::SM::LED::CalibrationLED} */
        case Q_ENTRY_SIG: {
            Serial.println(F("DKbOut: Enter CalibrationLED |D|"));

            byte whichPin = 2; // DKb r0: 3;
            byte bitsToSend = 0;

            digitalWrite(LATCHPIN_OUT, LOW);
            bitWrite(bitsToSend, whichPin, HIGH);
            shiftOut(DATAPIN_OUT, CLOCKPIN_OUT, MSBFIRST, bitsToSend);
            digitalWrite(LATCHPIN_OUT, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&DKbOut_LED);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::DKbOut} ####################################################*/
#endif
#ifdef MOTOROUT
/*$define${AOs::MotorsOut} #################################################*/
/*${AOs::MotorsOut} ........................................................*/
/*${AOs::MotorsOut::isInitialized} .........................................*/
static bool MotorsOut_isInitialized(MotorsOut * const me) {
    return me->initializeCounter == NUMSERVOS;
}

/*${AOs::MotorsOut::SM} ....................................................*/
static QState MotorsOut_initial(MotorsOut * const me) {
    /*${AOs::MotorsOut::SM::initial} */
    // Give the capacitor time to load
    QActive_armX((QActive *)me, 0U,
      MOTORSTARTUPDELAY*5,
      MOTORSTARTUPDELAY*5);

    servoLib.begin();
    me->initializeCounter = 0;

    Serial.println(F("MotorOut Initialized"));
    return Q_TRAN(&MotorsOut_Wait);
}

// Timings:
// servoLib.write for 16 motors takes 9 ms
// Serial print takes 0.2 ms
// Meassured with the oscilloscope and digitalWrite(HIGH/LOW)
/*${AOs::MotorsOut::SM::Active} ............................................*/
static QState MotorsOut_Active(MotorsOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::MotorsOut::SM::Active} */
        case Q_ENTRY_SIG: {
            //
            Serial.println(F("MotorsOut: Enter Active"));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::MotorsOut::SM::Active::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&MotorsOut_Simulation);
            break;
        }
        /*${AOs::MotorsOut::SM::Active::MOTOR_STEP_FORWARD} */
        case MOTOR_STEP_FORWARD_SIG: {
            uint32_t par = Q_PAR(me);
            MotorEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            me->stepSize[data.ServoNum] = data.StepSize;
            int pos = me->servoPosition[data.ServoNum] + data.Pos;
            if (pos < 0) { pos = 0; }
            else if (pos > 255) { pos = 255; }

            me->target[data.ServoNum] = pos;
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::MotorsOut::SM::Active::MOTOR_STEP_BACKWARD} */
        case MOTOR_STEP_BACKWARD_SIG: {
            uint32_t par = Q_PAR(me);
            MotorEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            me->stepSize[data.ServoNum] = data.StepSize;
            // Debug: Serial.println(data.StepSize);
            int pos = me->servoPosition[data.ServoNum] - data.Pos;
            if (pos < 0) { pos = 0; }
            else if (pos > 255) { pos = 255; }

            me->target[data.ServoNum] = pos;
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::MotorsOut::SM::Active::Simulation} ................................*/
static QState MotorsOut_Simulation(MotorsOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::MotorsOut::SM::Active::Simulation} */
        case Q_ENTRY_SIG: {
            Serial.println(F("MotorsOut: Enter Simulation"));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::MotorsOut::SM::Active::Simulation::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {

            #ifdef SERIALIN
            bool isMoving = false;
            #endif

            for (int n=0; n < NUMSERVOS; n++) {

              int newPos = me->servoPosition[n];
              if (me->servoPosition[n] < me->target[n]) {
                newPos = min(me->servoPosition[n]+me->stepSize[n], me->target[n]);
              }
              if (me->target[n] < me->servoPosition[n]) {
                newPos = max(me->servoPosition[n]-me->stepSize[n], me->target[n]);
              }
              if (newPos != me->servoPosition[n]) {
                me->servoPosition[n] = newPos;
                #ifdef SERIALIN
                isMoving = true;
                #endif
                servoLib.write(n, me->servoPosition[n]);
              }
            }

            #ifdef SERIALIN
            if (!isMoving) {
              if (me->_sendPositionCounter % NUMSERVOS == 0) {
                int servo = (me->_sendPositionCounter / NUMSERVOS) - 1;
                Serial.print("|");
                Serial.print(servo);
                Serial.print(me->servoPosition[servo]);
                Serial.print("|");
                if (me->_sendPositionCounter == (NUMSERVOS * 10)) me->_sendPositionCounter = 0;
              }
              me->_sendPositionCounter++;
            }
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::MotorsOut::SM::Active::Simulation::CALIBRATION_MODE} */
        case CALIBRATION_MODE_SIG: {
            Serial.println(F("MotorsOut: Enter Calibration"));
            status_ = Q_TRAN(&MotorsOut_Calibration);
            break;
        }
        /*${AOs::MotorsOut::SM::Active::Simulation::MOTOR_MOVE_ASOLUTE} */
        case MOTOR_MOVE_ASOLUTE_SIG: {
            uint32_t par = Q_PAR(me);
            MotorEvArgs data(par);
            // Debug: Serial.println(par, HEX);

            me->stepSize[data.ServoNum] = data.StepSize;
            if (data.Pos >= 0 && data.Pos <= 255) {
              me->target[data.ServoNum] = data.Pos;
            } else {
              me->target[data.ServoNum] = me->servoPosition[data.ServoNum];
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&MotorsOut_Active);
            break;
        }
    }
    return status_;
}
/*${AOs::MotorsOut::SM::Active::Calibration} ...............................*/
static QState MotorsOut_Calibration(MotorsOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::MotorsOut::SM::Active::Calibration} */
        case Q_ENTRY_SIG: {
            // Debug: crashes the application Serial.println(F("MotorsOut: Enter Calibration"));
            status_ = Q_HANDLED();
            break;
        }
        /*${AOs::MotorsOut::SM::Active::Calibration::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {

            #ifdef SERIALIN
            bool isMoving = false;
            #endif

            for (int n=0; n < NUMSERVOS; n++) {

              int newPos = me->servoPosition[n];
              if (me->servoPosition[n] < me->target[n]) {
                newPos = min(me->servoPosition[n]+me->stepSize[n], me->target[n]);
              }
              if (me->target[n] < me->servoPosition[n]) {
                newPos = max(me->servoPosition[n]-me->stepSize[n], me->target[n]);
              }
              if (newPos != me->servoPosition[n]) {
                me->servoPosition[n] = newPos;
                #ifdef SERIALIN
                isMoving = true;
                #endif

                Serial.println(me->servoPosition[n]);
                servoLib.write(n, me->servoPosition[n]);
              }
            }

            #ifdef SERIALIN
            if (!isMoving) {
              if (me->_sendPositionCounter % NUMSERVOS  == 0) {
                int servo = (me->_sendPositionCounter / NUMSERVOS) - 1;
                Serial.print("|");
                Serial.print(servo);
                Serial.print(me->servoPosition[servo] * 2 + 100);
                Serial.print("|");
                if (me->_sendPositionCounter == (NUMSERVOS * 10)) me->_sendPositionCounter = 0;
              }
              me->_sendPositionCounter++;
            }
            #endif
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&MotorsOut_Active);
            break;
        }
    }
    return status_;
}
/*${AOs::MotorsOut::SM::Wait} ..............................................*/
static QState MotorsOut_Wait(MotorsOut * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*${AOs::MotorsOut::SM::Wait::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            QActive_armX((QActive *)me, 0U,
              MOTORSTARTUPDELAY,
              MOTORSTARTUPDELAY);
            /*${AOs::MotorsOut::SM::Wait::Q_TIMEOUT::[isinitialized]} */
            if (MotorsOut_isInitialized(me)) {
                QActive_armX((QActive *)me, 0U,
                  MOTORSENDINTERVAL,
                  MOTORSENDINTERVAL);

                Serial.println(F("MotorsOut: Enter Active"));
                status_ = Q_TRAN(&MotorsOut_Active);
            }
            /*${AOs::MotorsOut::SM::Wait::Q_TIMEOUT::[else]} */
            else {
                // Debug: Serial.print("Initialize: "); Serial.println(me->initializeCounter);

                servoLib.write(me->initializeCounter, 127);
                me->servoPosition[me->initializeCounter] = 127;
                me->target[me->initializeCounter] = 127;
                me->stepSize[me->initializeCounter] = 1;

                me->initializeCounter++;
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${AOs::MotorsOut} #################################################*/
#endif
